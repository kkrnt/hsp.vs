<?xml version="1.0"?>
<Index xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <command>
    <Name>_debug</Name>
    <Title>デバッグモード時</Title>
    <Format></Format>
    <Setting>
      デバッグモード時のみ定義されるマクロです。
      #ifdef、#ifndef命令などで判別して分岐させることが可能です。
    </Setting>
  </command>
  <command>
    <Name>__hsp30__</Name>
    <Title>ver3.0以降使用時</Title>
    <Format></Format>
    <Setting>HSP3.0以降で、「HSP拡張マクロを使用する」にチェックが入っている時に定義されます。</Setting>
  </command>
  <command>
    <Name>__file__</Name>
    <Title>使用時点で解析されているファイル名</Title>
    <Format></Format>
    <Setting>
      使用時点で解析されているファイル名に置き換えられます。
      ファイルが保存されていない場合は"???"に置き換わります。
    </Setting>
  </command>
  <command>
    <Name>__line__</Name>
    <Title>使用時点で解析されている行番号</Title>
    <Format></Format>
    <Setting>使用時点で解析されている行番号に置き換わります。行番号は1から始まる整数値です。</Setting>
  </command>
  <command>
    <Name>__date__</Name>
    <Title>使用時点の日付</Title>
    <Format></Format>
    <Setting>
      使用時点（コンパイルした時点）の日付に置き換わります。日付はYYYY/MM/DD形式で表されます。

      「HSP拡張マクロを使用する」にチェックが入っていないと使用できません。
    </Setting>
  </command>
  <command>
    <Name>__time__</Name>
    <Title>使用時点の時刻</Title>
    <Format></Format>
    <Setting>
      使用時点（コンパイルした時点）の時刻に置き換わります。時刻はHH:MM:SS形式で表されます。

      「HSP拡張マクロを使用する」にチェックが入っていないと使用できません。
    </Setting>
  </command>
  <command>
    <Name>__hspver__</Name>
    <Title>HSPバージョン番号</Title>
    <Format></Format>
    <Setting>
      HSPのバージョン番号に置き換わります。上位8bit、下位8bitがそれぞれメジャーバージョン・マイナーバージョンを示します。

      「HSP拡張マクロを使用する」にチェックが入っていないと使用できません。
    </Setting>
  </command>
  <command>
    <Name>form_decode</Name>
    <Title>テキストをデコード</Title>
    <Format>
      p1, p2, p3
      p1=変数 : 変換結果を格納する文字列型変数
      p2=変数 : 変換する文字列を代入した文字列型変数
      p3=0〜(0) : 変換スイッチ(0)
    </Format>
    <Setting>
      送信用にエンコードされたテキストを元の日本語にデコードします。

      p3を1にすると'&amp;'を改行に変換し、2にすると'+'を空白に変換します。
      3にすると両方変換します。

      文字コードの変換は行いませんので、文字コード変換が必要な場合はデコード後に行う必要があります。
    </Setting>
  </command>
  <command>
    <Name>fvseti</Name>
    <Title>整数値からベクトル設定</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入される変数名
      (x,y,z) = 整数値
    </Format>
    <Setting>(x,y,z)で指定された整数値をベクトルとしてFV値に代入する。</Setting>
  </command>
  <command>
    <Name>fvset</Name>
    <Title>ベクトル設定</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入される変数名
      (x,y,z) = 計算値(実数値)
    </Format>
    <Setting>(x,y,z)で指定された小数値(X,Y,Z)をベクトルとしてFV値に代入する。</Setting>
  </command>
  <command>
    <Name>fvadd</Name>
    <Title>ベクトル加算</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 計算値(実数値)
    </Format>
    <Setting>(x,y,z)で指定された小数値(X,Y,Z)をFV値に加算する。</Setting>
  </command>
  <command>
    <Name>fvsub</Name>
    <Title>ベクトル減算</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 計算値(実数値)
    </Format>
    <Setting>(x,y,z)で指定された小数値(X,Y,Z)をFV値から減算する。</Setting>
  </command>
  <command>
    <Name>fvmul</Name>
    <Title>ベクトル乗算</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 計算値(実数値)
    </Format>
    <Setting>(x,y,z)で指定された小数値(X,Y,Z)をFV値に並列で乗算する。</Setting>
  </command>
  <command>
    <Name>fvdiv</Name>
    <Title>ベクトル除算</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 計算値(実数値)
    </Format>
    <Setting>(x,y,z)で指定された小数値(X,Y,Z)をFV値に並列で除算する。</Setting>
  </command>
  <command>
    <Name>fvdir</Name>
    <Title>ベクトル回転</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 回転角度(実数値)
    </Format>
    <Setting>
      fvで指定された変数に格納されているFV値をX,Y,Z角度として、
      小数値(X,Y,Z)で指定されたベクトルを回転させた結果を、変数fvに代入します。
    </Setting>
  </command>
  <command>
    <Name>fvface</Name>
    <Title>座標から角度を得る</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = X,Y,Z座標値(実数値)
    </Format>
    <Setting>fvで指定された変数に格納されているベクトル(FV値)を基点とするX,Y,Z座標から、指定されたX,Y,Z座標を直線で見るためのX,Y,Z回転角度を求めて変数fvに代入します。</Setting>
  </command>
  <command>
    <Name>fvmin</Name>
    <Title>ベクトル最小値</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 比較値(実数値)
    </Format>
    <Setting>
      fvで指定された変数に格納されているFV値と、小数値(X,Y,Z)を比較して、値の大きいものを代入します。
      FV値の各要素を最小値までに切り詰める場合に使用します。
    </Setting>
  </command>
  <command>
    <Name>fvmax</Name>
    <Title>ベクトル最大値</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 比較値(実数値)
    </Format>
    <Setting>
      fvで指定された変数に格納されているFV値と、小数値(X,Y,Z)を比較して、値の小さいものを代入します。
      FV値の各要素を最大値までに切り詰める場合に使用します。
    </Setting>
  </command>
  <command>
    <Name>fvouter</Name>
    <Title>ベクトル外積</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 演算するベクトル値(実数値)
    </Format>
    <Setting>fvで指定された変数に格納されているFV値と、小数値(X,Y,Z)で指定するベクトルの外積を求めて代入します。</Setting>
  </command>
  <command>
    <Name>fvinner</Name>
    <Title>ベクトル内積</Title>
    <Format>
      fv,x,y,z
      fv      = FV値が代入されている変数名
      (x,y,z) = 演算するベクトル値(実数値)
    </Format>
    <Setting>fvで指定された変数に格納されているFV値と、小数値(X,Y,Z)で指定するベクトルの内積を求めてfv.0に代入します。</Setting>
  </command>
  <command>
    <Name>fvunit</Name>
    <Title>ベクトル正規化</Title>
    <Format>
      fv
      fv      = FV値が代入されている変数名
    </Format>
    <Setting>fvで指定された変数に格納されているベクトル(FV値)を正規化します。</Setting>
  </command>
  <command>
    <Name>fsin</Name>
    <Title>サインを求める</Title>
    <Format>
      fval,frot
      fval    = 実数値が代入される変数名
      frot    = 回転角度(ラジアン)
    </Format>
    <Setting>
      frotで指定された角度のサイン値をfvalで指定した変数に代入します。
      角度の単位はラジアン(2π=360度)になります。
    </Setting>
  </command>
  <command>
    <Name>fcos</Name>
    <Title>コサインを求める</Title>
    <Format>
      fval,frot
      fval    = 実数値が代入される変数名
      frot    = 回転角度(ラジアン)
    </Format>
    <Setting>
      frotで指定された角度のコサイン値をfvalで指定した変数に代入します。
      角度の単位はラジアン(2π=360度)になります。
    </Setting>
  </command>
  <command>
    <Name>fsqr</Name>
    <Title>平方根を求める</Title>
    <Format>
      fval,fprm
      fval    = 実数値が代入される変数名
      fprm    = 演算に使われる値(実数)
    </Format>
    <Setting>fprmで指定された値の平方根をfvalで指定した変数に代入します。</Setting>
  </command>
  <command>
    <Name>str2fv</Name>
    <Title>文字列をベクトルに変換</Title>
    <Format>
      fv,"x,y,z"
      fv      = FV値が代入される変数名
      "x,y,z" = 「,」で区切られた実数値が格納された文字列
    </Format>
    <Setting>
      "x,y,z"で指定された文字列情報を「,」で区切られたX,Y,Z小数値として読み出し、fvで指定された変数に格納します。
      それぞれの項目が正しく数値として認識できない(不正な)文字列があった場合には、それ以降の項目も含めて0.0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>fv2str</Name>
    <Title>ベクトルを文字列に変換</Title>
    <Format>
      fv
      fv      = FV値が代入されている変数名
    </Format>
    <Setting>fvで指定された変数に格納されているベクトル(FV値)を文字列に変換してシステム変数refstrに結果を返します。</Setting>
  </command>
  <command>
    <Name>str2f</Name>
    <Title>文字列を小数値に変換</Title>
    <Format>
      fval,"fval"
      fval    = 実数値が代入される変数名
      "fval"  = 実数値が格納された文字列
    </Format>
    <Setting>"fval"で指定された文字列情報を小数値として読み出し、fvalで指定された変数に格納します。</Setting>
  </command>
  <command>
    <Name>f2str</Name>
    <Title>小数値を文字列に変換</Title>
    <Format>
      sval,fval
      sval    = 文字列が代入される変数名
      fval    = 変換元の実数値
    </Format>
    <Setting>fvalで指定された小数値を文字列に変換して、valで指定された文字列型の変数に結果を返します。</Setting>
  </command>
  <command>
    <Name>delobj</Name>
    <Title>オブジェクトの削除</Title>
    <Format>
      ObjID
      ObjID  : オブジェクトID
    </Format>
    <Setting>指定されたオブジェクトを削除します。</Setting>
  </command>
  <command>
    <Name>setpos</Name>
    <Title>posグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      posグループ(表示座標)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>setang</Name>
    <Title>angグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      angグループ(表示角度)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
      角度の単位はラジアンになります。
      整数で角度を設定するためのsetangr命令も用意されています。
    </Setting>
  </command>
  <command>
    <Name>setangr</Name>
    <Title>angグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      angグループ(表示角度)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
      角度の単位は整数で0〜255で一周する値を使用します。
      ラジアンで角度を設定するためのsetang命令も用意されています。
    </Setting>
  </command>
  <command>
    <Name>setscale</Name>
    <Title>scaleグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      scaleグループ(表示倍率)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>setdir</Name>
    <Title>dirグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      dirグループ(移動ベクトル)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
      移動ベクトルに登録された値は、オブジェクトの自動移動モード(OBJ_MOVE)時に参照されます。
    </Setting>
  </command>
  <command>
    <Name>setwork</Name>
    <Title>workグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      workグループ(ワーク値)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>addpos</Name>
    <Title>posグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      posグループ(表示座標)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>addang</Name>
    <Title>angグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      angグループ(表示角度)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
      角度の単位はラジアンになります。
      整数で角度を設定するためのsetangr命令も用意されています。
    </Setting>
  </command>
  <command>
    <Name>addangr</Name>
    <Title>angグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      angグループ(表示角度)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
      角度の単位は整数で0〜255で一周する値を使用します。
      ラジアンで角度を設定するためのsetang命令も用意されています。
    </Setting>
  </command>
  <command>
    <Name>addscale</Name>
    <Title>scaleグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      scaleグループ(表示倍率)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>adddir</Name>
    <Title>dirグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      dirグループ(移動ベクトル)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>addwork</Name>
    <Title>workグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      workグループ(ワーク値)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>getpos</Name>
    <Title>posグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      posグループ(表示座標)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getscale</Name>
    <Title>scaleグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      scaleグループ(表示倍率)の内容が(x,y,z)で指定された変数に代入されますます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getdir</Name>
    <Title>dirグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      dirグループ(移動ベクトル)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getwork</Name>
    <Title>workグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      workグループ(ワーク値)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getposi</Name>
    <Title>posグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      posグループ(表示座標)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>getscalei</Name>
    <Title>scaleグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      scaleグループ(表示倍率)の内容が(x,y,z)で指定された変数に代入されますます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>getdiri</Name>
    <Title>dirグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      dirグループ(移動ベクトル)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>getworki</Name>
    <Title>workグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      workグループ(ワーク値)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>selpos</Name>
    <Title>移動座標をMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをpos(座標)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>selang</Name>
    <Title>回転角度をMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをang(回転角度)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>selscale</Name>
    <Title>スケールをMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをscale(スケール)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>seldir</Name>
    <Title>移動量をMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをdir(移動量)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>selwork</Name>
    <Title>オブジェクトワークをMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをwork(ワーク)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>objset3</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      x,y,z
      x   : 設定する値
      y   : 設定する値2
      z   : 設定する値3
    </Format>
    <Setting>
      MOC情報を設定します。
      オフセット番号0から3つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objsetf3</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      fx,fy,fz
      fx  : 設定する値(実数値)
      fy  : 設定する値2(実数値)
      fz  : 設定する値3(実数値)
    </Format>
    <Setting>
      MOC情報を設定します。
      オフセット番号0から3つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objadd3</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      x,y,z
      x   : 加算する値
      y   : 加算する値2
      z   : 加算する値3
    </Format>
    <Setting>
      MOC情報に設定されている値にx,y,zを加算します。
      オフセット番号0から3つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objaddf3</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      fx,fy,fz
      fx  : 加算する値(実数値)
      fy  : 加算する値2(実数値)
      fz  : 加算する値3(実数値)
    </Format>
    <Setting>
      MOC情報に設定されている値にfx,fy,fzを加算します。
      オフセット番号0から3つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objadd3r</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,fx,fy,fz
      ofs : MOCのオフセット番号
      fx  : 加算する値(整数角度値)
      fy  : 加算する値2(整数角度値)
      fz  : 加算する値3(整数角度値)
    </Format>
    <Setting>
      MOC情報に設定されている値にfx,fy,fzを加算します。
      ただし整数値(256で１回転)をラジアン単位に変換したパラメーターを加算します。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objset3r</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      x,y,z
      x   : 設定する値
      y   : 設定する値2
      z   : 設定する値3
    </Format>
    <Setting>
      MOC情報に角度情報を設定します。
      オフセット番号0から3つのパラメータが対象になります。
      整数値(256で１回転)をラジアン単位に変換してパラメーターを書き込みます。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>setobjmode</Name>
    <Title>オブジェクトのモード設定</Title>
    <Format>
      ObjID,mode,sw
      ObjID    : オブジェクトID
      mode     : モード値
      sw       : 設定スイッチ
    </Format>
    <Setting>
      指定されたオブジェクトのモードを変更します。
      モード値は、regobj命令で指定するものと同様です。
      swは、以下のように動作します。

      sw = 0 : 指定したモード値を追加
      sw = 1 : 指定したモード値を削除
      sw = 2 : 指定したモード値だけを設定
    </Setting>
  </command>
  <command>
    <Name>setcoli</Name>
    <Title>オブジェクトのコリジョン設定</Title>
    <Format>
      id,mygroup,enegroup
      id       : オブジェクトID
      mygroup  : 自分が属するグループ値
      enegroup : 衝突を検出する対象となるグループ値
    </Format>
    <Setting>
      オブジェクトに対してコリジョン情報を設定します。
      グループ値は、1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768の中から1つだけを選択可能です。
    </Setting>
  </command>
  <command>
    <Name>getcoli</Name>
    <Title>オブジェクトのコリジョン判定</Title>
    <Format>
      val,id,distance
      val      : 結果が代入される変数名
      id       : オブジェクトID
      distance : 衝突を検出する範囲(実数値)
    </Format>
    <Setting>
      指定したオブジェクトが持つコリジョン情報をもとに、そのオブジェクトが衝突している別なオブジェクトのIDを調べます。
      distanceは、衝突する範囲(半径)を実数値で指定します。
      衝突が検出された場合は、変数にオブジェクトIDが代入されます。
      何も衝突が検出されなかった場合は、-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>getobjcoli</Name>
    <Title>オブジェクトのコリジョングループ取得</Title>
    <Format>
      var,id
      var      : 結果が代入される変数名
      id       : オブジェクトID
    </Format>
    <Setting>
      指定したオブジェクトが所属するコリジョングループを取得し、varで指定された変数に代入します。
      コリジョングループ値は、setcoli命令で設定されたものになります。
    </Setting>
  </command>
  <command>
    <Name>findobj</Name>
    <Title>オブジェクト検索</Title>
    <Format>
      exmode,group
      exmode  : 検索を除外するモード
      group   : 検索対象コリジョングループ値
    </Format>
    <Setting>
      指定したコリジョングループのオブジェクトだけを検索します。
      最初にfindobjを実行して、次にnextobj命令で該当するオブジェクトを検索することができます。
      また、exmodeで指定したモード(regobjで指定するモード値と同じ)は検索から除外されます。
    </Setting>
  </command>
  <command>
    <Name>nextobj</Name>
    <Title>次のオブジェクト検索</Title>
    <Format>
      val
      val      : 結果が代入される変数名
    </Format>
    <Setting>
      findobj命令で指定された条件をもとにオブジェクトを検索します。
      検索されると、変数にオブジェクトIDが代入されます。
      検索対象がなくなった時には-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>setborder</Name>
    <Title>オブジェクト有効範囲設定</Title>
    <Format>
      fx,fy,fz,option
      ( fx,fy,fz ) : ボーダー領域の設定値(実数値)
      option(0) : 設定オプション(0〜2)
    </Format>
    <Setting>
      ボーダー領域(オブジェクト有効範囲)を設定します。
      optionパラメーターにより、( fx,fy,fz )に設定する内容が変わります。
      optionパラメーターを省略するか、または0の場合は、
      ( 0,0,0 )を中心にした、( fx,fy,fz )サイズの立方体がボーダー領域となります。
      optionパラメーターが1の場合は、( fx,fy,fz )の座標を数値が小さい側のボーダー領域として設定します。
      optionパラメーターが2の場合は、( fx,fy,fz )の座標を数値が大きい側のボーダー領域として設定します。
    </Setting>
  </command>
  <command>
    <Name>selmoc</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      id, mocofs
      id     : オブジェクトID
      mocofs : MOCのグループ指定
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループを指定します。
      idは、オブジェクトIDとなります。
      通常は、selpos,selang,selscale,seldir命令をお使いください。
    </Setting>
  </command>
  <command>
    <Name>objgetfv</Name>
    <Title>MOC情報を取得</Title>
    <Format>
      fv
      fv      = FV値が代入される変数名
    </Format>
    <Setting>MOCに設定されている値を変数fvに代入します。</Setting>
  </command>
  <command>
    <Name>objsetfv</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      fv
      fv      = FV値が代入されている変数名
    </Format>
    <Setting>変数fvの内容をMOCに設定します。</Setting>
  </command>
  <command>
    <Name>objaddfv</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      fv
      fv      = FV値が代入されている変数名
    </Format>
    <Setting>変数fvの内容をMOCに加算します。</Setting>
  </command>
  <command>
    <Name>objexist</Name>
    <Title>オブジェクトIDが有効か調べる</Title>
    <Format>
      p1
      p1(0) : オブジェクトID
    </Format>
    <Setting>
      p1で指定されたオブジェクトIDが有効であるか調べます。
      オブジェクトIDが有効(登録済み)の場合は、システム変数statに0が代入されます。
      オブジェクトIDが無効(未登録)の場合は、システム変数statに-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hgini</Name>
    <Title>プラグインの初期化</Title>
    <Format>
      yofs,ysize
      yofs    : 有効スクリーン範囲を縦に+yofsだけずらす
      ysize   : 有効スクリーン範囲を縦にysizeとする
    </Format>
    <Setting>
      HGIMG3の初期化を行ないます。
      最初に必ず初期化をしてからHGIMG3の各命令を使用しなければなりません。
      hgini命令が実行された時点での描画先(ウィンドウID)が表示先として登録されます。
      またその時点での画面初期化モード(ウィンドウモードかフルスクリーンモードか)によって、HGIMG3の描画モードも合わせて設定されます。
      yofs,ysizeの指定が省略されるか0の場合はウィンドウ全体が描画対象になります。
    </Setting>
  </command>
  <command>
    <Name>hgreset</Name>
    <Title>シーン情報の初期化</Title>
    <Format></Format>
    <Setting>
      シーンの情報の初期化を行ないます。
      すべてのモデル、オブジェクト、テクスチャ、イベントリストの情報は破棄され、まったく新しいシーンの状態に戻します。
    </Setting>
  </command>
  <command>
    <Name>hgbye</Name>
    <Title>プラグインの解放</Title>
    <Format></Format>
    <Setting>
      HGIMG3の解放を行ないます。
      プログラムの終了時に自動的に実行されるので、通常は明示する必要はありません。
    </Setting>
  </command>
  <command>
    <Name>hgdraw</Name>
    <Title>描画の実行</Title>
    <Format>
      p1
      p1(0) : モード
    </Format>
    <Setting>
      オブジェクトの全描画処理を実行します。
      デフォルトでは、すべてのオブジェクト描画を行ない画面を更新します。
      hgdrawは、必ずhgsyncと対にして使用する必要があります。
      先にhgdraw命令で描画を行ない、最後にhgsyncで待ち時間を入れるようにしてください。
      p1でモードの指定を行なうことができます。

      モード  内容
      -----------------------------------------------
      1       描画エリアを反映する
      2       Objectの描画を行なわない
      4       画面の初期化を行なわない

      モード値は、加算することで複数指定することが可能です。
      これにより、１つの画面内を描画エリアごとに描画することが可能になります。
    </Setting>
  </command>
  <command>
    <Name>hgsync</Name>
    <Title>時間待ちを行なう</Title>
    <Format>
      val
      val : 待ち時間
    </Format>
    <Setting>
      valで指定した時間(ms)だけウェイトを取ります。
      hgsyncは、必ずhgdrawと対にして使用する必要があります。
      先にhgdraw命令で描画を行ない、最後にhgsyncで待ち時間を入れるようにしてください。
      システム変数statに、HGIMG3による負荷(処理にかかったミリ秒単位の時間)を代入します。
    </Setting>
  </command>
  <command>
    <Name>hgsetreq</Name>
    <Title>システムリクエスト設定</Title>
    <Format>
      type,val
      type : 設定タイプ(SYSREQ_???)
      val  : 設定する値
    </Format>
    <Setting>
      HGIMG3に対して様々なシステム設定を行ないます。
      type値で指定できるのは以下のシンボルです。

      シンボル名        内容
      -----------------------------------------------
      SYSREQ_MAXMODEL   モデル最大数
      SYSREQ_MAXOBJ     オブジェクト最大数
      SYSREQ_MAXTEX     テクスチャ最大数
      SYSREQ_DXMODE     フルスクリーンモードスイッチ
      SYSREQ_DXHWND     ウィンドウハンドル(参照のみ)
      SYSREQ_DXWIDTH    フルスクリーンモード時の横サイズ
      SYSREQ_DXHEIGHT   フルスクリーンモード時の縦サイズ
      SYSREQ_COLORKEY   テクスチャ登録時の透明色コード
      SYSREQ_RESVMODE   エラー発生時の原因コード(参照のみ)
      SYSREQ_MAXEVENT   イベント最大数
      SYSREQ_MDLANIM    モデルあたりのアニメーション最大数
      SYSREQ_CALCNORMAL Xファイルモデル法線再計算スイッチ
      SYSREQ_2DFILTER   2D描画時のテクスチャ補間モード
      SYSREQ_3DFILTER   3D描画時のテクスチャ補間モード
      SYSREQ_OLDCAM     カメラ注視モードの動作
      SYSREQ_QUATALG    Xファイルモデルアニメーション補間モード
      SYSREQ_DXVSYNC    フルスクリーンモード時のVSYNC待ちモード
      SYSREQ_DEFTIMER   hgsyncの時間待ちモード(0=HGIMG3/1=await)
      SYSREQ_NOMIPMAP   テクスチャのMIPMAP生成モード(0=自動/1=MIPMAPなし)
      SYSREQ_DEVLOST    DirectXデバイスの存在フラグ(0=存在/-1=ロスト)
      SYSREQ_MAXEMITTER エミッター最大数
      SYSREQ_THROUGHFLAG　X方向のボーダー処理フラグ(0=通常/1=スルー)
      SYSREQ_OBAQMATBUF OBAQ用マテリアルバッファ数
      SYSREQ_2DFILTER2   2D直接描画時のテクスチャ補間モード
      SYSREQ_FPUPRESERVE FPU演算精度設定オプション(0=単精度/1=変更なし)
      SYSREQ_DSSOFTWARE  ソフトウェアサウンドバッファの使用(1=ON,0=OFF)
      SYSREQ_DSGLOBAL    グローバルサウンドフォーカス(1=ON,0=OFF)
      SYSREQ_DSBUFSEC    oggストリーム再生バッファのサイズ(秒数)
    </Setting>
  </command>
  <command>
    <Name>hggetreq</Name>
    <Title>システムリクエスト取得</Title>
    <Format>
      val,type
      val  : 結果が代入される変数名
      type : 設定タイプ(SYSREQ_???)
    </Format>
    <Setting>
      HGIMG3のシステム設定値を取り出してvalで指定した変数に代入します。
      type値で指定できるのは以下のシンボルです。

      シンボル名        内容
      -----------------------------------------------
      SYSREQ_MAXMODEL   モデル最大数
      SYSREQ_MAXOBJ     オブジェクト最大数
      SYSREQ_MAXTEX     テクスチャ最大数
      SYSREQ_DXMODE     フルスクリーンモードスイッチ
      SYSREQ_DXHWND     ウィンドウハンドル
      SYSREQ_DXWIDTH    フルスクリーンモード時の横サイズ
      SYSREQ_DXHEIGHT   フルスクリーンモード時の縦サイズ
      SYSREQ_COLORKEY   テクスチャ登録時の透明色コード
      SYSREQ_MAXEVENT   イベント最大数
      SYSREQ_RESULT     エラー発生時の原因コード
      SYSREQ_RESVMODE   ステータスコード
      SYSREQ_PTRD3D     DIRECT3D8のCOMポインタ
      SYSREQ_PTRD3DDEV  DIRECT3DDEVICE8のCOMポインタ
    </Setting>
  </command>
  <command>
    <Name>hgrect</Name>
    <Title>矩形の直接描画</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=0〜(0)  : 矩形の中心X座標
      p2=0〜(0)  : 矩形の中心Y座標
      p3=0〜(0.0): 回転角度(単位はラジアン)
      p4=0〜(?)  : Xサイズ
      p5=0〜(?)  : Yサイズ
    </Format>
    <Setting>
      (p1,p2)で指定した座標を中心として、(p4,p5)で指定したサイズの矩形(長方形)を現在設定されている色で描画します。
      p3で回転角度を実数で指定することができます。
      角度の単位は、ラジアン(0から始まって、2πで一周)となります。
      grect命令は、gmodeで設定されたコピーモードの指定が反映されます。

      gmodeが0,1の場合は、通常の塗りつぶし。
      gmodeが3の場合は、指定されたレートで半透明になります。
      gmodeが5,6の場合は、それぞれ色加算、色減算処理となります。
      また、(p4,p5)のサイズ指定を省略した場合には、gmode命令で設定されているコピーサイズが使用されます。

      hgrect命令は、標準命令のgrect命令と同じ動作をHGIMG3の画面に対して行ないます。
      この命令は、直接描画命令です。命令の実行とともに描画が実行されます。
      必ず、hgdrawとhgsyncの間に直接描画を行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>hgrotate</Name>
    <Title>矩形画像の直接描画</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=0〜(0)  : テクスチャID
      p2=0〜(0)  : コピー元の左上X座標
      p3=0〜(0)  : コピー元の左上Y座標
      p4=0〜(0.0): 回転角度(単位はラジアン)
      p5=0〜(?)  : Xサイズ
      p6=0〜(?)  : Yサイズ
    </Format>
    <Setting>
      hgrotate命令は、指定された矩形範囲に回転を含めたテクスチャ描画処理を行ないます。
      p1で、コピー元のテクスチャIDを指定、(p2,p3)でコピーされる元の画像にあたる座標を指定します。(gcopy命令と同様です)
      コピー先は、現在の描画先に指定されているウィンドウIDで、pos命令で設定された場所を中心とした座標にコピーを行ないます。
      その際に、p3で回転角度を実数で指定することができます。
      角度の単位は、ラジアン(0から始まって、2πで一周)となります。
      (p5,p6)で、コピーされた後のX,Yサイズを指定します。
      また、コピー元のX,Yサイズはgmode命令で設定されたデフォルトのコピーサイズが使用されます。
      つまり、gmode命令で指定されたサイズよりも大きなサイズを(p5,p6)で指定した場合には、拡大されることになります。
      (p5,p6)を省略した場合には、コピー元と同じサイズ、つまり等倍でコピーが行なわれます。

      hgrotate命令は、gmodeで設定されたコピーモードの指定が反映されます。
      (詳しくはgmode命令のリファレンスを参照)

      hgrotate命令は、標準命令のgrotate命令と同じ動作をHGIMG3の画面に対して行ないます。
      この命令は、直接描画命令です。命令の実行とともに描画が実行されます。
      必ず、hgdrawとhgsyncの間に直接描画を行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>hgline</Name>
    <Title>直線の直接描画</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜(0)  : 開始X座標
      p2=0〜(0)  : 開始Y座標
      p3=0〜(?)  : 終了X座標
      p4=0〜(?)  : 終了Y座標
    </Format>
    <Setting>
      (p1,p2)で指定した座標から(p3,p4)で指定した座標を結ぶ線を現在設定されている色で描画します。
      hgline命令は、gmodeで設定されたコピーモードの指定が反映されます。

      gmodeが0,1の場合は、通常の塗りつぶし。
      gmodeが3の場合は、指定されたレートで半透明になります。
      gmodeが5,6の場合は、それぞれ色加算、色減算処理となります。

      hgline命令は、標準命令のline命令と同じ動作をHGIMG3の画面に対して行ないます。
      この命令は、直接描画命令です。命令の実行とともに描画が実行されます。
      必ず、hgdrawとhgsyncの間に直接描画を行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>settex</Name>
    <Title>テクスチャを登録</Title>
    <Format>
      x,y,sw,mode
      (x,y)    : テクスチャ登録サイズ
      sw(0)    : テクスチャ登録スイッチ(0=通常/1=Y反転)
      mode(-1) : 更新モード指定(-1=新規)
    </Format>
    <Setting>
      現在選択されているウィンドウIDの内容をテクスチャとして登録します。
      テクスチャの登録に成功すると、システム変数statにテクスチャIDが代入されます。
      失敗した場合はシステム変数statがマイナス値になります。

      swの値が1の場合は、イメージの上下を反転してテクスチャ登録を行ないます。
      mode値が-1または省略された場合は、通常の登録処理が行なわれ、mode値にすでに登録されたテクスチャIDを指定すると、同じIDのテクスチャを現在のウィンドウ内容で更新します。

      通常は、texload命令、texload2命令によってファイルからテクスチャを読み込むようにしてください。
    </Setting>
  </command>
  <command>
    <Name>texload</Name>
    <Title>テクスチャをファイルから登録</Title>
    <Format>
      "filename"
      "filename" : 登録するテクスチャの画像ファイル
    </Format>
    <Setting>
      画像ファイル"filename"の内容をテクスチャとして登録します。
      画像は、picload命令で使用可能なフォーマットと同じもの(BMP,JPG,GIF)が利用可能です。
      テクスチャの登録が終了すると、システム変数statにテクスチャIDが代入されます。
      失敗した場合はエラーダイアログが表示されます。

      texload命令は、2の乗数(2,4,8,16…)サイズでないテクスチャは自動的に適正なサイズに補正します。
      ビデオカードがテクスチャの色モードやサイズに対応していない場合には、ファイルが存在する場合でもエラーになることがあるので注意してください。
      また、アルファチャンネルを含むテクスチャを読み込む場合は、texload2命令を使用してください。

      この命令は、hgimg3.as内のモジュールとして実装されています。
      また、画像読み込み時に、HSPのウィンドウID3を内部で使用しています。
    </Setting>
  </command>
  <command>
    <Name>texload2</Name>
    <Title>テクスチャをファイルから登録</Title>
    <Format>
      "filename",sx,sy
      "filename" : 登録するテクスチャの画像ファイル
      sx,sy      : 基準となるテクスチャサイズ
    </Format>
    <Setting>
      画像ファイル"filename"の内容をテクスチャとして登録します。
      texload命令と同じ動作を行ないますが、DirectXのAPIを使用して読み込みが行なわれます。
      使用可能なフォーマットは、BMP,JPG,GIF,PNG,DDS,TGA,TIFFなどです。
      テクスチャの登録が終了すると、システム変数statにテクスチャIDが代入されます。
      失敗した場合はシステム変数statにマイナス値が代入されます。

      DDSやTGAファイルなどアルファチャンネルを含む画像データは、texload2命令で読み込むことで有効になります。
      ただし、texload2命令はビデオカードのスペックに合わせて画像サイズを最適なサイズに拡大縮小を行なうことがあります。
      必要に応じてtexload、texload2命令を使い分けるようにしてください。

      sx,syでテクスチャサイズを強制的に指定することが可能です。
      通常は、指定を省略していて問題ありません。
    </Setting>
  </command>
  <command>
    <Name>loadtoon</Name>
    <Title>トゥーンテクスチャをファイルから登録</Title>
    <Format>
      p1,"filename"
      p1         : モデルID
      "filename" : 登録するテクスチャの画像ファイル
    </Format>
    <Setting>
      p1で指定したモデルに対してトゥーンシェーディングのモードを設定し、色の情報を持つテクスチャファイルを読み込みます。

      あらかじめ、addxfile命令によりX形式の3Dモデルが読み込まれている必要があります。
      トゥーンシェーディングを設定する場合には、あらかじめトゥーンテクスチャと呼ばれる色情報を持った画像データを作成しておかなければなりません。
      (トゥーンテクスチャは、maketoon命令によって作成することが可能です。)

      この命令は、hgimg3.as内のモジュールとして実装されています。
      また、HSPのウィンドウID3を内部で使用しています。
    </Setting>
  </command>
  <command>
    <Name>maketoon</Name>
    <Title>トゥーンテクスチャを作成</Title>
    <Format>
      p1,p2
      p1    : モデルID
      p2(0) : 作成モード
    </Format>
    <Setting>
      p1で指定したモデルの情報をもとにトゥーンテクスチャの作成を行ないます。
      p2で、作成モードを指定することができます。

      作成モード  内容
      --------------------------------------------------------------
      1         作成されたトゥーンテクスチャをモデルに適用する
      2         作成されたトゥーンテクスチャをファイルにセーブする

      maketoon命令は、モデルの持つマテリアル色を抽出し、標準的なトゥーンテクスチャを作成します。
      作成モードに2を指定した場合は、「toon.bmp」という名前でトゥーンテクスチャを保存します。
      保存されたトゥーンテクスチャは、loadtoon命令で読み込んで使用することが可能なほか、画像を編集することにより、より細かいトゥーンシェーディングの表現を行なうことが可能になります。

      この命令は、hgimg3.as内のモジュールとして実装されています。
      また、HSPのウィンドウID3を内部で使用しています。
    </Setting>
  </command>
  <command>
    <Name>setfont</Name>
    <Title>オリジナルフォント定義</Title>
    <Format>
      cx,cy,px,sw
      ( cx,cy ) : フォント1つあたりのXYサイズ
      px      : 1文字表示ごとに右に移動するドット数
      sw      : 0=透明色抜きなし / 1=透明色抜きあり
    </Format>
    <Setting>
      fprt命令で表示するためのフォントを設定します。
      使用するテクスチャはこの直後に読み込まれたものになります。
    </Setting>
  </command>
  <command>
    <Name>fprt</Name>
    <Title>定義フォント文字列表示</Title>
    <Format>
      "mes",x,y
      "mes"  : 表示する文字列
      ( x,y ) : 表示する座標
    </Format>
    <Setting>
      "mes"の内容を指定されたフォントで画面に表示します。
      必ずhgdraw命令と、hgsync命令の間に使用してください。
      (x,y)の指定は画面の左上が(0,0)になります。
    </Setting>
  </command>
  <command>
    <Name>falpha</Name>
    <Title>フォント文字α値を設定</Title>
    <Format>
      val
      val : フォント表示に使用するα合成値
    </Format>
    <Setting>
      fprt命令によるフォント表示で使用されるα合成値を指定します。
      以降すべてのfprt命令に適用されます。
      α値についての詳細は以下の通りです。

      α合成値 = 0〜255    : 背景とα合成(blend)を行なう
      α合成値 = 256〜511  : 合成を行なわない(通常時)
      α合成値 = 512〜767  : 背景と色加算(modulate)を行なう
      α合成値 = 768〜1023 : 背景と色減算(substract)を行なう
    </Setting>
  </command>
  <command>
    <Name>setsizef</Name>
    <Title>登録モデルの幅、高さを指定</Title>
    <Format>
      fsx,fsy
      (fsx,fsy) : X,Yサイズ(実数値)
    </Format>
    <Setting>モデル登録の際に使用されるサイズ値を指定します。</Setting>
  </command>
  <command>
    <Name>clscolor</Name>
    <Title>背景色設定</Title>
    <Format>
      color
      color : カラーコード
    </Format>
    <Setting>
      単色で塗りつぶす背景色を設定します。
      colorに-1を指定した場合は、背景クリアを行ないません。
      colorはRGBコード($rrggbb)となります。
    </Setting>
  </command>
  <command>
    <Name>clstex</Name>
    <Title>背景テクスチャ設定</Title>
    <Format>
      id
      id : テクスチャID
    </Format>
    <Setting>
      背景となるテクスチャのIDを指定します。
      idに-1を指定した場合は、背景にテクスチャを使わなくなります。
    </Setting>
  </command>
  <command>
    <Name>clsblur</Name>
    <Title>ブラー設定</Title>
    <Format>
      val
      val : 強度(0〜255)
    </Format>
    <Setting>
      擬似ブラー効果を設定します。
      valで設定した強度の値が小さいほど、画面に前のフレームが残像として残ります。
    </Setting>
  </command>
  <command>
    <Name>texmake</Name>
    <Title>メッセージテクスチャの作成</Title>
    <Format>
      p1,p2,p3
      p1(256) : テクスチャXサイズ
      p2(256) : テクスチャYサイズ
      p3(0)   : 作成モード
    </Format>
    <Setting>
      メッセージ描画用テクスチャの作成を行ないます。
      このテクスチャは、texmes命令のメッセージ描画先として使用することができます。

      テクスチャの登録が終了すると、システム変数statにテクスチャIDが代入されます。
      失敗した場合はシステム変数statにマイナス値が代入されます。

      作成モードが0の場合は、16bitテクスチャ(A4R4G4B4)が作成されます。
      0以外の時は、32bitテクスチャ(A8R8G8B8)となります。
      デフォルトでは、16bitテクスチャが作成されます。
      メッセージを扱う場合は、16bitテクスチャの方が速度的にも互換性の上でも有利になります。
      より高精度なメッセージ描画を行なう場合には、32bitテクスチャを指定してください。
    </Setting>
  </command>
  <command>
    <Name>texcls</Name>
    <Title>メッセージテクスチャのクリア</Title>
    <Format>
      p1,p2
      p1    : テクスチャID
      p2(0) : カラーコード
    </Format>
    <Setting>
      メッセージ描画用テクスチャの内容をクリア(消去)します。
      p2で、単色で塗りつぶすための背景色を設定します。
      p2はRGBコード($rrggbb)となります。
    </Setting>
  </command>
  <command>
    <Name>texmes</Name>
    <Title>メッセージテクスチャへの描画</Title>
    <Format>
      "message",p1,p2,p3
      "message" : メッセージ文字列
      p1        : テクスチャID
      p2,p3     : 描画先座標
    </Format>
    <Setting>
      メッセージ描画用テクスチャにメッセージを書き込みます。
      "message"に描画したい文字列を指定することで、p1のテクスチャに書き込みを行ないます。
      あらかじめ、texmake命令によりメッセージ描画用テクスチャを作成しておく必要があるので注意してください。

      texmes命令は、アンチエイリアスを行なった文字をテクスチャに対して書き込みます。
      描画される文字フォントや色は、font命令、color命令で指定されているものが使われます。
      texmes命令は、テクスチャに対して文字列を描画するだけなので、実際に文字列を表示するためには、テクスチャをhgrotate命令やスプライトなどで表示する必要があります。
    </Setting>
  </command>
  <command>
    <Name>texdel</Name>
    <Title>テクスチャの削除</Title>
    <Format>
      p1
      p1    : テクスチャID
    </Format>
    <Setting>
      p1で指定されたテクスチャを削除します。
      削除されたテクスチャは、VRAM上から破棄され新しく入れ替えることができるようになります。
    </Setting>
  </command>
  <command>
    <Name>setuv</Name>
    <Title>登録テクスチャUV座標を指定</Title>
    <Format>
      tx0,ty0,tx1,ty1
      (tx0,ty0) : テクスチャの左上座標
      (tx1,ty1) : テクスチャの右下座標
    </Format>
    <Setting>モデル登録の際に使用されるUV値を指定します。</Setting>
  </command>
  <command>
    <Name>addspr</Name>
    <Title>2Dスプライトモデルを作成</Title>
    <Format>
      var,mode,x1,y1,x2,y2,texid
      var     : 作成されたモデルIDが代入される変数名
      mode    : 0=透明色抜きなし / 1=透明色抜きあり
      (x1,y1) : テクスチャの左上座標
      (x2,y2) : テクスチャの右下座標
      texid   : テクスチャのID
    </Format>
    <Setting>
      2Dスプライトモデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      texidが指定されている場合は、それをテクスチャIDとして参照します。
      texidが省略された場合は、次に登録されるテクスチャが参照されます。
      (x1,y1)-(x2,y2)で参照されるテクスチャの座標を設定することができます。
      (x1,y1)-(x2,y2)の指定を省略した場合には、setuvで指定された値が適用されます。
    </Setting>
  </command>
  <command>
    <Name>regobj</Name>
    <Title>オブジェクトの登録</Title>
    <Format>
      var,ModelID,mode,EventID
      var      : 作成されたオブジェクトIDが代入される変数名
      modelID  : モデルID
      mode     : モード値
      EventID  : イベントID
    </Format>
    <Setting>
      指定されたモデルを表示するためのオブジェクトを作成します。
      成功すると作成されたオブジェクトIDが変数に代入されます。
      何らかの理由で作成に失敗した場合は、-1が代入されます。

      モードは以下の中から選択します。

      ラベル             |        内容
      --------------------------------------------------------------
      OBJ_HIDE             非表示(画面から消す)
      OBJ_TREE             木属性(Y軸のみ正面を向く)
      OBJ_XFRONT           正面属性(常に画面に正面を向く)
      OBJ_MOVE             XYZ移動量を有効にする
      OBJ_FLIP             ボーダー領域で反転する
      OBJ_BORDER           ボーダー領域を有効にする
      OBJ_LATE             常に後から描かれる(半透明オブジェクト用)
      OBJ_FIRST            常に最初に描かれる
      OBJ_SORT             自動的に奥から描かれる(3Dオブジェクト用)
      OBJ_LOOKAT           特定オブジェクトの方向を常に向く
      OBJ_LAND             Y座標を常に一定に保つ
      OBJ_GROUND           地面として認識される
      OBJ_STAND            地面の上に配置する
      OBJ_GRAVITY          重力計算を有効にする
      OBJ_STATIC           障害物として認識される
      OBJ_BOUND            地面で反発する(メッシュマップコリジョン用)
      OBJ_ALIEN            ターゲットに向ける(メッシュマップコリジョン用)
      OBJ_WALKCLIP         移動の制限を受ける(メッシュマップコリジョン用)
      OBJ_EMITTER          エミッター発生オブジェクトになる

      複数の項目を同時に選択する場合は、「OBJ_LATE|OBJ_MOVE」のように「|」で区切って指定してください。何も指定しない場合は、0にするか省略して構いません。
      オブジェクトのモードは、あらかじめデフォルトのモードがモデルの種類に応じて設定されているので、通常は特に設定する必要はありません。
      OBJ_2Dのモードは、自動的に設定されるもので、途中で変更しないようにしてください。
      EventIDを指定すると、該当するイベントがオブジェクトに設定されます。
      EventIDを省略するか、マイナス値の場合はイベントを設定しません。
    </Setting>
  </command>
  <command>
    <Name>addplate</Name>
    <Title>板(PLATE)モデルを作成</Title>
    <Format>
      var,mode,sx,sy,x1,y1,x2,y2,texid
      var     : 作成されたモデルIDが代入される変数名
      mode    : 0=透明色抜きなし / 1=透明色抜きあり
      (sx,sy) : X,Yサイズ
      (x1,y1) : テクスチャの左上座標
      (x2,y2) : テクスチャの右下座標
      texid   : テクスチャID
    </Format>
    <Setting>
      3Dの板(PLATE)モデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      PLATEモデルは、単色またはテクスチャで描画され3D上に配置される四角形です。
      setcolor命令で色が設定されている時は、単色の板になります。
      texidが指定されている場合は、それをテクスチャIDとして参照します。
      texidが省略された場合は、次に登録されるテクスチャが参照されます。
      (sx,sy)で板のX,Yサイズを設定します。省略された場合は、setsizefで指定された値が適用されます。
      (x1,y1)-(x2,y2)で参照されるテクスチャの座標を設定することができます。
      (x1,y1)-(x2,y2)の指定を省略した場合には、setuvで指定された値が適用されます。
      PLATEモデルは、光源計算を行ないません。
      光源計算が必要な場合には、addsplate命令によりSPLATEモデルを作成してください。
    </Setting>
  </command>
  <command>
    <Name>addsplate</Name>
    <Title>板(SPLATE)モデルを作成</Title>
    <Format>
      var,mode,sx,sy,texid
      var     : 作成されたモデルIDが代入される変数名
      mode    : 0=透明色抜きなし / 1=透明色抜きあり
      (sx,sy) : X,Yサイズ
      texid   : テクスチャID
    </Format>
    <Setting>
      3Dの光源計算付き板(SPLATE)モデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      SPLATEモデルは、単色またはテクスチャで描画され3D上に配置される四角形です。
      setcolor命令で色が設定されている時は、単色の板になります。
      texidが指定されている場合は、それをテクスチャIDとして参照します。
      texidが省略された場合は、次に登録されるテクスチャが参照されます。
      (sx,sy)で板のX,Yサイズを設定します。省略された場合は、setsizefで指定された値が適用されます。
      addplate命令とほぼ同じですが、光源計算を行なうことと、テクスチャUV座標の指定ができない点が異なっています。
    </Setting>
  </command>
  <command>
    <Name>setcolor</Name>
    <Title>単色ポリゴン作成設定</Title>
    <Format>
      r,g,b
      r,g,b : RGB色情報(それぞれ0〜255)
    </Format>
    <Setting>
      モデルの作成を行なう際のポリゴン色を設定します。
      addplate,addbox命令などで単色ポリゴンを作成する場合に使用します。
    </Setting>
  </command>
  <command>
    <Name>addbox</Name>
    <Title>箱(BOX)モデルを作成</Title>
    <Format>
      var,sx,sy,texid
      var     : 作成されたモデルIDが代入される変数名
      (sx,sy) : X,Yサイズ
      texid   : テクスチャID
    </Format>
    <Setting>
      箱(BOX)モデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      BOXモデルは、単色またはテクスチャで描画され3D上に配置される立方体です。
      texidが指定されている場合は、それをテクスチャIDとして参照します。
      setcolor命令で色が設定されている時は、単色の箱になります。
      setuv命令によってUVが指定されており、texidが省略された場合は、
      次に登録されるテクスチャが参照されます。(ただしUVの指定は反映されません)
      (sx,sy)で板のX,Yサイズを設定します。省略された場合は、setsizefで指定された値が適用されます。
    </Setting>
  </command>
  <command>
    <Name>addmesh</Name>
    <Title>板(MESH)モデルを作成</Title>
    <Format>
      var,divx,divy,mode,sx,sy,texid
      var     : 作成されたモデルIDが代入される変数名
      divx    : メッシュの分割数X
      divy    : メッシュの分割数Y
      mode    : 0=透明色抜きなし / 1=透明色抜きあり / 16=繰り返し
      (sx,sy) : X,Yサイズ
      texid   : テクスチャID
    </Format>
    <Setting>
      分割された3Dポリゴンを使った板(MESH)を作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      BOXモデルは、テクスチャで描画され3D上に配置される分割メッシュです。
      texidが指定されている場合は、それをテクスチャIDとして参照します。
      setuv命令によってUVが指定されており、texidが省略された場合は、次に登録されるテクスチャが参照されます。(ただしUVの指定は反映されません)
      (sx,sy)で板のX,Yサイズを設定します。省略された場合は、setsizefで指定された値が適用されます。

      基本的にaddplateで作られる板と見た目は同じですが、divsizex × divsizeyのポリゴンに分割されています。
      modeが16の場合は、指定されたテクスチャを1ポリゴンごとに割り付ける繰り返しモードとなります。
    </Setting>
  </command>
  <command>
    <Name>addeprim</Name>
    <Title>エフェクト(EPRIM)モデルを作成</Title>
    <Format>
      var,mode,option
      var     : 作成されたモデルIDが代入される変数名
      mode    : プリミティブモード
      option  : オプション値
    </Format>
    <Setting>
      エフェクト(EPRIM)モデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      エフェクトモデルは、効果生成用の特殊な形状を持ったモデルです。
      エフェクトモデルは頂点ごとに色が設定され、光源計算を行なわない特別なモデルで、形状をseteprim命令でカスタマイズすることができます。
      modeパラメーターにより、以下の形状を選択することができます。

      ラベル             |        内容
      --------------------------------------------------------------
      EPRIM_CIRCLE         円
      EPRIM_CIRCLE2        ギザギザの円
      EPRIM_SQUARE         角の丸い四角形
      EPRIM_FAN            任意の頂点数を持つ多角形

      optionパラメーターにより、モデル作成をコントロールすることができます。
      option値が0か省略された場合は、通常通りのモデルが作成されます。
      option値が1の場合は、モデル本体の生成は行なわず、周囲のりん光(SPREAD)のみ生成します。
      option値が2の場合は、りん光(SPREAD)の生成は行なわず、モデル本体のみ生成します。
    </Setting>
  </command>
  <command>
    <Name>seteprim</Name>
    <Title>エフェクト(EPRIM)モデルを設定</Title>
    <Format>
      Model,Param,Value
      Model   : モデルID
      Param   : パラメーターID
      Value   : パラメーターに設定する値
    </Format>
    <Setting>
      エフェクト(EPRIM)モデルの生成パラメーターを設定します。
      Modelに、addeprim命令によって作成されたモデルIDを指定します。
      Paramに設定するパラメーターIDを、Valueに設定する値を実数か整数により指定します。
      Paramで指定するパラメーターIDは、addeprim命令で作成されたモデル形状により異なります。
      パラメーターIDは、0から8までが実数値による設定が可能です。
      パラメーターIDの16から19までは、色コードの設定となりα値、RGB値を持つ32bitの整数値を設定することができます。
      seteprim命令により、生成パラメーターを変更した後は、表示を行なう際に頂点座標の再構築が行なわれます。
      処理の負荷を軽減するためには、毎フレームごとにseteprim命令を実行するのは避けて、
      必要な場合にのみパラメーター変更を行なうようにしてください。
    </Setting>
  </command>
  <command>
    <Name>setefx</Name>
    <Title>efxグループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      efxグループ(特殊効果設定)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。

      オブジェクトに対し、xの値は次のように認識されます。y,zの値は未使用です。

      0 〜255 : 背景とα合成(blend)を行なう
      256 〜511 : 合成を行なわない(通常時)（現在、ブレンド濃度は関係ありません）
      512 〜767 : 背景と色加算(modulate)を行なう
      768 〜1023 : 背景とα値減算(substract)を行なう
      1024 〜1279 : 背景と色減算(substract2)を行なう（現在、ブレンド濃度は無効になります）
      1280 〜1535 : 合成を行なわない(Z無視)（現在、ブレンド濃度は関係ありません）

      カメラに対し、このパラメータを指定する場合、x,y,zを次のように認識します。

      x : 視野角度。初期値は45度(π/4)が指定されています。
      y : NearZ値。カメラからこの距離より手前のポリゴンは表示されません。
      z : FarZ値。カメラからこの距離より奥のポリゴンは表示されません。
    </Setting>
  </command>
  <command>
    <Name>addefx</Name>
    <Title>efxグループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 加算する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      efxグループ(特殊効果設定)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>getang</Name>
    <Title>angグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      angグループ(表示角度)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getangr</Name>
    <Title>angグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      angグループ(表示角度)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
      角度の単位は整数で0〜255で一周する値を使用します。
    </Setting>
  </command>
  <command>
    <Name>getefx</Name>
    <Title>efxグループ情報を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      efxグループ(特殊効果設定)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getangi</Name>
    <Title>angグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      angグループ(表示角度)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>getefxi</Name>
    <Title>efxグループ情報を整数で取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを取得します。
      efxグループ(特殊効果設定)の内容が(x,y,z)で指定された変数に代入されます。
      (x,y,z)は、整数型の変数として設定されます。
    </Setting>
  </command>
  <command>
    <Name>selefx</Name>
    <Title>オブジェクト特殊効果をMOC情報に設定</Title>
    <Format>
      id
      id     : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをefx(効果)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>objset1</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,x
      ofs : MOCのオフセット番号
      x   : 設定する値
    </Format>
    <Setting>MOC情報を設定します。</Setting>
  </command>
  <command>
    <Name>objsetf1</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,fx
      ofs : MOCのオフセット番号
      fx  : 設定する値(実数値)
    </Format>
    <Setting>MOC情報を設定します。</Setting>
  </command>
  <command>
    <Name>objadd1</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,x
      ofs : MOCのオフセット番号
      x   : 加算する値
    </Format>
    <Setting>MOC情報に設定されている値にxを加算します。</Setting>
  </command>
  <command>
    <Name>objadd1r</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,x
      ofs : MOCのオフセット番号
      x   : 加算する値(整数角度値)
    </Format>
    <Setting>
      MOC情報に設定されている値にxを加算します。
      ただし整数値(256で１回転)をラジアン単位に変換したパラメーターを加算します。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objaddf1</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,fx
      ofs : MOCのオフセット番号
      fx  : 加算する値(実数値)
    </Format>
    <Setting>MOC情報に設定されている値にfxを加算します。</Setting>
  </command>
  <command>
    <Name>objset1r</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,x
      ofs : MOCのオフセット番号
      x   : 設定する値
    </Format>
    <Setting>
      MOC情報に角度情報を設定します。
      整数値(256で１回転)をラジアン単位に変換してパラメーターを書き込みます。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objset2</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,x,y
      ofs : MOCのオフセット番号
      x   : 設定する値
      y   : 設定する値2
    </Format>
    <Setting>
      MOC情報を設定します。
      ofsで指定したオフセット番号から２つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objsetf2</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,fx,fy
      ofs : MOCのオフセット番号
      fx  : 設定する値(実数値)
      fy  : 設定する値2(実数値)
    </Format>
    <Setting>
      MOC情報を設定します。
      ofsで指定したオフセット番号から２つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objadd2</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,x,y
      ofs : MOCのオフセット番号
      x   : 加算する値
      y   : 加算する値2
    </Format>
    <Setting>
      MOC情報に設定されている値にx,yを加算します。
      ofsで指定したオフセット番号から２つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objaddf2</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,fx,fy
      ofs : MOCのオフセット番号
      fx  : 加算する値(実数値)
      fy  : 加算する値2(実数値)
    </Format>
    <Setting>
      MOC情報に設定されている値にfx,fyを加算します。
      ofsで指定したオフセット番号から２つのパラメータが対象になります。
    </Setting>
  </command>
  <command>
    <Name>objadd2r</Name>
    <Title>MOC情報を加算</Title>
    <Format>
      ofs,fx,fy
      ofs : MOCのオフセット番号
      fx  : 加算する値(整数角度値)
      fy  : 加算する値2(整数角度値)
    </Format>
    <Setting>
      MOC情報に設定されている値にfx,fyを加算します。
      ただし整数値(256で１回転)をラジアン単位に変換したパラメーターを加算します。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objset2r</Name>
    <Title>MOC情報を設定</Title>
    <Format>
      ofs,x,y
      ofs : MOCのオフセット番号
      x   : 設定する値
      y   : 設定する値2
    </Format>
    <Setting>
      MOC情報に角度情報を設定します。
      ofsで指定したオフセット番号から２つのパラメータが対象になります。
      整数値(256で１回転)をラジアン単位に変換してパラメーターを書き込みます。
      角度を指定するパラメーター以外では正常な値にならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>dxfload</Name>
    <Title>DXF形式ファイルを読み込み</Title>
    <Format>
      "filename",p1
      "filename" : 読み込むモデルファイル(DXF形式)
      p1(0)      : 表面の色指定(オプション)
    </Format>
    <Setting>
      DXF形式のファイルをモデルデータとして読み込みます。
      システム変数statに読み込まれた先のモデルIDが返されます。
      p1で読み込まれたポリゴンの表面色を指定することができます。表面色は、RGBを24bit整数にパックした形式($rrggbb)で指定する必要があります。
      p1を省略または0に指定した場合は、白色(0xffffff)が選択されます。
      DXF形式は、CADやほとんどの3Dツールがサポートしている基本的な3D形状フォーマットです。テクスチャ情報など高度な情報は反映されませんが、形状をやり取りすることが可能です。
      dxfload命令では、DXF形式の3DFACEというタイプにのみ対応しています。
      一部のファイルとは互換がない可能性があります。
      この命令は、hgimg3.asモジュール内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>adddxf</Name>
    <Title>DXF形式データの登録</Title>
    <Format>
      var1,var2,color
      var1     : 作成されたモデルIDが代入される変数名
      var2     : DXF形式のデータが代入されているバッファ変数名
      color(0) : 表面の色指定(オプション)
    </Format>
    <Setting>
      DXF形式のモデルを登録します。モデルデータは、あらかじめvar2で指定された変数バッファに読み込まれている必要があります。
      正常にモデルが登録されると、varで指定した変数にモデルIDが代入されます。
      colorで読み込まれたポリゴンの表面色を指定することができます。表面色は、RGBを24bit整数にパックした形式($rrggbb)で指定する必要があります。
      colorを省略または0に指定した場合は、白色(0xffffff)が選択されます。
      この命令は、メモリ上に読み込まれたデータから登録を行なうためのものです。DXF形式のファイルが用意されている場合は、dxfload命令をお使いください。
    </Setting>
  </command>
  <command>
    <Name>modelscale</Name>
    <Title>モデルのサイズを変更する</Title>
    <Format>
      id,x,y,z
      id      : モデルID
      (x,y,z) : X,Y,Z倍率(実数値)
    </Format>
    <Setting>
      指定したモデル全体を指定したスケール値で拡大縮小します。
      これによりモデルそのもののサイズ自体を変えることが可能になります。
    </Setting>
  </command>
  <command>
    <Name>event_wait</Name>
    <Title>待ち時間イベントを追加</Title>
    <Format>
      id,p1
      id      : イベントID
      p1(0)   : 待ち時間(フレーム)
    </Format>
    <Setting>
      idで指定しているイベントIDに、待ち時間イベントを追加します。
      待ち時間イベントは、p1で指定されたフレーム数だけ次のイベントに進むことを保留します。
    </Setting>
  </command>
  <command>
    <Name>event_jump</Name>
    <Title>ジャンプイベントを追加</Title>
    <Format>
      id,p1,p2
      id      : イベントID
      p1(0)   : ジャンプ先のイベント番号
      p2(0)   : ジャンプ無視の確率(%)
    </Format>
    <Setting>
      idで指定しているイベントIDに、ジャンプイベントを追加します。
      ジャンプイベントは、指定されたイベント番号から実行を続けることを指示します。
      イベントリストの中でのgoto命令にあたります。
      p1で指定するイベント番号は、イベントに追加された順番に0,1,2…と数えたものになります。
      p2で、ジャンプ無視の確率(%)を設定することができます。
      0または省略された場合は、必ず(無条件)でジャンプを行ないます。
      それ以外の場合は、乱数をもとに1〜100%の確率でジャンプを行ない、
      ジャンプしなかった場合は次のイベントに進みます。
    </Setting>
  </command>
  <command>
    <Name>event_prmset</Name>
    <Title>パラメーター設定イベントを追加</Title>
    <Format>
      id,p1,p2
      id      : イベントID
      p1(0)   : パラメーターID(PRMSET_*)
      p2(0)   : 設定される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、パラメーター設定イベントを追加します。
      パラメーター設定イベントは、p1で指定されたパラメーターIDにp2の値を設定します。
      (それまでに設定されていた内容は消去されます)
      パラメーターIDには、以下の名前を使用することができます。

      パラメーターID   内容
      ---------------------------------------
      PRMSET_MODE      動作モード
      PRMSET_FLAG      存在フラグ
      PRMSET_SHADE     シェーディングモード
      PRMSET_TIMER     タイマー
      PRMSET_MYGROUP   コリジョングループ値
      PRMSET_COLGROUP  対象グループ値
    </Setting>
  </command>
  <command>
    <Name>event_prmon</Name>
    <Title>パラメータービット設定イベントを追加</Title>
    <Format>
      id,p1,p2
      id      : イベントID
      p1(0)   : パラメーターID(PRMSET_*)
      p2(0)   : 設定されるビット
    </Format>
    <Setting>
      idで指定しているイベントIDに、パラメータービット設定イベントを追加します。
      パラメータービット設定イベントは、p1で指定されたパラメーターIDにp2のビットを設定します。
      (それまでに設定されていた内容は保持されたまま、新しい値のビットだけが有効になります)
      パラメーターIDの詳細については、event_prmset命令を参照してください。
    </Setting>
  </command>
  <command>
    <Name>event_prmoff</Name>
    <Title>パラメータービット消去イベントを追加</Title>
    <Format>
      id,p1,p2
      id      : イベントID
      p1(0)   : パラメーターID(PRMSET_*)
      p2(0)   : 消去されるビット
    </Format>
    <Setting>
      idで指定しているイベントIDに、パラメータービット消去イベントを追加します。
      パラメータービット消去イベントは、p1で指定されたパラメーターIDから、
      p2のビットだけを消去します。
      パラメーターIDの詳細については、event_prmset命令を参照してください。
    </Setting>
  </command>
  <command>
    <Name>event_setpos</Name>
    <Title>posグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setang</Name>
    <Title>angグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setangr</Name>
    <Title>angグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setscale</Name>
    <Title>scaleグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setdir</Name>
    <Title>dirグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setefx</Name>
    <Title>efxグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_setwork</Name>
    <Title>workグループ設定イベントを追加</Title>
    <Format>
      id,x1,y1,z1,x2,y2,z2
      id         : イベントID
      (x1,y1,z1) : 設定される値(下限値)
      (x2,y2,z2) : 設定される値(上限値)
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ設定イベントを追加します。
      グループ設定イベントは、オブジェクトが持っているパラメーターを設定します。
      (x1,y1,z1)と(x2,y2,z2)を指定すると、それぞれの範囲内にある値を乱数で作成します。
      (x2,y2,z2)を省略して、(x1,y1,z1)だけを指定した場合はそのまま値が設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_pos</Name>
    <Title>posグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(1)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値スプラインが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_ang</Name>
    <Title>angグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_angr</Name>
    <Title>angグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
    </Setting>
  </command>
  <command>
    <Name>event_scale</Name>
    <Title>scaleグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_dir</Name>
    <Title>dirグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_efx</Name>
    <Title>efxグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_work</Name>
    <Title>workグループ変化イベントを追加</Title>
    <Format>
      id,frame,x1,y1,z1,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      (x1,y1,z1) : 設定される値
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時に(x1,y1,z1)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_addpos</Name>
    <Title>posグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_addang</Name>
    <Title>angグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_addangr</Name>
    <Title>angグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_addscale</Name>
    <Title>scaleグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_adddir</Name>
    <Title>dirグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_addefx</Name>
    <Title>efxグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>event_addwork</Name>
    <Title>workグループ加算イベントを追加</Title>
    <Format>
      id,x,y,z
      id      : イベントID
      (x,y,z) : 加算される値
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ加算イベントを追加します。
      グループ加算イベントは、オブジェクトが持っているパラメーターに(x,y,z)の値を加算します。
    </Setting>
  </command>
  <command>
    <Name>setevent</Name>
    <Title>オブジェクトにイベントを設定</Title>
    <Format>
      p1,p2,p3
      p1(0)  : オブジェクトID
      p2(0)  : イベントID
      p3(-1) : イベントスロットID
    </Format>
    <Setting>
      p1で指定したオブジェクトにp2のイベントを適用します。
      あらかじめ、決まった流れの処理(イベント)を登録したイベントリストを用意しておく必要があります。

      setevent命令によって設定されるイベントは、オブジェクト１つあたり４つまで同時に適用することが可能です。
      p3にイベントを設定するためのイベントスロットID(0から3まで)を指定することができます。
      p3を省略するか、-1を指定した場合には0から順番に空いているイベントスロットIDが使用されます。
      オブジェクトに設定されたイベントを削除する場合には、p3にイベントスロットIDを指定して、p2をマイナス値にしてください。

      イベントの設定に成功した場合には、システム変数statに設定されたイベントスロットIDが代入されます。
      イベントの設定に失敗すると、システム変数statに-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>delevent</Name>
    <Title>イベントリストを削除</Title>
    <Format>
      p1
      p1 : イベントID
    </Format>
    <Setting>p1で指定したイベントリストを削除します。</Setting>
  </command>
  <command>
    <Name>newevent</Name>
    <Title>イベントリストを作成</Title>
    <Format>
      p1
      p1 : イベントIDが代入される変数名
    </Format>
    <Setting>
      新しいイベントIDを取得し、p1で指定した変数に代入します。

      新しくイベントを作成する場合には、必ずnewevent命令でイベントIDを取得しておく必要があります。
      次に、「event_」で始まるイベントリスト追加命令によって多彩な動作を登録しておくことができます。
      一度取得されたイベントIDは、シーンのリセット(hgreset命令)が行なわれるか、
      またはdelevent命令によってイベントリストが削除されるまでは保持されます。

      こうしてできたイベントは、setevent命令によっていつでもオブジェクトに対して適用することができます。
    </Setting>
  </command>
  <command>
    <Name>cammode</Name>
    <Title>カメラモードの設定</Title>
    <Format>
      mode
      mode : モード値
    </Format>
    <Setting>
      カメラの向きについてのモードを設定します。
      指定できるモードは、
      CAM_MODE_NORMAL		(カメラの位置、角度に従う)
      と、
      CAM_MODE_LOOKAT		(カメラは注視点を常に向いている)
      です。
    </Setting>
  </command>
  <command>
    <Name>settoonedge</Name>
    <Title>トゥーンシェーディング時の設定</Title>
    <Format>
      p1,p2,p3,p4
      p1    : モデルID
      p2(0) : エッジの色(RGBコード)
      p3(0) : Zオフセット
      p4(0) : Xオフセット(0.0〜1.0)
    </Format>
    <Setting>
      p1で指定したモデルのトゥーンシェーディング時の設定を行ないます。
      p2で、エッジの色コード(RRGGBB)を指定します。
      p3,p4は実数値によりエッジのオフセットを指定することができます。
      Zオフセット(p3)を変更することにより、輪郭線の太さを調整することができます。
      Zオフセットのデフォルト値は、0.005が設定されています。
      Xオフセット(p4)は、トゥーンシェーディングで使用するテクスチャのX方向原点を指定します。
      Xオフセットのデフォルト値は、0.5が設定されており、この場合はX方向の半分にあたる位置を中心にして、テクスチャのU値が計算されることになります。
    </Setting>
  </command>
  <command>
    <Name>event_uv</Name>
    <Title>UV設定イベントを追加</Title>
    <Format>
      p1,p2,p3
      p1    : イベントID
      p2    : Xオフセット
      p3    : Yオフセット
    </Format>
    <Setting>
      idで指定しているイベントIDに、UV設定イベントを追加します。
      UV設定イベントは、2D及び3D(x形式モデルを除く)の単一ポリゴンが持つUVを動的に変更します。
      これは、テクスチャーアニメーションを実現させるためのもので、イベントが実行されると、テクスチャのUV座標が(p2,p3)で指定された値(ドット数)に再設定されます。
    </Setting>
  </command>
  <command>
    <Name>setobjmodel</Name>
    <Title>オブジェクトのモデル設定</Title>
    <Format>
      ObjID,modelID
      ObjID    : オブジェクトID
      modelID  : モデルID
    </Format>
    <Setting>指定されたオブジェクトが表示するモデルを変更します。</Setting>
  </command>
  <command>
    <Name>event_wpos</Name>
    <Title>posグループ変化イベントを追加</Title>
    <Format>
      id,frame,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      sw(1)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時にworkグループ(ワーク値)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値スプラインが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_wang</Name>
    <Title>angグループ変化イベントを追加</Title>
    <Format>
      id,frame,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時にworkグループ(ワーク値)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_wscale</Name>
    <Title>scaleグループ変化イベントを追加</Title>
    <Format>
      id,frame,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時にworkグループ(ワーク値)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_wdir</Name>
    <Title>dirグループ変化イベントを追加</Title>
    <Format>
      id,frame,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時にworkグループ(ワーク値)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_wefx</Name>
    <Title>efxグループ変化イベントを追加</Title>
    <Format>
      id,frame,sw
      id         : イベントID
      frame      : 変化までのフレーム数
      sw(0)      : 補間オプション
    </Format>
    <Setting>
      idで指定しているイベントIDに、グループ変化イベントを追加します。
      グループ変化イベントは、オブジェクトが持っているパラメーターの時間による変化を設定します。
      frameで指定したフレーム数が経過した時にworkグループ(ワーク値)の値になります。
      swの補間オプションは、以下の値を指定することができます。

      sw = 0 : リニア補間(絶対値)
      sw = 1 : スプライン補間(絶対値)
      sw = 2 : リニア補間(相対値)
      sw = 3 : スプライン補間(相対値)

      swを省略した場合には、絶対値リニアが設定されます。
    </Setting>
  </command>
  <command>
    <Name>event_delobj</Name>
    <Title>オブジェクト削除イベントを追加</Title>
    <Format>
      id
      id         : イベントID
    </Format>
    <Setting>
      idで指定しているイベントIDに、オブジェクト削除イベントを追加します。
      オブジェクト削除イベントは、現在イベントを実行しているオブジェクトそのものを削除する命令です。
    </Setting>
  </command>
  <command>
    <Name>event_regobj</Name>
    <Title>オブジェクト生成イベントを追加</Title>
    <Format>
      id,model,event
      id         : イベントID
      model      : モデルID
      event      : イベントID
    </Format>
    <Setting>
      idで指定しているイベントIDに、オブジェクト生成イベントを追加します。
      オブジェクト生成イベントは、regobj命令と同様にイベント実行時に新しいオブジェクトを生成します。
      パラメーターとして、modelにモデルIDを、eventにイベントIDを指定することができます。また、生成されるオブジェクトの座標は、イベントを実行しているオブジェクトの座標が継承されます。
    </Setting>
  </command>
  <command>
    <Name>event_eprim</Name>
    <Title>エフェクト設定イベントを追加</Title>
    <Format>
      id,model,param,val1,val2
      id     : イベントID
      model  : モデルID
      param  : パラメーターID
      val1   : 設定値1
      val2   : 設定値2
    </Format>
    <Setting>
      idで指定しているイベントIDに、エフェクト設定イベントを追加します。
      seteprim命令と同様の操作をイベント実行時に行なうことができます。
      modelに、addeprim命令によって作成されたモデルIDを指定します。
      モデルIDがマイナス値の場合は、イベントが設定されているオブジェクトに割り当てられているモデルが対象になります。
      paramにseteprim命令と同様のパラメーターIDを指定します。
      ただし、色指定(パラメーターID16以降)については、A→R→G→Bの順番で別なパラメーターIDが割り当てられています。
      (seteprim命令では、16にあたるIDが16(A),17(R),18(G),19(B)に分割されています。)
      val2を省略した場合には、val1の値が設定されます。
      val2が指定された場合は、実際に設定される値がval1〜val2になります。
      val1〜val2は、イベント実行時に乱数で生成されます。
    </Setting>
  </command>
  <command>
    <Name>selcam</Name>
    <Title>カメラをMOC情報に設定</Title>
    <Format>
      mocofs
      mocofs : MOCのグループ指定
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをカメラに設定します。
      通常は、selcpos,selcang,selcint命令をお使いください。
    </Setting>
  </command>
  <command>
    <Name>sellight</Name>
    <Title>光源をMOC情報に設定</Title>
    <Format>
      id,ofs
      id     : 光源のID(0〜3)
      mocofs : MOCのグループ指定
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをライト(光源)に設定します。
      通常は、sellpos,sellang,sellcolor命令をお使いください。
    </Setting>
  </command>
  <command>
    <Name>selcpos</Name>
    <Title>カメラ座標をMOC情報に設定</Title>
    <Format></Format>
    <Setting>MOC設定命令の対象となるMOCグループをカメラのA(移動座標)に設定します</Setting>
  </command>
  <command>
    <Name>selcang</Name>
    <Title>カメラ角度をMOC情報に設定</Title>
    <Format></Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをカメラのB(回転角度)に設定します
      cammodeの設定が注視点を見るモードになっている場合は、カメラ回転角は自動的に設定されます。
    </Setting>
  </command>
  <command>
    <Name>selcint</Name>
    <Title>カメラ注視点をMOC情報に設定</Title>
    <Format></Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをC(注視点座標)に設定します
      注視点は、cammodeの設定によって有効になります。
    </Setting>
  </command>
  <command>
    <Name>sellpos</Name>
    <Title>光源座標をMOC情報に設定</Title>
    <Format>
      id
      id     : 光源のID(0〜3)
    </Format>
    <Setting>MOC設定命令の対象となるMOCグループをライト(光源)の座標に設定します。</Setting>
  </command>
  <command>
    <Name>sellang</Name>
    <Title>光源角度をMOC情報に設定</Title>
    <Format>
      id
      id     : 光源のID(0〜3)
    </Format>
    <Setting>MOC設定命令の対象となるMOCグループをライト(光源)の角度に設定します。</Setting>
  </command>
  <command>
    <Name>sellcolor</Name>
    <Title>光源色をMOC情報に設定</Title>
    <Format>
      id
      id     : 光源のID(0〜3)
    </Format>
    <Setting>MOC設定命令の対象となるMOCグループをライト(光源)の色(R,G,B,Ambient)に設定します。</Setting>
  </command>
  <command>
    <Name>sellambient</Name>
    <Title>環境光色をMOC情報に設定</Title>
    <Format>
      id
      id     : 光源のID(0〜3)
    </Format>
    <Setting>MOC設定命令の対象となるMOCグループをアンビエント(環境光)の色(R,G,B)に設定します。</Setting>
  </command>
  <command>
    <Name>objgetv</Name>
    <Title>MOC情報を整数値で取得</Title>
    <Format>
      v
      v    : 値が代入される変数名
    </Format>
    <Setting>
      MOCに設定されている値を変数vに整数で代入します。
      v.0〜v.3にそれぞれのオフセット番号が持つ値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>objsetv</Name>
    <Title>MOC情報を整数値で設定</Title>
    <Format>
      v
      v    : 値が代入されている変数名
    </Format>
    <Setting>
      変数vに整数で代入されている値をMOCに設定します。
      v.0〜v.3がそれぞれのオフセット番号に設定されます。
    </Setting>
  </command>
  <command>
    <Name>objgetstr</Name>
    <Title>MOC情報を文字列で取得</Title>
    <Format>
      sval
      sval : 結果が代入される文字列型変数名
    </Format>
    <Setting>MOCに設定されている値を変数svalに文字列で書き出します。</Setting>
  </command>
  <command>
    <Name>objact</Name>
    <Title>指定アニメーションを開始</Title>
    <Format>
      ObjID,Anim,mode
      ObjID   : オブジェクトID
      Anim    : アニメーションインデックス値
      mode(0) : 設定モード(0=即時/1=終了時)
    </Format>
    <Setting>
      指定されたオブジェクトのアニメーションを開始します。
      Animで複数あるアニメーションを示すインデックス値を指定します。
      インデックス値は、複数アニメーション読み込みを行なった順番に、0,1,2,3…という数字で表わされます。
      Animにマイナスの値(-1)を指定することで、アニメーションを解除(停止)させることができます。
      また、modeの値により設定のモードを指定することができます。
      設定モードを0または省略した場合は、即時にアニメーションを切り替えます。
      設定モードを1に指定した場合は、現在再生されているアニメーションが終わるのを待ってから、切り替えを行ないます。
      設定モード1で、Animにマイナス値を指定した場合は、現在のアニメーション再生終了後にアニメーションを停止します。
      設定モード0でアニメーションを再生した場合は、再生スピードはデフォルト値に戻され、リピート再生が行なわれる設定になります。
      アニメーションの開始時は、モデルが持つ標準的なアニメーション速度(modelspeed命令にて変更可能)が設定されます。
      アニメーションの再生中は、objspeed命令により速度を変更することが可能です。
    </Setting>
  </command>
  <command>
    <Name>getanim</Name>
    <Title>アニメーション情報を取得</Title>
    <Format>
      p1,p2,p3
      p1    : 情報が代入される変数
      p2(0) : オブジェクトID
      p3(0) : 情報ID
    </Format>
    <Setting>
      p2で指定されたオブジェクトのアニメーションに関する情報を取得して、p1で指定された変数に代入します。
      取得される情報の種類は、p3の情報IDで指定することができます。
      情報IDは、以下の値が用意されています。

      情報ID   内容
      -----------------------------------------------
      0      アニメーション開始からの時間(ms)
      1      アニメーションループフラグ

      結果が代入される変数は、自動的に整数型に設定されます。
      アニメーションループフラグは、アニメーション開始時は0ですが、最後まで再生された場合には1が返されます。
    </Setting>
  </command>
  <command>
    <Name>addxfile</Name>
    <Title>Xファイルモデルを作成</Title>
    <Format>
      var,"filename"
      var        : 作成されたモデルIDが代入される変数名
      "filename" : 読み込みを行なうファイル名
    </Format>
    <Setting>
      x形式のモデルファイルを読み込みます。
      正常にモデルが読みこまれると、varで指定した変数にモデルIDが代入されます。
      読み込みに失敗した場合には、varで指定した変数に-1が代入されます。

      HGIMG3が読み込むx形式は、DirectX8以降のスキンメッシュに対応しています。
      ワンスキンモデル及びアニメーションを出力可能な各種ツールで、x形式の出力に対応したものを別途ご用意下さい。

      setreq命令によって法線再計算スイッチ(SYSREQ_CALCNORMAL)が0以外に設定
      されている場合には、モデル法線の再計算を行ないます。
      通常は、x形式ファイルに記録された法線をそのまま使用します。
    </Setting>
  </command>
  <command>
    <Name>addxanim</Name>
    <Title>Xファイルアニメーションの追加</Title>
    <Format>
      ModelID,"filename"
      ModelID    : モデルID
      "filename" : 読み込みを行なうファイル名
    </Format>
    <Setting>
      Xファイルモデルに、アニメーションデータを追加します。
      ModelIDでは、すでにaddxfile命令によって読み込まれているモデルIDを指定する必要があります。
      アニメーションの追加に成功すると、システム変数statにモデルIDが代入されます。
      アニメーションの追加に失敗した場合は、システム変数statに-1が代入されます。

      addxanim命令は、１つのモデルで複数のアニメーションを切り替えて使用する場合に利用します。
      最初にモデル全体と最初のアニメーションを含んだデータをaddxfile命令により読み込み、さらに追加でアニメーションだけを登録する場合にaddxanim命令を使用します。
      必ず、モデルやボーンの構成は同一のものから出力されている必要があります。

      複数のアニメーションは、objact命令によって切り替えることが可能です。
      切り替えるためのアニメーションインデックス値は、最初にaddxfile命令で読み込まれたアニメーションを0として、以降addxanim命令で追加するたびに1,2,3…と増加していきます。

      追加できるアニメーションの最大数は、標準で16(もとのxファイル含む)です。
      最大数を拡張する場合は、setreq命令によってアニメーション最大数(SYSREQ_MDLANIM)を適切に設定してください。

      複数のアニメーション情報を持つXファイルからは、最初の１つしか読み込むことができません。複数読み込む際には、複数のXファイルを用意する必要があります。
    </Setting>
  </command>
  <command>
    <Name>objspeed</Name>
    <Title>アニメーション再生速度の設定</Title>
    <Format>
      p1,p2
      p1(0) : オブジェクトID
      p2(0) : １フレームあたりの再生速度(実数値)
    </Format>
    <Setting>
      p1で指定されたオブジェクトIDのアニメーション再生速度を設定します。
      p2で１フレームあたりの再生速度(ms)を実数値で指定することができます。
      この命令は、objact命令により再生されているアニメーションの再生速度を変更するためのものです。
      objact命令を実行した場合は、modelspeed命令によって設定されている標準のアニメーション再生速度が適用されます。
      アニメーションの再生前に速度を設定する場合は、modelspeed命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>modelspeed</Name>
    <Title>アニメーション再生速度の設定(2)</Title>
    <Format>
      p1,p2
      p1(0) : モデルID
      p2(0) : １フレームあたりの再生速度(実数値)
    </Format>
    <Setting>
      p1で指定されたモデルIDが持つ標準のアニメーション再生速度を設定します。
      p2で１フレームあたりの再生速度(ms)を実数値で指定することができます。
      以降は、指定されたモデルを使用するオブジェクトが、アニメーションを再生する場合の標準速度として設定されます。
      modelspeed命令によって標準のアニメーション再生速度が設定されなかった場合は、15(ms)がオブジェクト初期化時に設定されます。
      objact命令により、すでに再生されているアニメーションの再生速度は、objspeed命令によって変更してください。
    </Setting>
  </command>
  <command>
    <Name>hgcapture</Name>
    <Title>DirectX画面データの取得</Title>
    <Format></Format>
    <Setting>
      HGIMGが描画しているフレームバッファの情報をHSPの画面にコピーします。
      gsel命令などで現在アクティブな画面がコピー先になります。
      必ず、HGIMGを初期化したサイズと同じ大きさのバッファをコピー先にしてください。
      hgcapture命令は、HSPの仮想画面バッファにコピーを行ないますが、画面の更新は行なわれません。
      取得された画面をウィンドウ上で反映させるためには、redraw命令により再描画を行なう必要があります。
      HGIMGを初期化したウィンドウIDと同じバッファをコピー先にした場合は、HGIMGの画面がオーバーレイされているため、内容が表示されないので注意してください。
      また、hgcapture命令は、ビデオカードのフレームバッファから大量のデータをメインメモリにコピーするため、ビデオカードやCPU負荷が発生します。
    </Setting>
  </command>
  <command>
    <Name>objlight</Name>
    <Title>参照されるライトの設定</Title>
    <Format>
      p1,p2,p3
      p1(0)  : ライトが設定されるオブジェクトID
      p2(0)  : ライトとして参照されるオブジェクトID
      p3(-1) : 設定モード
    </Format>
    <Setting>
      p1で指定されたオブジェクトIDが影響を受けるライトを設定します。
      p2で参照されるオブジェクトIDを指定します。
      通常、すべてのオブジェクトは基本ライト(HGOBJ_LIGHT)の影響を受けます。
      objlight命令により、基本ライト以外のオブジェクトから影響を受ける状態に変更します。
      参照される追加のライトオブジェクトは、reglight命令で作成することができます。

      p3でモードを指定することができます。p3の値は、以下の意味を持ちます。

      モード   内容
      ---------------------------------------
      1     ライトの方向
      2     ライトの色
      4     ライトのアンビエント色

      複数の項目を設定する場合は、それぞれのモード値を加算してください。
      p3を省略すると、方向・色・アンビエント色のすべてが設定されます。
    </Setting>
  </command>
  <command>
    <Name>reglight</Name>
    <Title>ライトオブジェクトの登録</Title>
    <Format>
      p1
      p1 : 作成されたオブジェクトIDが代入される変数名
    </Format>
    <Setting>
      追加のライトオブジェクトを登録して、p1に指定された変数にIDを代入します。
      ライトオブジェクトは、objlight命令によって新しく参照されるためのライトとして扱うことができます。
      取得されたオブジェクトIDは、他のオブジェクトと同じ方法でパラメーターを設定、取得することが可能です。
      設定できるパラメーターは、基本ライト(HGOBJ_LIGHT)と同様のものになります。
    </Setting>
  </command>
  <command>
    <Name>getxinfo</Name>
    <Title>Xモデル表示情報の取得</Title>
    <Format>
      p1,p2,p3
      p1 : 作成されたモデル情報文字列が代入される変数名
      p2 : オブジェクトID
      p3 : ノードID
      p4 : 設定モード
    </Format>
    <Setting>
      p2で指定されたオブジェクトIDが示すモデルの情報を文字列として
      p1で指定した変数に代入します。
      必ずX形式のモデル持つオブジェクトIDを指定する必要があります。
      p1の変数には、文字列の形で情報が代入されます。
      p2でノードIDを指定することができます。
      ノードIDは0から始まる数値で、ボーンやメッシュごとに複数のIDが割り振られています。
      ノードIDに-1などマイナス値を指定した場合は、改行コードで区切られた1行1要素の形ですべてのノード情報が返されます。
      これによりノードIDの最大数を調べることができます。
      (ノードIDの最大数は、同じモデルであればモードが違っていても共通です。)
      p4で取得する情報の種類を指定することができます。
      p4で指定できる値は、以下の通りです。

      モード        内容
      ---------------------------------------------
      0            ノード名
      1            ノードのワールド座標
      2            ノードのX,Y,Z回転角度
      16           ノードが持つマテリアル数
      $1000+MatID  マテリアルの色( Diffuse Color )
      $2000+MatID  テクスチャのCOMポインタ(テクスチャ未使用時は0)
      $10000+Index  頂点座標
      $20000+Index  UV座標

      $1000と$2000は、マテリアルIDと組み合わせて使用します。
      マテリアルIDは、ノードごとに割り振られた0から始まる値で、有効なマテリアルIDの数は、モード16で調べることができます。

      $10000と$20000は、内部バッファのIndexと組み合わせて使用します。
      指定したインデックスが持つ頂点座標またはUV座標の値を取得することができます。

      getxinfo命令は、ボーンを含むモデルが持つ個別の位置情報などを得るために使用することができます。
      多数のノードを持つモデルを処理する場合には、処理がかかることもあるのでリアルタイムな動作を行なうアプリケーションでは注意して下さい。
      現在は、モード1及び2の値は最後に描画されたモデルに関する情報を取得します。
      複数のオブジェクトでモデルを共有している場合は、正しく取得されませんのでご注意ください。
    </Setting>
  </command>
  <command>
    <Name>setxinfo</Name>
    <Title>Xモデル情報の詳細設定</Title>
    <Format>
      p1,p2,p3,x,y,z
      p1 : オブジェクトID
      p2 : ノードID
      p3 : 設定モード
      (x,y,z) : 設定されるベクトル情報(実数値)
    </Format>
    <Setting>
      p1で指定されたオブジェクトIDが示すモデルの詳細情報を設定します。
      必ずX形式のモデル持つオブジェクトIDを指定する必要があります。
      モデルが複数のノード(ボーンやメッシュなど)を持っている場合には、p2でノードIDを指定することができます。
      ノードIDは0から始まる数値で、ボーンやメッシュごとに複数のIDが割り振られています。
      (指定可能なノードIDの範囲は、getxinfo命令によってノード一覧を取得して調べることができます。)
      p3で取得する情報の種類を指定することができます。
      p3で指定できる値は、以下の通りです。

      モード        内容
      ---------------------------------------------
      1            ノードのローカル座標(x,y,z)
      2            ノードの回転角度(x,y,z)
      $1000+MatID  マテリアルの色( xyz=RGB )
      $2000+MatID  参照されるテクスチャ( x=テクスチャID )
      $10000+Index  頂点座標( x,y,z )
      $20000+Index  UV座標( x,y )

      $1000と$2000は、マテリアルIDと組み合わせて使用します。
      マテリアルIDは、ノードごとに割り振られた0から始まる値で、有効なマテリアルIDの数は、getxinfo命令のモード16で調べることができます。

      $10000と$20000は、内部バッファのIndexと組み合わせて使用します。
      指定したインデックスが持つ頂点座標またはUV座標を直接編集することができます。

      setxinfo命令は、ボーンを含むモデルが持つ個別の状態を変更するために使用することができます。
      アニメーションが設定されているノードは設定することができません。
      また、正しいノードIDを指定しないと表示が崩れることもあるので、十分に注意して使用してください。
    </Setting>
  </command>
  <command>
    <Name>getobjmodel</Name>
    <Title>オブジェクトのモデルID取得</Title>
    <Format>
      var,id
      var      : 結果が代入される変数名
      id       : オブジェクトID
    </Format>
    <Setting>指定したオブジェクトに割り当てられているモデルIDを取得し、varで指定された変数に代入します。</Setting>
  </command>
  <command>
    <Name>modelcols</Name>
    <Title>コリジョンパラメーターの設定(2)</Title>
    <Format>
      p1,p2
      p1(0) : モデルID
      p2(1.0) : コリジョンパラメーターX(実数値)
      p3(1.0) : コリジョンパラメーターY(実数値)
      p4(1.0) : コリジョンパラメーターZ(実数値)
      p5(0) : 設定タイプ
    </Format>
    <Setting>
      p1で指定されたモデルIDが持つ標準のコリジョンパラメーターを設定します。
      以降は、指定されたモデルを使用するオブジェクト初期化時のコリジョンパラメーターとして設定されます。
      p5の設定タイプが0の場合は、getcoli命令のコリジョン判定時に、
      指定された値に対するスケール(倍率)を実数でX,Y,Z軸ごとに指定することができます。
      (標準のコリジョンスケールが設定されなかった場合は、1.0(等倍)が設定されます。)
      p5の設定タイプが1の場合は、拡張コリジョンパラメーターの設定となります。
      p2をオブジェクトの重さ(反発力)、p3を高さ、p4を半径とした円柱をコリジョン判定用に設定します。
      (これは、objwalk命令による地形判定用で使用するための設定です)

      オブジェクトごとのコリジョンパラメーターは、setcolscale命令によって設定することも可能です。
    </Setting>
  </command>
  <command>
    <Name>setcolscale</Name>
    <Title>コリジョンパラメーターの設定</Title>
    <Format>
      p1,p2
      p1(0) : オブジェクトID
      p2(1.0) : コリジョンパラメーターX(実数値)
      p3(1.0) : コリジョンパラメーターY(実数値)
      p4(1.0) : コリジョンパラメーターZ(実数値)
      p5(0) : 設定タイプ
    </Format>
    <Setting>
      p1で指定されたオブジェクトIDが持つコリジョンパラメーターを設定します。
      p5の設定タイプが0の場合は、getcoli命令のコリジョン判定時に、指定された値に対するスケール(倍率)を実数でX,Y,Z軸ごとに指定することができます。
      (標準のコリジョンスケールが設定されなかった場合は、1.0(等倍)が設定されます。)
      p5の設定タイプが1の場合は、拡張コリジョンパラメーターの設定となります。
      p2をオブジェクトの重さ(反発力)、p3を高さ、p4を半径とした円柱をコリジョン判定用に設定します。
      (これは、objwalk命令による地形判定用で使用するための設定です)

      setcolscale命令によってコリジョンパラメーターが設定されなかった場合は、モデルごとの標準コリジョンパラメーターが使用されます。
    </Setting>
  </command>
  <command>
    <Name>modelshade</Name>
    <Title>シェーディングモードの設定</Title>
    <Format>
      p1,p2
      p1(0) : モデルID
      p2(0) : シェーディングモード
    </Format>
    <Setting>
      p1で指定されたモデルIDが持つシェーディングモードを設定します。
      シェーディングモードは、モデルを表示した時に行なう光源計算の方法を示します。
      モード値は、以下のいずれかになります。

      モード値      内容
      -----------------------------------------------------
      0          コンスタント(光源計算なし)
      1          グーロー(DirectX標準の光源計算)
      2          半球ライティング

      モード値が0の場合は、光源計算を行なわず常にマテリアル色をそのまま反映します。(コンスタントシェーディング)
      モード値が0の場合は、ライト色、アンビエント色を考慮した光源計算を行ないます。この場合の表示色は、

      輝度 = 光の強さ * ライト色 * マテリアル色 + アンビエント色

      という式が使用されます。(輝度が255を越えた場合は、255になります。)
      モード値が2の場合は、ライト色を天球色、アンビエント色を地上色として半球ライティングの計算が行なわれます。
      半球ライティングは、DirectX標準の光源計算と比べてやわらかできめの細かい陰影を表現することができます。
      現在のバージョンでは、シェーディングモードの設定は、x形式のモデルにのみ適用することができます。
      また、シェーディングモード１ではライトのscale(カラー)パラメータは現在反映されない仕様となっていますのでご了承ください。
    </Setting>
  </command>
  <command>
    <Name>modelorder</Name>
    <Title>回転順序モードの設定</Title>
    <Format>
      p1,p2
      p1(0) : モデルID
      p2(0) : 回転順序モード
    </Format>
    <Setting>
      p1で指定されたモデルIDが持つ回転順序のモードを設定します。
      回転順序モードにより、3Dオブジェクト表示時の回転順序を設定することができます。
      モードの値は、以下のいずれかになります。

      モード値  マクロ                 回転順序
      ------------------------------------------------------
      0     HGMODEL_ROTORDER_ZYX   Z→Y→X
      1     HGMODEL_ROTORDER_XYZ   X→Y→Z
      2     HGMODEL_ROTORDER_YXZ   Y→X→Z

      デフォルトのモデルでは、モード値0が設定されています。
      (ただし、x形式のモデルのみモード値1がデフォルトとなります。)

      modelorder命令は、どうしても解決できないオブジェクトの向きを設定する場合や、既存のデータとの互換を取るために用意されています。
      通常、使用する範囲で必須となる命令ではありません。
    </Setting>
  </command>
  <command>
    <Name>objchild</Name>
    <Title>オブジェクトの親子関係設定</Title>
    <Format>
      ObjID,ChildObjID
      ObjID      : オブジェクトID
      ChildObjID : 子供のオブジェクトID
    </Format>
    <Setting>
      指定されたオブジェクトの子供となるオブジェクトを設定します。
      ChildObjIDで指定されたオブジェクトは、ObjIDで指定されたオブジェクトと親子関係を持つことになります。
      以降は親となる、ObjIDで指定されたオブジェクトの座標、回転角度、スケールを継承した形で表示が行なわれます。
      また、親のオブジェクトが削除された場合には、その子供すべても同時に削除されます。
      子供を持っている親オブジェクトを、ChildObjIDに指定することで多階層の構造を設定することが可能です。
      すでに何らかの親を持っているオブジェクトを子供に指定することはできません。
      ChildObjIDにマイナス値を指定すると、ObjIDで指定したオブジェクトが持つ親子設定をすべて破棄します。

      現在のバージョンでは、x形式のモデルを持つオブジェクトでの親子関係設定は反映されません。x形式以外の3D,2Dモデルでのみご使用ください。
    </Setting>
  </command>
  <command>
    <Name>objproj</Name>
    <Title>オブジェクトのプロジェクション変更</Title>
    <Format>
      ObjID,Mode
      ObjID      : オブジェクトID
      Mode       : プロジェクションモード
    </Format>
    <Setting>
      ObjIDで指定されたオブジェクトのプロジェクションモードを変更します。
      プロジェクションモードが0の場合は、通常のオブジェクトとしてカメラのNearZ値、FarZ値に従ってZ方向のクリッピングが行なわれます。
      プロジェクションモードが1の場合は、特殊なオブジェクトとしてカメラのFarZ値は無視されます。
      背景など、一部のオブジェクトだけを遠くに描画するような場合に、プロジェクションモードを変更することができます。
    </Setting>
  </command>
  <command>
    <Name>dmmini</Name>
    <Title>サウンド機能初期化</Title>
    <Format></Format>
    <Setting>
      サウンド機能の初期化を行ないます。
      プログラム実行時の最初に１回だけ初期化を行なう必要があります。
      これ以降は、dmm〜で始まる命令を使用して、DirectSoundによるサウンド再生機能を使用することが可能になります。
      dmmini命令により、初期化が行なわれた時にのみサウンド機能が使用されます。
      HGIMG3使用時でも、サウンド関連機能の初期化が行なわれない場合は、DirectSoundなどサウンドに関するAPIが使用されることはありません。
      HGIMG3と他のサウンド関連プラグインを使用する場合は、通常通りお使い頂けます。
    </Setting>
  </command>
  <command>
    <Name>dmmreset</Name>
    <Title>サウンド機能の設定をリセット</Title>
    <Format></Format>
    <Setting>
      サウンド機能の設定をリセットします。
      読み込まれていた、すべてのサウンドデータは破棄されます。
    </Setting>
  </command>
  <command>
    <Name>dmmbye</Name>
    <Title>サウンド機能終了処理</Title>
    <Format></Format>
    <Setting>
      サウンド機能の終了処理を行ないます。
      通常は、終了処理が自動的に行なわれるので、この命令を入れる必要はありません。
    </Setting>
  </command>
  <command>
    <Name>dmmdel</Name>
    <Title>サウンドデータを削除</Title>
    <Format>
      p1
      p1(0) : サウンドID
    </Format>
    <Setting>p1で指定したサウンドIDの情報を破棄します。</Setting>
  </command>
  <command>
    <Name>dmmvol</Name>
    <Title>サウンドデータの音量設定</Title>
    <Format>
      p1,p2
      p1(0) : サウンドID
      p2(0) : 音量(-10000〜0)
    </Format>
    <Setting>
      p1で指定したサウンドIDの音量(ボリューム)を設定します。
      p2で設定する音量を指定します。0が最大の音量(0db)となり、-10000が最小の音量(無音)になります。
      設定値の単位は、db(デシベル)になっているため、人間が感じる音量と異なっています。人が聞いた際に自然な音量を設定するサンプルとして、volsamp.hspが用意されていますので参考にしてみてください。
      ※mmvol命令とは値の分解能、指定される値の意味が異なるので注意してください
    </Setting>
  </command>
  <command>
    <Name>dmmpan</Name>
    <Title>サウンドデータのパン設定</Title>
    <Format>
      p1,p2
      p1(0) : サウンドID
      p2(0) : パンニング値(-10000〜10000)
    </Format>
    <Setting>
      p1で指定したサウンドIDのパン(ステレオバランス)を設定します。
      p2で設定するパンニング値を指定します。
      -10000で左側100%となり、10000で右側100%になります。
      ※mmpan命令とは値の分解能が異なるので注意してください
    </Setting>
  </command>
  <command>
    <Name>dmmloop</Name>
    <Title>サウンドデータのループ設定</Title>
    <Format>
      p1,p2
      p1(0) : サウンドID
      p2(0) : ループポイント(-1=ループなし)
    </Format>
    <Setting>
      p1で指定したサウンドIDのループ情報を設定します。
      p2に0以上の値を指定した場合には、再生が繰り返されます。
      p2がマイナス値の場合は、ループを行ないません。
      ストリーミング再生時は、p2でループポイントの指定を行なうことが可能です。ループポイントは、サンプル単位(44.1kHzの場合は、44100分の1秒)で数値を指定します。
    </Setting>
  </command>
  <command>
    <Name>dmmload</Name>
    <Title>サウンドデータの読み込み</Title>
    <Format>
      "ファイル名",p1,p2
      "ファイル名" : 読み込みを行なうファイル名
      p1(-1) : 登録するサウンドID (-1=自動割り当て)
      p2(0)  : 再生モード(0=通常、1=リピート)
    </Format>
    <Setting>
      "ファイル名"で指定されたファイルをサウンドデータとして登録します。
      サウンドデータは、wave形式(拡張子.wav)または、ogg vorbis形式(拡張子.ogg)のファイルを指定します。
      ファイルは、memfile命令で指定したメモリ内のイメージを含め、dpmファイルなどHSPで使用可能なファイルをすべて利用することができます。

      p1に登録するサウンドID番号(0から始まる任意の数値)を指定することで、これ以降はサウンドID番号をもとに各種機能を使用することができるようになります。
      p1の指定を省略、またはマイナス値にした場合は、登録されていないサウンドID番号を自動的に割り当てます。
      割り当てられたサウンドID番号は、dmmload命令実行後にシステム変数statに代入されます。
      p2でwave形式の再生モードを指定することができます。
      再生モードが、0の場合は１回のみの再生。1の場合は、繰り返し(リピート)再生になります。
      ogg vorbis形式の繰り返し再生については、dmmloop命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>dmmplay</Name>
    <Title>サウンドデータの再生</Title>
    <Format>
      p1,p2
      p1(0) : サウンドID
      p2(0) : 開始ポイント
    </Format>
    <Setting>
      p1で指定したサウンドIDを再生します。
      すでに指定されたサウンドIDが再生中の場合は、最初から再生されます。
      p2で開始ポイントを指定することができます。
      p2が省略されるか0の場合は、サウンドデータの最初から再生され、それ以外の場合は最初からのオフセット位置として途中から再生されます。
      p2で指定する単位は、サウンドデータがwav形式の場合は、バイト数(byte)。
      ストリームデータ(ogg vorbis形式)の場合は、サンプル数(samples)になります。
      尚、ストリームデータの同時再生には対応していません。
    </Setting>
  </command>
  <command>
    <Name>dmmstop</Name>
    <Title>サウンドデータの再生停止</Title>
    <Format>
      p1
      p1(-1) : サウンドID (-1=すべてのサウンド)
    </Format>
    <Setting>
      p1で指定したサウンドIDの再生を停止します。
      p1を省略するかマイナス値を指定した場合には、再生中のすべてのサウンドを停止します。
    </Setting>
  </command>
  <command>
    <Name>dmmstat</Name>
    <Title>サウンドデータの状態取得</Title>
    <Format>
      p1,p2,p3
      p1 : 状態が取得される変数
      p2(0) : サウンドID
      p3(0) : 取得モード
    </Format>
    <Setting>
      p2で指定したサウンドIDの状態を取得して、p1の変数に代入します。
      p3で取得するモードを指定することができます。
      取得モードの値は、以下の通りです。

      モード値  内容
      ------------------------------------------------------
      0     設定フラグ値
      1     ボリューム値
      2     パンニング値
      3     再生レート(0=オリジナル)
      4,5   ループポイント(下位、上位16bit)
      16    再生中フラグ(0=停止中/1=再生中)
      $100   oggサウンドの再生位置(実数値)
      $101   oggサウンドの全体サイズ(実数値)
    </Setting>
  </command>
  <command>
    <Name>hgprm</Name>
    <Title>動作パラメーターの設定</Title>
    <Format>
      p1,p2,p3…
      p1(0)   : パラメーターID
      p2(0.0) : 設定する値
    </Format>
    <Setting>
      HGIMG3の動作を細かく設定します。
      p1で指定したパラメーターIDにp2の値を設定します。
      パラメーターIDは、以下の値を指定することができます。

      パラメーターID  内容
      ------------------------------------------------------
      0           地面の基点となるY座標(初期値=0.0)
      (OBJ_LANDのオブジェクトモードで参照されます)
      1           時間更新フラグ(初期値=1)
      (0を指定することでアニメーションや動作の補間を停止します)
      2           移動可能な地面の最高となるY座標(初期値=-15.0)
      (オブジェクト自動移動の際に、指定されたY座標より上には
      移動することができなくなります)
      3           ターゲットオブジェクトIDを指定
      (この項目は現在未使用です。将来の拡張用に用意されています)
      4           バウンド係数(初期値=1.0)
      (OBJ_BOUNDのオブジェクトモードで参照されます)
      5           摩擦抵抗(空中、地上)(初期値=0.95,0.95)
      (オブジェクト自動移動の際に、加えられる抵抗を設定します
      このパラメーターIDは、2つの値を設定する必要があります)
    </Setting>
  </command>
  <command>
    <Name>objaim</Name>
    <Title>オブジェクトを目標に向けて操作する</Title>
    <Format>
      ObjID,Target,Mode,x,y,z
      ObjID(0)   : オブジェクトID
      Target(0)  : ターゲットモード(0=座標、1=角度)
      Mode(0)    : モード
      x(1.0)     : オプションパラメーターX
      y(1.0)     : オプションパラメーターY
      z(1.0)     : オプションパラメーターZ
    </Format>
    <Setting>
      ObjIDで指定されたオブジェクトを、目標となる値に向けて座標や角度を操作します。
      Targetで、操作を行なう対象(ターゲットモード)を設定します。
      0または、省略した場合には、座標を移動させることになります。
      Modeで、操作の内容を選択することができます。

      Mode 0 : 目標値に向けて移動(または回転)

      オブジェクトのworkグループ情報に設定された座標に向けて移動(または回転)します。
      (ターゲットモードが0の場合は移動、1の場合は回転角度の変更になります。)
      あらかじめ、setwork命令により目標の座標を設定しておく必要があります。
      オプションパラメーターX,Y,Zにより、１フレームあたりの最大移動量を設定することができます。
      たとえば、(1,1,1)が指定されている場合は、X,Y,Zそれぞれ１フレームあたり最大1づつしか移動を行ないません。

      Mode 1 : 目標値に向けて移動量を設定

      Mode0と同様に、オブジェクトのworkグループ情報に設定された座標に向けて移動します。
      ただし、実際に移動を行なうのではなく、dirグループ情報に移動量を設定します。
      これは、オブジェクトのモードでOBJ_MOVEを指定している場合に、指定された座標に向けて移動させる場合などに使用するためのものです。
      このモードは、常にターゲットモード0(座標)を指定するようにしてください。

      Mode 4 : 目標値に向けて角度を設定

      オブジェクトのworkグループ情報に設定された座標に向けて角度を設定します。
      あらかじめ、setwork命令により目標の座標を設定しておく必要があります。
      オプションパラメーターX,Y,Zにより、もともとのモデルが向いているベクトルを指定する必要があります。
      このモードは、常にターゲットモード0(座標)を指定するようにしてください。

      objaim命令は、非常に多様なオブジェクト操作が可能な反面、設定が複雑になっています。
      必要な機能だけを実践しながら覚えていくといいでしょう。
      命令実行後に、システム変数refdvalに対象となる座標からの距離が代入されます。
    </Setting>
  </command>
  <command>
    <Name>event_aim</Name>
    <Title>オブジェクト操作イベントを追加</Title>
    <Format>
      id,Mode,x,y,z
      id(0)      : イベントID
      Mode(0)    : モード
      x(1.0)     : オプションパラメーターX
      y(1.0)     : オプションパラメーターY
      z(1.0)     : オプションパラメーターZ
    </Format>
    <Setting>
      idで指定しているイベントIDに、オブジェクト操作イベントを追加します。
      objaim命令と同様の操作をイベント実行時に行なうことができます。
      モード及び、オプションパラメーターX,Y,Zの値は、objaim命令と同様の内容を使用できます。
      (ターゲットモードは常に0が使用されます。)
    </Setting>
  </command>
  <command>
    <Name>event_objact</Name>
    <Title>アニメーション設定イベントを追加</Title>
    <Format>
      id,Anim,mode,speed
      id(0)      : イベントID
      Anim       : アニメーションインデックス値
      mode(0)    : 設定モード(0=即時/1=終了時)
      speed(0.0) : アニメーション再生スピード
    </Format>
    <Setting>
      idで指定しているイベントIDに、アニメーション設定イベントを追加します。
      Anim及び、modeの設定は、objact命令と同様の値を指定することができます。
      speedにより再生時の速度(objspeed命令と同様)を設定することができます。
      speedの値を0.0かまたは省略にした場合は、再生速度の設定は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>hgview</Name>
    <Title>描画エリアの設定</Title>
    <Format>
      x,y,sx,sy
      x(0) : 描画エリアの左上座標(X)
      y(0) : 描画エリアの左上座標(Y)
      sx(640) : 描画エリアの横サイズ
      sy(480) : 描画エリアの縦サイズ
    </Format>
    <Setting>
      画面内で描画を行なうエリアを設定します。
      hgviewで描画エリアを設定すると、それ以降の指定された範囲内にのみ描画されるようになります。
      １つの画面内をいくつかの領域に分割して描画を行なう場合に有効です。
      描画エリアを反映するためには、hgdraw命令のモードを適切な値に指定する必要がありますのでご注意ください。
      hgview命令は、メインウィンドウに表示される内容を指定した範囲に収めるように描画設定を変更する命令です。メインウインドウのアスペクト比率と違うものを指定した場合は、画像が歪んで表示されることになります。

      例 :
      hgdraw 0			; 描画処理(全画面)
      hgview 0,0,320,240		; 描画エリアの設定
      hgdraw 1			; 描画処理(指定エリア内)
      hgsync 12			; 時間待ち
    </Setting>
  </command>
  <command>
    <Name>texopt</Name>
    <Title>文字列描画モードを設定</Title>
    <Format>
      space,linespace,mode
      space(0)     : 文字間隔サイズ
      linespace(0) : 行間隔サイズ
      mode(0)      : 描画モード指定
    </Format>
    <Setting>
      texmes命令により描画される文字列の詳細設定を行ないます。
      space,linespaceにより、表示時の文字、行間隔サイズをドット単位で微調整可能です。
      0ならば通常の間隔で、数値がマイナスの場合は間隔が狭く、プラスの場合は広くなります。
      またmodeにより、描画モードを以下の中から指定することができます。

      モード  内容
      -----------------------------------------------
      0       アンチエイリアスあり
      1       アンチエイリアスなし
      2       アンチエイリアスなし + α値のみ更新
    </Setting>
  </command>
  <command>
    <Name>hgsettime</Name>
    <Title>リアルタイムタイマー設定</Title>
    <Format>
      val,max
      val(0)      : 設定する値
      max(100000) : タイマーの上限値
    </Format>
    <Setting>
      リアルタイムタイマーの値を設定します。
      リアルタイムタイマーは、1ms単位の高精度な時間を計測するもので、HGIMG3の動作中に使用可能です。
      (ただし、hgsetreq命令で、hgsyncの時間待ちモード(SYSREQ_DEFTIMER)を
      awaitに設定している場合はリアルタイムタイマーを利用できません。)
      リアルタイムタイマーは、1msごとに常に1づつカウントアップされます。
      また、タイマーの上限値を越えた場合は、0に戻ります。
      リアルタイムタイマーの値は、hggettime命令によって取得することができます。
    </Setting>
  </command>
  <command>
    <Name>hggettime</Name>
    <Title>リアルタイムタイマー取得</Title>
    <Format>
      val,type
      val     : 結果が代入される変数名
      type(0) : 取得タイプ
    </Format>
    <Setting>
      リアルタイムタイマーの情報を取得して、valで指定された変数に代入します。
      リアルタイムタイマーは、1ms単位の高精度な時間を計測するもので、HGIMG3の動作中に使用可能です。
      取得タイプの値によって、取得される内容が変わります。
      取得タイプが0の場合は、1msごとにカウントアップされるリアルタイムタイマーの値をそのまま取得します。
      取得タイプが1の場合は、リアルタイムタイマーが上限値を越えた回数を取得します。
      リアルタイムタイマーの値は、いつでもhgsettime命令によって設定することができます。
    </Setting>
  </command>
  <command>
    <Name>meshmap</Name>
    <Title>メッシュマップ情報の更新</Title>
    <Format>
      var,id,mode,factor
      var     : メッシュマップ情報が代入されている配列変数名
      id(0)   : 処理の対象となるメッシュモデルID
      mode(0) : 更新モード
      factor(1.0) : 更新に使用される倍率(実数)
    </Format>
    <Setting>
      配列変数に代入されている、メッシュマップ情報をモデルに反映させます。
      メッシュマップ情報は、整数型の配列変数としてX,Y方向に分割された格子単位の情報を保持するものです。メッシュ頂点ごとの高さを始めとして、UVなど様々な情報をリアルタイムに更新することができます。
      これにより、起伏のある地面やマップチップを表現することができます。
      modeで指定する値により、更新される情報が変わります。

      モード  内容
      -----------------------------------------------
      0       メッシュのY座標
      1       メッシュのX座標
      2       メッシュのZ座標
      3       メッシュのテクスチャU座標
      4       メッシュのテクスチャV座標
      $100    メッシュのテクスチャをマッピング

      modeに$100(256)を指定した場合は、メッシュマップ情報の値(0〜3)をもとに４分割された地形用のテクスチャマップチップを表示するためのUV値が設定されます。

      メッシュの座標が変更された場合には、法線の再計算が行なわれます。
      その場合、モードの値に16を足すことで、スムーズな法線が作成されます
      (ただし、計算コストがかかります。またメッシュマップの繰り返しテクスチャを使用していないものが対象になります)。

      meshmap命令は、すべての頂点に対して配列変数の内容をもとに値を設定します。
      設定される値には、factorの倍率が一律に適用されます。
      つまり、変数に格納されている値が15だった場合でも、factorに0.1を指定すると、実際に設定される値は1.5になります。
      getvarmap命令と組み合わせて使用することで、画像データをもとにして高さや、マップチップの設定を行なうことができます。
    </Setting>
  </command>
  <command>
    <Name>getvarmap</Name>
    <Title>メッシュマップ情報の作成</Title>
    <Format>
      var,sx,sy,mode
      var     : メッシュマップ情報が代入される配列変数名
      sx(0)   : X方向分割数
      sy(0)   : Y方向分割数
      mode(0) : 取得モード
    </Format>
    <Setting>
      描画バッファの内容からメッシュマップ情報を作成します。
      メッシュマップ情報は、整数型の配列変数としてX,Y方向に分割された格子単位の情報を保持するものです。メッシュ頂点ごとの高さを始めとして、UVなど様々な情報を格納することができます。
      描画先に指定されているHSPの画像バッファの内容を読み取って、指定された配列変数に値を設定します。
      あらかじめ、代入される変数は２次元配列として初期化されている必要があります。
      ２次元配列のサイズは、(sx,sy)で指定された数よりもそれぞれ1づつ多い、頂点数の数だけ配列を確保する点に注意してください。
      (XY分割数を(sx,sy)とすれば、配列の初期化を行なうサイズは、(sx+1,sy+1)となります。)

      modeで指定する値により、取得される情報が変わります。

      モード  内容
      -----------------------------------------------
      0       白を0、黒を255とした輝度情報
      1       白をスキップ、それ以外を1とする値
      2       白はスキップ、それ以外を2とする値
      17      白を0、それ以外を1とする値
      18      白を0、それ以外を2とする値

      画像の点を読み取り、それに応じた値がメッシュマップ情報として代入されます。
      (画像の色は関係ありません。RGBのうち、最も小さな値を読み取ります。)
    </Setting>
  </command>
  <command>
    <Name>objwalk</Name>
    <Title>メッシュマップ上の移動</Title>
    <Format>
      var,id,x,y,z
      var      : 結果が代入される変数名
      id(0)    : 移動を行なうオブジェクトID
      x(0.0)   : X方向の移動量(実数)
      y(0.0)   : Y方向の移動量(実数)
      z(0.0)   : Z方向の移動量(実数)
    </Format>
    <Setting>
      指定したオブジェクトを(x,y,z)の方向に移動させます。
      単に座標を移動させるだけでなく、地面を示すロッシュマップや、拡張コリジョンを設定したオブジェクトを考慮した上で、適切な移動先が設定されます。
      varで指定された変数には、実際に移動した大きさ(ベクトル)が代入されます。
      (変数は、double型の配列として要素0〜2に値が代入されます)

      起伏のある地面の上を移動させる場合は、適切なモードがオブジェクトに対して設定されている必要があります。
      OBJ_GROUNDのモードが設定されているオブジェクトは、地面として認識されます。
      OBJ_STANDのモードが設定されているオブジェクトは、地面の上に配置されます。
      OBJ_GRAVITYのモードが設定されているオブジェクトは、重力計算が付加されます。
      また、オブジェクトを障害物として認識させる場合にも、モード及びコリジョングループの設定が必要となります。
      OBJ_STATICのモードが設定されているオブジェクトは、障害物となります。

      objwalk命令による移動時に得られる様々な情報をgetcolvec命令により取得することが可能です。
    </Setting>
  </command>
  <command>
    <Name>objfloor</Name>
    <Title>地面からの表示オフセット設定</Title>
    <Format>
      id,offset
      id(0)      : 設定を行なうオブジェクトID
      offset(0.0): Y方向のオフセット値(実数)
    </Format>
    <Setting>
      地面の上を移動する際に表示されるオブジェクトのY座標に対するオフセット値を設定します。
      これは、地面にあたる座標から指定された値だけ上方向にずらして表示を行なうためのパラメーターです。
      モデルの中心座標によっては、地面に埋まってしまうことがあるのを回避します。
      ここで設定されたオフセット値は、objwalk命令で地面の上を移動した場合などに適用されます。
    </Setting>
  </command>
  <command>
    <Name>getcolvec</Name>
    <Title>コリジョン情報の取得</Title>
    <Format>
      var1,var2,var3,id,mode
      var1    : Xの結果が代入される変数名
      var2    : Yの結果が代入される変数名
      var3    : Zの結果が代入される変数名
      id(0)   : 対象となるオブジェクトID
      mode(0) : 取得モード
    </Format>
    <Setting>
      コリジョンとオブジェクトに関する各種情報を取得します。
      idで指定されたオブジェクトの情報がvar1,var2,var3で指定した変数に代入されます。
      取得される情報は、modeの値によって異なります。
      modeの内容は、以下の通りです。

      モード  内容
      -----------------------------------------------
      0      足元にある地面の傾き(法線)を取得する
      1      地面のオブジェクトID、X,Y分割数を取得する
      2      コリジョンスケール値を取得する
      3      拡張コリジョンパラメーターを取得する
      4      地面のY座標、表示Yオフセット値を取得する
      16      地面のオブジェクトID、X,Y分割数を取得する
      17      押し出しに関する各種情報
      18      オブジェクト汎用ユーザー情報を取得する


      モードが0〜15までは、実数値としてvar1〜var3が設定されます。
      モード16以降は、整数値としてvar1〜var3が設定されます。
      (あらかじめ変数の型を設定しておく必要はありません。)

      モード17の押し出しに関する各種情報は、var1に押し出しを行なったかどうかのフラグ値を、var2に押し出しを行なった
      オブジェクトのIDを、var3には自分が押し出された場合に押し出した側のオブジェクトIDが代入されます。
    </Setting>
  </command>
  <command>
    <Name>getnearobj</Name>
    <Title>最も近くにあるオブジェクトを検索</Title>
    <Format>
      var,id,group,range
      var      : 結果が代入される変数名
      id(0)    : 検索元のオブジェクトID
      group(0) : 検索対象となるコリジョングループ
      range(10.0): 検索を行なう距離(実数)
    </Format>
    <Setting>
      検索元のオブジェクトIDから最も近い場所にある別なオブジェクトを検索します。
      idで指定したオブジェクトの周囲で、最も近い位置にあるオブジェクトを検索して、varで指定された変数にオブジェクトIDを代入します。
      検索の際に、groupで指定したコリジョングループと、rangeで指定した距離を参照します。
      groupで指定するコリジョングループと一致するオブジェクトだけを検索します。
      (あらかじめsetcoli命令等で設定されている衝突対象のグループは参照されません)
      rangeは、どの距離までを検索対象とするかを指定します。
      3Dオブジェクトの場合は座標の距離を、2Dオブジェクトの場合は2D座標上の距離(ドット数)を使用します。
    </Setting>
  </command>
  <command>
    <Name>wave_init</Name>
    <Title>波紋の初期化</Title>
    <Format>
      p1,p2
      p1(32) : 初期化Xサイズ
      p2(32) : 初期化Yサイズ
    </Format>
    <Setting>
      波紋生成機能の初期化を行ないます。
      p1,p2パラメーターで、X,Y方向の分割数を指定します。
      波紋生成機能は、メッシュマップの頂点に対応した波紋の伝達や弾性の計算を行なうものです。
      ただし、厳密な物理演算を行なっているわけではなく、パフォーマンスを優先した簡易的なレベルに計算量が抑えられています。
      これらの機能は、画面上の演出や効果などに利用することができます。
      波紋生成機能を利用するためには、格子の初期化とメッシュの高さ情報を格納する配列変数を作成しておく必要があるので注意してください。
      波紋の初期化は、何度でも行なうことが可能です。
      初期化を行なうと、すべての頂点が高さ0にリセットされます。
    </Setting>
  </command>
  <command>
    <Name>wave_set</Name>
    <Title>波紋の高さを設定</Title>
    <Format>
      x,y,pow,mode
      x(0)    : 頂点のX位置
      y(0)    : 頂点のY位置
      pow(0)  : 高さの値
      mode(0) : 設定モード
    </Format>
    <Setting>
      波紋生成機能での、波紋の高さを設定します。
      必ず、先にwave_init命令によって初期化を行なっておく必要があります。
      頂点(x,y)の位置にある高さをpowで指定した値として設定します。
      また、modeの値によりいくつかの設定方法を選択することができます。

      モード  内容
      -----------------------------------------------
      0       指定した位置のみ値を設定します
      1       円錐状になるように周囲の値を設定します(弱)
      2       円錐状になるように周囲の値を設定します(強)
      3       球形に盛り上げます(上書き)
      4       球形に盛り上げます(追加)
    </Setting>
  </command>
  <command>
    <Name>wave_apply</Name>
    <Title>波紋の状態を取得</Title>
    <Format>
      var,mode
      var      : 結果が代入される変数名
      mode(0)  : 取得モード
    </Format>
    <Setting>
      波紋生成機能による計算を行ない、結果を変数に読み出します。
      必ず、先にwave_init命令によって初期化を行なっておく必要があります。
      また、varで指定する配列変数は、必ず整数型でグリッドサイズよりもX,Yともに1つ大きい値で初期化されている必要があります。
      (頂点の数はグリッドの分割数より１つ多くなるためです)

      modeの値により、処理の内容を指定することができます。
      モードの内容は、以下の通りです。

      モード  内容
      -----------------------------------------------
      0       前回の結果のみを取り出す
      1       弾性計算を行ない結果を取り出す
      2       波紋の計算を行ない結果を取り出す
      -1      変数の内容を波紋バッファに書き込む(デバッグ用)

      wave_apply命令は、あくまでもメッシュに適用するための計算を行なうためのものです。
      実際の画面上に表示するためのメッシュマップへ適用する場合は、meshmap命令を使用する必要があります。
    </Setting>
  </command>
  <command>
    <Name>delmodel</Name>
    <Title>モデルの削除</Title>
    <Format>
      ModelID
      ModelID  : モデルID
    </Format>
    <Setting>
      指定されたモデルを削除します。
      モデルに関する情報や読み込まれているリソースもすべて解放されます。
      オブジェクトに割り当てられているモデルを削除した場合には、何も表示されなくなります。(その際にもオブジェクトは削除されないので注意してください。)
      モデルの削除と登録はコストの高い命令なので、毎フレームの単位で行なうような使い方は推奨されません。
      必要なモデルはシーンの描画前に用意し、シーンを入れ替える場合はhgreset命令によってすべて破棄してから再登録を行なう方法が効率的です。
    </Setting>
  </command>
  <command>
    <Name>hgcnvaxis</Name>
    <Title>3D座標の変換を行なう</Title>
    <Format>
      var_x,var_y,var_z,x,y,z,mode
      var_x   : X値が代入される変数
      var_y   : Y値が代入される変数
      var_z   : Z値が代入される変数
      x(0.0)  : 変換元のX値
      y(0.0)  : 変換元のY値
      z(0.0)  : 変換元のZ値
      mode(0) : 変換モード
    </Format>
    <Setting>
      決められたモードに従って、(x,y,z)の3D座標を変換します。
      結果は、var_x,var_y,var_zで指定された変数に実数型で代入されます。(変数型は自動的に設定されます)
      モード値による変換の内容は以下の通りです。

      モード  内容
      -----------------------------------------------
      0       描画される2D座標(X,Y)位置+Zバッファ値
      1       0と同じだが(X,Y)座標が正規化されたもの
      2       ビュー変換を行なった(X,Y,Z)座標
      +16     Y軸の値を正負逆として扱う

      モード0と1は、スクリーン上に2D投影を行なった際のX,Y座標、及びZバッファ値に変換します。
      モード2では、カメラ位置を考慮したビュー変換を行なったX,Y,Z座標値に変換します。
      モード値に16を加算すると、Y軸の値を正負逆として扱います。これは、HSP3.21より前のバージョンとの互換性を持たせるため用意されています。
    </Setting>
  </command>
  <command>
    <Name>hgobaq</Name>
    <Title>HGIMG3でのOBAQ初期化</Title>
    <Format>
      p1,p2,p3
      p1(0) : OBAQシステムポインタ値
      p2(0) : デバッグ表示モード設定(0=ON/1=OFF)
      p3(0) : 2D/3D表示モード設定(0=2D/1=3D)
    </Format>
    <Setting>
      HGIMG3からOBAQ(物理エンジンプラグイン)を使用するための初期化を行ないます。
      あらかじめ、OBAQプラグインを初期化した上で、qgetptr命令により取得されたOBAQシステムポインタ値をp1に指定する必要があります。
      p2によりデバッグ表示モードを指定します。これは、qdraw命令で指定される表示モードスイッチと同様の内容になります。
      p3で、2D/3D表示の切り替えを行ないます。
      デフォルトか、0が指定されている場合は2Dモードとして通常のOBAQと同様の方法でHGIMG3の画面上に描画を行ないます。
      p3に1が指定されていた場合は、3DモードとなりOBAQの描画を3Dポリゴン(板)の上に貼り付ける形で3D空間上にオブジェクトとして配置することができます。
      3D表示モードを利用する場合は、別途addobaq3d命令によりOBAQモデルを作成し、オブジェクトの登録を行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>hgceldiv</Name>
    <Title>HGIMG3でのセル分割指定</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜(0)  : テクスチャID
      p2=1〜(0)  : 横方向の分割サイズ
      p3=1〜(0)  : 縦方向の分割サイズ
      p4=0〜(0)  : 横方向の中心座標
      p5=0〜(0)  : 縦方向の中心座標
    </Format>
    <Setting>
      HGIMG3が管理するテクスチャのセル分割サイズ、及び中心座標を設定します。
      これは、HGIMG3上でOBAQプラグインを使用する際に、OBAQオブジェクトのマテリアル指定でセルIDを指定する時に参照されるものです。
      hgceldivは、標準命令であるceldivと同様の機能をHGIMG3で再現するためのものです。
      HGIMG3単体で使用する場合は、特に設定を行なう必要はありません。
    </Setting>
  </command>
  <command>
    <Name>addobaq3d</Name>
    <Title>OBAQ3Dモデルを作成</Title>
    <Format>
      var
      var     : 作成されたモデルIDが代入される変数名
    </Format>
    <Setting>
      OBAQ3Dモデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      OBAQ3Dモデルは、OBAQプラグインが管理するオブジェクトの描画を行ないます。
      OBAQ3Dモデルは、平面の板に対して描画を行ないますが、3D空間上に自由に配置し、回転をさせることができます。板(PLATE)モデルと同様の性質を持ったモデルです。
      OBAQ3Dモデルは、必ずhgobaq命令によりOBAQの初期化と3D表示の設定を行なっておく必要があります。
    </Setting>
  </command>
  <command>
    <Name>addline</Name>
    <Title>線分モデルを作成</Title>
    <Format>
      var,p1,p2,p3
      var     : 作成されたモデルIDが代入される変数名
      p1(-1)  : テクスチャID
      p2(0)   : セルID、カラーコード
      p3(16)  : 線サイズ
    </Format>
    <Setting>
      線分モデルを作成します。
      正常にモデルが作成されると、varで指定した変数にモデルIDが代入されます。
      線分モデルは、オブジェクトに設定された座標から、オブジェクトのworkグループに設定された座標(相対位置)に線を引く機能を持っています。
      p1にテクスチャIDを指定した場合は、テクスチャを使用して線を描画します。
      その際には、p2で指定した値をセルID(hgceldivで分割された中でのID)として扱います。
      p1がデフォルトかマイナス値の場合は、p2で指定されたカラーコードで線を描画します。また、テクスチャ描画時はp3の線サイズが有効になります。
    </Setting>
  </command>
  <command>
    <Name>newemit</Name>
    <Title>エミッターを作成</Title>
    <Format>
      p1,p2,p3,p4
      p1     : 作成されたエミッターIDが代入される変数名
      p2(0)  : エミッターモード
      p3(8)  : オブジェクト生成数
      p4(-1) : エミッターID
    </Format>
    <Setting>
      エミッターを初期化し、p1で指定した変数にエミッターIDを代入します。

      エミッターとは、複数のオブジェクトを一度に発生させることのできる特別な仕組みです。
      ランダムなパラメーターなど自由な組み合わせで生成することのできる、オブジェクト発生器と考えてください。
      新しくエミッターを作成する場合には、必ずnewemit命令でエミッターIDを取得しておく必要があります。
      p2で初期化するエミッターのモードを指定することができます。

      モード          値      内容
      -----------------------------------------------
      EMITMODE_NONE	0	何もしない
      EMITMODE_STATIC	1	出現のみで移動しない
      EMITMODE_CIRCLE	2	同心円状に移動
      EMITMODE_RANDOM	3	ランダムな方向に移動
      EMITMODE_LOOKAT	16	移動方向に向ける(他と併用可能)

      p3で一度に生成されるオブジェクトの数を設定します。
      デフォルトでは、8個のオブジェクトが一度に生成される設定になります。
      作成されたエミッターには、「emit_」で始まるエミッター設定命令によって多彩な動作を登録しておくことができます。
      p4で上書きするエミッターIDを指定することができます。
      新規に作成する場合は、省略するかマイナス値にしておいてください。

      エミッターが作成されてすぐにオブジェクトが発生するわけではありません。
      あらかじめ、発生条件を色々と設定した上で必要な時に発生させます。
      エミッターを実際に利用する場合は、hgemit命令によっていつでも発生させることができるほか、setobjemit命令によりオブジェクトに対して適用することも可能です。
    </Setting>
  </command>
  <command>
    <Name>delemit</Name>
    <Title>エミッターを削除</Title>
    <Format>
      p1
      p1(0)   : エミッターID
    </Format>
    <Setting>
      p1で指定されたエミッターを削除します。
      削除されたエミッターIDは、再度newemit命令で初期化するまでは使用できません。
    </Setting>
  </command>
  <command>
    <Name>emit_size</Name>
    <Title>エミッターの発生範囲を設定</Title>
    <Format>
      id,dx,dy,dz
      id(0)   : エミッターID
      dx(0.0) : 発生範囲X(実数)
      dy(0.0) : 発生範囲Y(実数)
      dz(0.0) : 発生範囲Z(実数)
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトの範囲を設定します。
      発生範囲は、もともと指定された発生座標からどの程度までちらばるかを指定するものです。
      たとえば、エミッターの発生座標が(10,10,10)であったとして、発生範囲が(20,10,0)と設定された場合には、
      エミッターから発生されるオブジェクトは、(10〜30,10〜20,10)の範囲内で乱数によりちらばることになります。
      これにより、発生する初期位置をある程度ばらつきを持たせることができます。
      emit_sizeの設定が行なわれないエミッターは、初期値として(0,0,0)が設定されています。
    </Setting>
  </command>
  <command>
    <Name>emit_speed</Name>
    <Title>エミッターのスピード設定</Title>
    <Format>
      id,speed,spdopt
      id(0)       : エミッターID
      speed(1.0)  : スピード初期値(実数)
      spdopt(0.0) : スピード範囲(実数)
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトの速度を設定します。
      オブジェクトの速度は、発生すると同時に移動を開始するオブジェクトに与えられる数値です。
      スピードの値が大きいほど、速い速度で移動を行ないます。
      speedパラメーターで、設定するスピードの初期値を指定します。
      spdoptが0より大きい値の場合は、その範囲内でばらつきを持たせます。
      たとえば、(1.0,5.0)が指定された場合には、速度は1.0〜6.0の範囲内で乱数によりちらばることになります。
      emit_speedの設定が行なわれないエミッターは、初期値として(1.0,0.0)が設定されています。
    </Setting>
  </command>
  <command>
    <Name>emit_angmul</Name>
    <Title>エミッターの角度係数を設定</Title>
    <Format>
      id,dx,dy,dz
      id(0)   : エミッターID
      dx(0.0) : 角度係数X(実数)
      dy(0.0) : 角度係数Y(実数)
      dz(0.0) : 角度係数Z(実数)
    </Format>
    <Setting>
      idで指定されたエミッターが発生する際のオブジェクト移動角度係数を設定します。
      エミッターによりオブジェクトが発生する場合に、移動する方向の角度が算出されます。
      移動方向は、基本的にEMITMODE_RANDOMモードの場合は、全周360度からランダムに選ばれ、EMITMODE_CIRCLEモードの場合は全周360度を発生する個数で均等に割り付けます。
      角度係数は、この角度に乗算される数値になります。
      これにより、全周360度だけでなく180度、90度といった限定された範囲内での移動を設定することができます。
      たとえば、角度係数に0.5を指定した場合は、全周の半分(180度)で計算が行なわれます。さらに、emit_angopt命令により角度加算値を設定することにより移動の範囲を自由に設定することが可能です。
      角度係数は、X,Y,Z軸ごとに個別設定可能です。また、2Dスプライトの場合はZ軸回転のみが反映されます。
      emit_angmulの設定が行なわれないエミッターは、初期値として(1,1,1)が設定されています。
    </Setting>
  </command>
  <command>
    <Name>emit_angopt</Name>
    <Title>エミッターの角度加算値を設定</Title>
    <Format>
      id,dx,dy,dz
      id(0)   : エミッターID
      dx(0.0) : 角度加算値X(実数)
      dy(0.0) : 角度加算値Y(実数)
      dz(0.0) : 角度加算値Z(実数)
    </Format>
    <Setting>
      idで指定されたエミッターが発生する際のオブジェクト移動角度加算値を設定します。
      エミッターによりオブジェクトが発生する場合に、移動する方向の角度が算出されますが、その値に加算する定数をX,Y,Z軸ごとに指定できます。
      発生するオブジェクトの移動方向(角度)は、

      オブジェクト角度 = 基本角度 * 角度係数 + 角度加算値

      という形で算出されます。(基本角度の詳細は、emit_angmul命令のリファレンスを参照してください)
      角度係数を設定するemit_angmul命令と併用することで、移動角度の範囲を限定した形でオブジェクトを発生させることが可能になります。
      emit_angoptの設定が行なわれないエミッターは、初期値として(0,0,0)が設定されています。
    </Setting>
  </command>
  <command>
    <Name>emit_model</Name>
    <Title>エミッターの発生モデルを設定</Title>
    <Format>
      id,model,modelnum,objmode,efx
      id(0)       : エミッターID
      model(0)    : モデルID
      modelnum(0) : モデルID範囲
      objmode(0)  : オブジェクトモード設定値
      efx(0x100)  : efx設定値
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトのモデルIDなど詳細パラメーターを設定します。
      エミッターから発生されるオブジェクトの種類やモード設定など重要な要素を指定します。
      エミッターを使用する際には必ず設定するようにしてください。
      modelパラメーターで、発生するモデルIDを指定します。モデルIDは、regobj命令で設定可能なモデルIDと同様です。
      modelnumで、発生するモデルIDの範囲を指定することができます。
      これは、ランダムに別々なモデルを発生させる際に使用することができます。
      たとえば、モデルIDが3で、modelnumが4の場合は、モデルID3〜6の範囲でランダムにオブジェクトが発生することになります。
      単一のモデルだけを発生させる場合は、modelnumは0のままにしておいてください。
      objmodeパラメーターで、発生時に設定されるオブジェクトのモードを指定することができます。モード値は、regobj命令で指定する値と同様です。
      efxパラメーターで、発生時に設定されるオブジェクトのefxパラメーターを指定することができます。
      efxパラメーターは、setefx命令で指定する１番目のパラメーターと同様です。
      これにより、半透明や加算などの特殊効果設定をオブジェクトに適用することが可能になります。
    </Setting>
  </command>
  <command>
    <Name>emit_event</Name>
    <Title>エミッターのイベント設定</Title>
    <Format>
      id,event,eventnum
      id(0)   : エミッターID
      event(0)    : イベントID
      eventnum(0) : イベントID範囲
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトのイベントIDを設定します。
      eventパラメーターで、発生するイベントIDを指定します。イベントIDは、setevent命令で設定可能なイベントIDと同様です。
      eventnumで、発生するイベントIDの範囲を指定することができます。
      これは、ランダムに別々なイベントを発生させる際に使用することができます。
      たとえば、イベントIDが2で、eventnumが5の場合は、モデルID2〜6の範囲でランダムにイベントが発生することになります。
      単一のイベントだけを発生させる場合は、eventnumは0のままにしておいてください。
      emit_eventの設定が行なわれないエミッターは、オブジェクト発生時にイベント設定は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>emit_num</Name>
    <Title>エミッターの発生数設定</Title>
    <Format>
      id,num,numopt
      id(0)     : エミッターID
      num(0)    : オブジェクト発生数
      numopt(0) : 発生範囲
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトの数を設定します。
      numで、発生するオブジェクトの数を指定することができます。
      これは、ランダムに別々な数のオブジェクトを発生させる際に使用することができます。
      たとえば、オブジェクト発生数が5で、numoptが10の場合は、5〜14の範囲でランダムに発生数が変わることになります。
      emit_numの設定が行なわれないエミッターは、newemitで指定された発生個数とともに、発生範囲(numopt)は0になっています。
    </Setting>
  </command>
  <command>
    <Name>emit_group</Name>
    <Title>エミッターのグループ設定</Title>
    <Format>
      id,mygroup,enegroup
      id(0)       : エミッターID
      mygroup(0)  : 自分が属するグループ値
      enegroup(0) : 衝突を検出する対象となるグループ値
    </Format>
    <Setting>
      idで指定されたエミッターが発生するオブジェクトのコリジョングループを設定します。これは、setcoli命令によりオブジェクトに設定する値と同様です。
      特定のコリジョングループを持つオブジェクトを発生させる場合に使用してください。
      emit_groupの設定が行なわれないエミッターは、オブジェクト発生時にコリジョングループ設定は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>hgemit</Name>
    <Title>エミッター発生実行</Title>
    <Format>
      id,dx,dy,dz
      id(0)   : エミッターID
      dx(0.0) : X座標値(実数)
      dy(0.0) : Y座標値(実数)
      dz(0.0) : Z座標値(実数)
    </Format>
    <Setting>
      idで指定されたエミッターを、(dx,dy,dz)の座標から発生させます。
      あらかじめエミッターから発生させるオブジェクトの設定を行なっておく必要があります。
      実行後に、発生させたオブジェクトの合計数がシステム変数statに代入されます。
      配置されているオブジェクトに対してエミッターを適用する場合は、setobjemit命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>setobjemit</Name>
    <Title>オブジェクトにエミッター適用</Title>
    <Format>
      p1,p2
      p1(0) : オブジェクトID
      p2(0) : エミッターID
    </Format>
    <Setting>
      配置されているオブジェクトをエミッターの発生元として設定します。
      p1で指定されたオブジェクトに、p2のエミッターを割り当てます。
      以降は、オブジェクト表示時にエミッターとしても動作するようになります。
      エミッターIDにマイナス値を指定することで、エミッターの適用を解除することができます。
    </Setting>
  </command>
  <command>
    <Name>groupmod</Name>
    <Title>同一グループに演算適用</Title>
    <Format>
      group,mocid,dx,dy,dz,opt
      group(0) : 演算の対象となるコリジョングループ
      mocid(0) : MOCの適用先
      dx(0.0)  : X演算値(実数)
      dy(0.0)  : Y演算値(実数)
      dz(0.0)  : Z演算値(実数)
      opt(0)   : 演算方法
    </Format>
    <Setting>
      同じコリジョングループに属しているモデルに対してまとめて演算を行ないます。
      有効なすべてのオブジェクトの中で、groupパラメーターで指定したコリジョングループが指定されているものが操作の対象となります。
      groupパラメーターで指定されるコリジョングループには、複数のビットを組み合わせることが可能です。たとえば、グループ1とグループ2を同時に指定する場合は、3という値になります。
      mocidパラメーターは、MOCグループを示す値を指定します。MOCグループには、以下を指定することが可能です。

      MOCグループ    mocid
      ---------------------------
      pos           0
      ang           1
      scale         2
      dir           3
      efx           4
      work          5

      (dx,dy,dz)により演算で使用する値をします。
      演算の方法は、optパラメーターによって指定されまます。optパラメーターには、以下を指定することができます。

      opt  演算方法
      ---------------------------
      0   代入
      1   加算
      2   減算
      3   乗算

      optが省略、または0が指定された時は、(dx,dy,dz)の値がそのまま対象となるオブジェクトに代入されます。
      それ以外の値では、すでに代入されている(X,Y,Z)値に対して(dx,dy,dz)が演算されます。
    </Setting>
  </command>
  <command>
    <Name>hgqview</Name>
    <Title>HGIMG3上のOBAQビュー設定</Title>
    <Format>
      ofsx,ofsy,ofsz,zoom
      ofsx(0.0)  : X方向の表示オフセット(実数)
      ofsy(0.0)  : Y方向の表示オフセット(実数)
      ofsz(0.0)  : Z方向の表示オフセット(実数)
      zoom(4.0) : ズーム倍率(実数)
    </Format>
    <Setting>
      HGIMG3上でobaqオブジェクトを表示する際の設定を行ないます。
      zoomパラメーターで、HGIMG3表示時のズーム倍率を指定します。
      (ofsx,ofsy,ofsz)でX,Y,Z軸に対する表示オフセットを指定することができます。
    </Setting>
  </command>
  <command>
    <Name>hgqcnvaxis</Name>
    <Title>OBAQ座標をHGIMG3座標に変換</Title>
    <Format>
      x,y,z,srcx,srcy
      (x,y,z)    : 取得する変数
      srcx(0.0)  : OBAQ上のX座標(実数)
      srcy(0.0)  : OBAQ上のY座標(実数)
    </Format>
    <Setting>
      OBAQ上のX,Y座標をHGIMG3上のX,Y,Z座標に変換します。
      これは、OBAQオブジェクトを3Dオブジェクトとして表示する際の座標を求めるものです。
      (srcx,srcy)でOBAQ上のX,Y座標を指定すると、(x,y,z)に指定された変数に実数型でHGIMG3上のX,Y,Z座標が代入されます。
    </Setting>
  </command>
  <command>
    <Name>enumobj</Name>
    <Title>オブジェクトの検索開始</Title>
    <Format>
      group
      group    : コリジョングループ
    </Format>
    <Setting>
      指定したコリジョングループに属するオブジェクトを検索します。
      検索結果は、getenum命令により取得することができます。
      検索結果が複数ある場合は、getenum命令を呼び出すたびに次の結果が返されます。
      すべての検索が終了した場合は、getenum命令でオブジェクトのIDとして-1が返されます。
    </Setting>
  </command>
  <command>
    <Name>getenum</Name>
    <Title>オブジェクトの検索結果を取得</Title>
    <Format>
      var
      var      : 結果が代入される変数名
    </Format>
    <Setting>
      enumobj命令により検索されたオブジェクトのIDを取得します。
      getenum命令を実行するたびに、次の検索結果が取得されます。取得が終わった場合には、-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>gpreset</Name>
    <Title>HGIMG4の初期化</Title>
    <Format>
      option
      option(0) : 初期化オプション
    </Format>
    <Setting>
      HGIMG4の初期化を行ないます。
      シーンを再構築する場合に使用してください。
      optionで設定した内容によって初期化の内容が変わります。

      オプション値  内容
      ---------------------------------------------------------------
      0         すべてのオブジェクトを破棄して初期状態に戻す
      1         シーンに存在するオブジェクトのみ破棄する
    </Setting>
  </command>
  <command>
    <Name>gpdraw</Name>
    <Title>シーン内の全オブジェクトを描画する</Title>
    <Format>
      option
      option(0) : 描画オプション
    </Format>
    <Setting>
      シーン内のオブジェクトをすべて描画します。
      optionパラメーターを指定することで、限られた項目の描画だけを行なうことができます。

      マクロ名                      内容
      --------------------------------------------------------------------
      GPDRAW_OPT_OBJUPDATE          オブジェクトの自動移動処理
      GPDRAW_OPT_DRAWSCENE          3Dシーン描画処理
      GPDRAW_OPT_DRAWSCENE_LATE     3Dシーン描画処理(OBJ_LATE)
      GPDRAW_OPT_DRAW2D             2Dスプライト描画処理
      GPDRAW_OPT_DRAW2D_LATE        2Dスプライト描画処理(OBJ_LATE)

      optionパラメーターを省略した場合は、すべての項目が選択されている状態になります。
      通常は、optionパラメーターを指定しなくても問題ありません。
      また、2Dの直接描画命令だけを使用して、オブジェクトによる描画が不要な場合は、gpdraw命令を記述する必要もありません。
      OBJ_LATEのモードが付加されたもの(半透明α値が設定されているものを含む)は、不透明のオブジェクトよりも後に描画するため、項目が分けられています。
      複数の項目を「|」で区切って指定することもできます。

      例:
      gpdraw GPDRAW_OPT_DRAW2D|GPDRAW_OPT_DRAW2D_LATE

      上の例では、2Dスプライト描画処理、2Dスプライト描画処理(OBJ_LATE)だけを実行します。
      これを利用すると、3Dシーン描画と2Dスプライト描画の間にgcopy命令など別な描画命令による
      表示を行なうことが可能になります。
    </Setting>
  </command>
  <command>
    <Name>gpusescene</Name>
    <Title>シーンの切り替え</Title>
    <Format>
      id
      id(0) : 選択するシーンID
    </Format>
    <Setting>(今後のバージョンでサポートするための予約キーワードです。機能は現在まだ実装されていません。)</Setting>
  </command>
  <command>
    <Name>gpsetprm</Name>
    <Title>オブジェクトのコアパラメーター設定</Title>
    <Format>
      objid,prmid,value
      objid(0) : オブジェクトID
      prmid(0) : コアパラメーターID
      value(0) : 設定する値(整数値)
    </Format>
    <Setting>
      オブジェクトごとに保持されているコアパラメーターに値を設定します。
      コアパラメーターは、32bit整数値で、様々な情報を管理しています。
      コアパラメーターIDとして指定可能な項目は以下の通りです。

      マクロ名             | 内容
      --------------------------------------------------------------
      PRMSET_FLAG            オブジェクト登録フラグ(*)
      PRMSET_MODE            モード値
      PRMSET_ID              オブジェクトID(*)
      PRMSET_ALPHA           透明度(α値)
      PRMSET_TIMER           タイマー値
      PRMSET_MYGROUP         自身のコリジョングループ
      PRMSET_COLGROUP        衝突検出するコリジョングループ
      PRMSET_SHAPE           形状ID(*)
      PRMSET_USEGPMAT        マテリアルID
      PRMSET_USEGPPHY        物理設定ID
      PRMSET_COLILOG         コリジョンログID(*)
      PRMSET_SPRID           ソースバッファID(スプライトのみ)
      PRMSET_SPRCELID        ソースのセルID(スプライトのみ)
      PRMSET_SPRGMODE        コピーモード(スプライトのみ)

      (*)の項目は読み出しのみ
    </Setting>
  </command>
  <command>
    <Name>gpgetprm</Name>
    <Title>オブジェクトのコアパラメーター取得</Title>
    <Format>
      var,objid,prmid
      var      : 値が代入される変数名
      objid(0) : オブジェクトID
      prmid(0) : コアパラメーターID
    </Format>
    <Setting>
      オブジェクトごとに保持されているコアパラメーターに値を取得します。
      コアパラメーターは、32bit整数値で、様々な情報を管理しています。
      コアパラメーターIDとして指定可能な項目は以下の通りです。

      マクロ名             | 内容
      --------------------------------------------------------------
      PRMSET_FLAG            オブジェクト登録フラグ(*)
      PRMSET_MODE            モード値
      PRMSET_ID              オブジェクトID(*)
      PRMSET_ALPHA           透明度(α値)
      PRMSET_TIMER           タイマー値
      PRMSET_MYGROUP         自身のコリジョングループ
      PRMSET_COLGROUP        衝突検出するコリジョングループ
      PRMSET_SHAPE           形状ID(*)
      PRMSET_USEGPMAT        マテリアルID
      PRMSET_USEGPPHY        物理設定ID
      PRMSET_COLILOG         コリジョンログID(*)
      PRMSET_SPRID           ソースバッファID(スプライトのみ)
      PRMSET_SPRCELID        ソースのセルID(スプライトのみ)
      PRMSET_SPRGMODE        コピーモード(スプライトのみ)

      (*)の項目は読み出しのみ
    </Setting>
  </command>
  <command>
    <Name>gppostefx</Name>
    <Title>ポストエフェクト生成</Title>
    <Format>
      var
      var     : エフェクトIDが代入される変数名
    </Format>
    <Setting>(今後のバージョンでサポートするための予約キーワードです。機能は現在まだ実装されていません。)</Setting>
  </command>
  <command>
    <Name>gpuselight</Name>
    <Title>ライトオブジェクトの切り替え</Title>
    <Format>
      id
      id(0) : 選択するライトオブジェクトのID
    </Format>
    <Setting>
      指定したノードオブジェクトを有効なライトオブジェクトとして選択します。
      必ず、ライトとして初期化されているノードオブジェクトを指定する必要があります。
      ライトを切り替えることで、以降に生成されるオブジェクトを照らすライトが変更されます。
    </Setting>
  </command>
  <command>
    <Name>gpusecamera</Name>
    <Title>カメラオブジェクトの切り替え</Title>
    <Format>
      id
      id(0) : 選択するカメラオブジェクトのID
    </Format>
    <Setting>
      指定したノードオブジェクトを有効なカメラオブジェクトとして選択します。
      必ず、カメラとして初期化されているノードオブジェクトを指定する必要があります。
      以降は、切り替えられたカメラを視点としてシーンの描画が行なわれます。
    </Setting>
  </command>
  <command>
    <Name>gpmatprm</Name>
    <Title>マテリアルのパラメーター設定</Title>
    <Format>
      id,"name",x,y,z
      id(0)  : マテリアルID
      "name" : パラメーター名
      x(0.0) : Xの設定値(実数値)
      y(0.0) : Yの設定値(実数値)
      z(0.0) : Zの設定値(実数値)
    </Format>
    <Setting>
      生成されたマテリアルのシェーダーパラメーターを設定します。

      例:
      gpmatprm objid,"u_diffuseColor",1,0,0.5 ; マテリアルのパラメーター設定

      上の例では、u_diffuseColorという名称のパラメーターに( 1.0, 0.0, 0.5 )のベクトル値を設定します。
      シェーダーパラメーターに設定する項目の数に応じて、gpmatprm1、gpmatprm4命令が用意されています。
      (x,y,z)の3項目を設定する場合は、gpmatprmを使用してください。
    </Setting>
  </command>
  <command>
    <Name>gpmatstate</Name>
    <Title>マテリアルのステート設定</Title>
    <Format>
      objid,"name","value"
      id(0)   : マテリアルID
      "name"  : 設定項目名(文字列)
      "value" : 設定値(文字列)
    </Format>
    <Setting>
      生成されたマテリアルの表示ステート設定を変更します。
      文字列としてnameで指定された項目に対して、valueで指定された内容を設定します。
      項目名と設定内容はすべて文字列で行なうので注意してください。
      項目名と設定内容はすべて文字列で行なうので注意してください。(項目名及び設定値は大文字小文字を区別しません。)

      name             value
      --------------------------------------------------------------------
      "blend"          プレンドの有効/無効切り替え
      (true または false を指定)
      "blendSrc"       ブレンド元を選択(下記参照)
      "blendDst"       ブレンド先を選択(下記参照)
      "cullFace"       隠面除去(カリング)の有効/無効切り替え
      (true または false を指定)
      "cullFaceSide"   隠面除去(カリング)の面指定
      "depthTest"      true または false
      (true または false を指定)
      "depthWrite"     Zバッファ書き込みの有効/無効切り替え
      (true または false を指定)
      "depthFunc"      Z値比較方法を選択(下記参照)

      (*)blendSrc,blendDstで設定できる文字列

      "ZERO"                     即値(0)
      "ONE"                      即値(1)
      "SRC_COLOR"                書き込み元カラー
      "ONE_MINUS_SRC_COLOR"      書き込み元カラー(反転値)
      "DST_COLOR"                書き込み先カラー
      "ONE_MINUS_DST_COLOR"      書き込み先カラー(反転値)
      "SRC_ALPHA"                書き込み元α
      "ONE_MINUS_SRC_ALPHA"      書き込み元α(反転値)
      "DST_ALPHA"                書き込み先α
      "ONE_MINUS_DST_ALPHA"      書き込み先α(反転値)
      "CONSTANT_ALPHA"           α固定値
      "ONE_MINUS_CONSTANT_ALPHA" α固定値(反転値)
      "SRC_ALPHA_SATURATE"       書き込み元α反転値

      (*)cullFaceSideで設定できる文字列

      BACK             裏面をカリング
      FRONT            表面をカリング
      FRONT_AND_BACK   両面をカリング

      (*)depthFuncで設定できる文字列

      NEVER            常に拒否
      LESS             小さい値の時のみ許可
      EQUAL            同一値のみ許可
      LEQUAL           同一か小さい値の時のみ許可
      GREATER          大きい値の時のみ許可
      NOTEQUAL         同一でない値のみ許可
      GEQUAL           同一か大きい値の時のみ許可
      ALWAYS           常に許可
    </Setting>
  </command>
  <command>
    <Name>gpviewport</Name>
    <Title>ビューポート設定</Title>
    <Format>
      x,y,sx,sy
      x(0)  : ビューポート左上X座標
      y(0)  : ビューポート左上Y座標
      sx    : ビューポートのXサイズ
      sy    : ビューポートのYサイズ
    </Format>
    <Setting>
      HGIMG4が描画を行なう領域(ビューポート)を設定します。
      スクリーン座標の(x,y)から(sx,sy)で指定したサイズの領域に対して描画が行なわれます。
      sx,syを省略すると、現在の表示X,Yサイズがデフォルトとして指定されます。
    </Setting>
  </command>
  <command>
    <Name>setobjname</Name>
    <Title>オブジェクトのノード名を設定する</Title>
    <Format>
      objid,"name"
      objid(0) : オブジェクトのID
      "name"   : 設定される名称(文字列)
    </Format>
    <Setting>
      ノードオブジェクトに指定された名称を設定します。
      すべてのノードオブジェクトは、任意に指定した名称を設定することが可能です。
    </Setting>
  </command>
  <command>
    <Name>getobjname</Name>
    <Title>オブジェクトのノード名を取得する</Title>
    <Format>
      var,objid
      var      : 結果が代入される変数名
      objid(0) : オブジェクトのID
    </Format>
    <Setting>
      ノードオブジェクトに指定された名称を取得します。
      varで指定された変数に名称が文字列型として代入されます。
      すべてのノードオブジェクトは、任意に指定した名称が設定されています。
    </Setting>
  </command>
  <command>
    <Name>gpcolormat</Name>
    <Title>カラーマテリアルの生成</Title>
    <Format>
      var,color,opt
      var      : 生成されたマテリアルIDが代入される変数名
      color(0) : マテリアルカラー(24bitRGB値)
      opt(0)   : マテリアルオプション値
    </Format>
    <Setting>
      指定された色を持つカラーマテリアルの生成を行ないます。
      colorパラメーターは、24bitRGB値(0xRRGGBBで示される値)を指定します。省略した場合は、白色(0xffffff)が設定されます。
      マテリアルを独自に生成することにより、詳細な質感の設定が可能になります。


      例:
      gpcolormat mat_id,0xff00ff,GPOBJ_MATOPT_NOLIGHT
      gpbox id_model, 1, , mat_id

      上の例では、RGBカラーが0xff00ff(紫)の、ライティングを行なわないマテリアルを持った、立方体のノードオブジェクトが生成されます。
      optパラメーターにより、マテリアルの設定を変更することができます。
      これらの設定は、gpmatstate命令で別途設定することも可能です。

      マクロ名                内容
      -------------------------------------------------------------------
      GPOBJ_MATOPT_NOLIGHT    ライティングを行なわない
      GPOBJ_MATOPT_NOMIPMAP   MIPMAPを生成しない
      GPOBJ_MATOPT_NOCULL     カリングを無効にする
      GPOBJ_MATOPT_NOZTEST    Zテストを無効にする
      GPOBJ_MATOPT_NOZWRITE   Zバッファ書き込みを無効にする
      GPOBJ_MATOPT_BLENDADD   プレンドモードを加算に設定する

      正常にマテリアルが生成できなかった場合は、エラー3(パラメータの値が異常です)が発生します。
      正しく生成された場合は、varで指定された変数にマテリアルID(整数値)が代入されます。
    </Setting>
  </command>
  <command>
    <Name>gptexmat</Name>
    <Title>テクスチャマテリアルの生成</Title>
    <Format>
      var,"file",opt
      var     : 生成されたマテリアルIDが代入される変数名
      opt(0)  : マテリアルオプション値
    </Format>
    <Setting>
      テクスチャ(画像)マテリアルの生成を行ないます。
      マテリアルを独自に生成することにより、詳細な質感の設定が可能になります。

      例:
      gptexmat id_texmat, "res/qbox.png"	; テクスチャマテリアル作成
      gpbox id_model, 1, , id_texmat		; 箱ノードを追加

      上の例では、resフォルダ内のqbox.pngをテクスチャとして持ったマテリアルを持った、立方体のノードオブジェクトが生成されます。
      optパラメーターにより、マテリアルの設定を変更することができます。
      これらの設定は、gpmatstate命令で別途設定することも可能です。

      マクロ名                内容
      -------------------------------------------------------------------
      GPOBJ_MATOPT_NOLIGHT    ライティングを行なわない
      GPOBJ_MATOPT_NOMIPMAP   MIPMAPを生成しない
      GPOBJ_MATOPT_NOCULL     カリングを無効にする
      GPOBJ_MATOPT_NOZTEST    Zテストを無効にする
      GPOBJ_MATOPT_NOZWRITE   Zバッファ書き込みを無効にする
      GPOBJ_MATOPT_BLENDADD   プレンドモードを加算に設定する

      正常にマテリアルが生成できなかった場合は、エラー3(パラメータの値が異常です)が発生します。
      正しく生成された場合は、varで指定された変数にマテリアルID(整数値)が代入されます。
    </Setting>
  </command>
  <command>
    <Name>gpusermat</Name>
    <Title>カスタムマテリアルの生成</Title>
    <Format>
      var,"vsh","fsh","defs",color,opt
      var       : 生成されたマテリアルIDが代入される変数名
      "vsh"     : バーテックスシェーダーファイル名
      "fsh"     : フラグメントシェーダーファイル名
      "defs"    : 追加のラベル定義
      color(-1) : マテリアルカラー(24bitRGB値)
      opt(0)    : マテリアルオプション値
    </Format>
    <Setting>
      カスタムマテリアルを生成します。
      カスタムマテリアルは、バーテックスシェーダー及びフラグメントシェーダーを指定した独自の描画を行ないます。
      OpenGLのシェーダー言語(GLSL)で記述されたシェーダーファイル名を、"vsh"、"fsh"パラメーターに指定します。
      "defs"パラメーターには、シェーダーコンパイル時に追加されるラベル定義を記述します。
      colorパラメーターでデフォルトのカラーを設定することができます。省略した場合は、白色(0xffffff)が設定されます。
      optパラメーターにより、マテリアルの設定を変更することができます。
      これらの設定は、gpmatstate命令で別途設定することも可能です。

      マクロ名                内容
      -------------------------------------------------------------------
      GPOBJ_MATOPT_NOLIGHT    ライティングを行なわない
      GPOBJ_MATOPT_NOMIPMAP   MIPMAPを生成しない
      GPOBJ_MATOPT_NOCULL     カリングを無効にする
      GPOBJ_MATOPT_NOZTEST    Zテストを無効にする
      GPOBJ_MATOPT_NOZWRITE   Zバッファ書き込みを無効にする
      GPOBJ_MATOPT_BLENDADD   プレンドモードを加算に設定する

      正常にマテリアルが生成できなかった場合は、エラー3(パラメータの値が異常です)が発生します。
      正しく生成された場合は、varで指定された変数にマテリアルID(整数値)が代入されます。

      カスタムマテリアルにより、任意のシェーダーを使って描画のすべてをコントロールすることができるようになります。
      これは、シェーダーについての知識がある上級者向けの拡張機能ですので、通常は使用する必要はありません。
      カスタムマテリアルを生成した場合は、gpmatprm命令によってシェーダーパラメーターに渡すための値を設定することができます。
    </Setting>
  </command>
  <command>
    <Name>gpclone</Name>
    <Title>ノードを複製</Title>
    <Format>
      var,objid
      var      : 複製されたオブジェクトのIDが代入される変数名
      objid(0) : 複製元のオブジェクトID
    </Format>
    <Setting>
      既に存在するオブジェクトと同じ設定で、新しいオブジェクトを生成します。
      varで指定された変数に、複製されたオブジェクトのIDが代入されます。
      同一の形状、パラメーター設定(物理設定を除く)を持ちますが座標や角度などを新しく設定することができます。
      同一の物体を複数生成する場合に、設定や読み込みを何度も行なう手間を軽減し高速化にもつながります。

      例:
      gpload id_model,"res/duck"	; モデル読み込み
      gpclone i, id_model		; 同じものをクローン

      上の例では、res/duck.gpbファイルによる3Dモデルノード(id_model)をクローンして変数iに新しいオブジェクトIDを代入します。
      ※現在のバージョンでは、シーン内に存在する表示可能なオブジェクト以外はクローンすることができませんので注意してください。%href
      gpdraw
    </Setting>
  </command>
  <command>
    <Name>gpnull</Name>
    <Title>ヌルノードを生成</Title>
    <Format>
      var
      var : 生成されたオブジェクトIDが代入される変数名
    </Format>
    <Setting>
      空のノードオブジェクト(ヌルノード)を生成します。
      varで指定された変数に、複製されたオブジェクトのIDが代入されます。
      ヌルノードは、カメラやライトなどモデルを持つ必要のないノードを作成する場合などに使用します。
      生成されたノードは、他のノードと同様に3D空間の中で自由に操作することが可能になります。
    </Setting>
  </command>
  <command>
    <Name>gpload</Name>
    <Title>3Dモデルノードを生成</Title>
    <Format>
      var,"file","name"
      var     : 生成されたオブジェクトIDが代入される変数名
      "file"  : 読み込みを行なうgpbファイル名
      "name"  : 読み込み対象となるノード名
    </Format>
    <Setting>
      ファイル化された3Dモデルデータ(.gpbファイル)をノードとして生成します。
      varで指定された変数に、生成されたオブジェクトのIDが代入されます。
      生成されたノードは3D空間の中で自由に操作することが可能になります。
      "file"でフォルダ及びファイル名を指定します。「.gpb」などの拡張子は指定する必要ありません。
      ファイルの中で特定の名前を持ったノードだけを読み込みたい場合は、"name"で指定することができます。
      "name"の指定を省略した場合は、ファイルに含まれている階層構造をすべて読み込みノードとして生成します。
      ノードに物理設定を行なう場合は、gppbind命令を使用してください。
      3Dモデルデータの接触判定は、全体を包む球(バウンディング球)が使用されます。

      生成されたオブジェクト(ノード)の描画はgpdraw命令によりまとめて行なわれます。

      例:
      gpload id_model,"res/duck"		; モデル読み込み

      上の例では、resフォルダ内にあるduck.gpbファイルを読み込みます。
      その際に、マテリアル情報が書かれているduck.materialファイルが参照されます。
      さらに、テクスチャが必要な場合は、同じフォルダ内の画像ファイルも読み込まれます。

      gpload命令で読み込むためのファイル(.gpb形式)は、gameplay3Dで標準的に使用されているデータ形式です。
      HGIMG4では、.gpb形式を生成するためのGPBコンバーター(gpbconv.exe)を用意しています。
      詳しくは、HGIMG4マニュアルを参照してください。
    </Setting>
  </command>
  <command>
    <Name>gpplate</Name>
    <Title>板ノードを生成</Title>
    <Format>
      var,sizex,sizey,color,matobj
      var        : 生成されたオブジェクトIDが代入される変数名
      sizex(1)   : 生成されるXサイズ
      sizey(1)   : 生成されるYサイズ
      color(-1)  : マテリアルカラー(24bitRGB値)
      matobj(-1) : マテリアルID
    </Format>
    <Setting>
      垂直に立った1枚の板(四角形)を3Dモデルデータとしてノードを生成します。
      varで指定された変数に、生成されたオブジェクトのIDが代入されます。
      生成されたノードは3D空間の中で自由に操作することが可能になります。
      モデルのX,Yサイズをsizex,sizeyパラメーターで指定することができます。
      colorパラメーターでモデルの色(マテリアルカラー)を24bitRGB値(0xRRGGBBで示される値)により指定します。
      colorパラメーターが省略された場合は、白色(0xffffff)が使用されます。
      matobjパラメーターで、マテリアルIDを指定することができます。
      gpcolormat命令などにより、ユーザーが生成したマテリアルを使用する場合は指定してください。
      matobjパラメーターが省略された場合は、標準のマテリアルが使用されます。

      生成されたオブジェクト(ノード)の描画はgpdraw命令によりまとめて行なわれます。

      ノードに物理設定を行なう場合は、gppbind命令を使用してください。
      ノードの接触判定は、もとのモデルと同じ形状が使用されます。
    </Setting>
  </command>
  <command>
    <Name>gpfloor</Name>
    <Title>床ノードを生成</Title>
    <Format>
      var,sizex,sizey,color,matobj
      var     : 生成されたオブジェクトIDが代入される変数名
    </Format>
    <Setting>
      1枚の床(四角形)を3Dモデルデータとしてノードを生成します。
      varで指定された変数に、生成されたオブジェクトのIDが代入されます。
      生成されたノードは3D空間の中で自由に操作することが可能になります。
      モデルのX,Yサイズをsizex,sizeyパラメーターで指定することができます。
      colorパラメーターでモデルの色(マテリアルカラー)を24bitRGB値(0xRRGGBBで示される値)により指定します。
      colorパラメーターが省略された場合は、白色(0xffffff)が使用されます。
      matobjパラメーターで、マテリアルIDを指定することができます。
      gpcolormat命令などにより、ユーザーが生成したマテリアルを使用する場合は指定してください。
      matobjパラメーターが省略された場合は、標準のマテリアルが使用されます。

      生成されたオブジェクト(ノード)の描画はgpdraw命令によりまとめて行なわれます。

      ノードに物理設定を行なう場合は、gppbind命令を使用してください。
      (床モデルは標準で、同じ場所に固定された物理特性が設定されます)
      ノードの接触判定は、もとのモデルと同じ形状が使用されます。
    </Setting>
  </command>
  <command>
    <Name>gpbox</Name>
    <Title>箱ノードを生成</Title>
    <Format>
      var,size,color,matobj
      var     : 生成されたオブジェクトIDが代入される変数名
    </Format>
    <Setting>
      指定サイズの立方体を3Dモデルデータとしてノードを生成します。
      varで指定された変数に、生成されたオブジェクトのIDが代入されます。
      生成されたノードは3D空間の中で自由に操作することが可能になります。
      モデルのX,Yサイズをsizex,sizeyパラメーターで指定することができます。
      colorパラメーターでモデルの色(マテリアルカラー)を24bitRGB値(0xRRGGBBで示される値)により指定します。
      colorパラメーターが省略された場合は、白色(0xffffff)が使用されます。
      matobjパラメーターで、マテリアルIDを指定することができます。
      gpcolormat命令などにより、ユーザーが生成したマテリアルを使用する場合は指定してください。
      matobjパラメーターが省略された場合は、標準のマテリアルが使用されます。

      生成されたオブジェクト(ノード)の描画はgpdraw命令によりまとめて行なわれます。

      ノードに物理設定を行なう場合は、gppbind命令を使用してください。
      ノードの接触判定は、もとのモデルと同じ形状が使用されます。
    </Setting>
  </command>
  <command>
    <Name>gpspr</Name>
    <Title>2Dスプライトノード生成</Title>
    <Format>
      var,bufid,celid,gmode
      var     : 生成されたオブジェクトIDが代入される変数名
    </Format>
    <Setting>
      2Dスプライトを表示するためのノードははを生成します。
      varで指定された変数に、生成されたオブジェクトのIDが代入されます。
      生成されたノードは2Dスクリーンの中で自由に操作することが可能になります。
      bufidパラメーターで表示元の画像が読み込まれているバッファIDを、celidパラメーターで表示するセルIDを指定します。
      また、gmodeパラメーターでgcopy命令で指定するものと同様のコピーモードを指定します。

      gmode値  |  内容
      ---------------------------------------------------
      0,1      アルファチャンネル無効
      2        アルファチャンネル有効
      5        色加算・アルファチャンネル有効

      生成されたオブジェクト(ノード)の描画はgpdraw命令によりまとめて行なわれます。

      ; スプライト1個あたりの描画
      gmode [gmode設定値]
      pos [ノードX座標],[ノードY座標]
      celput [バッファID], [セルID], [ノードXスケール], [ノードYスケール], [ノードZ回転]

      つまり、2Dスプライトノードは上のような処理をあらかじめ登録した設定をまとめて行なう機能と考えることができます。
      また、getcoli命令による2Dスプライトノード同士の接触判定を手軽に行なうことが可能です。
    </Setting>
  </command>
  <command>
    <Name>gplight</Name>
    <Title>ライトノードを設定</Title>
    <Format>
      id,opt,range,inner,outer
      id(0)     : オブジェクトのID
      opt(0)    : ライト生成オプション
      range(1)  : 影響範囲パラメーター
      inner(0.5): 内側の減衰パラメーター
      outer(1)  : 外側の減衰パラメーター
    </Format>
    <Setting>
      生成済みのノードにライトとしての機能を追加します。
      idパラメーターで、ノードのオブジェクトIDを指定します。
      optパラメーターでライト生成オプション値を指定することができます。

      opt値               |  内容
      --------------------------------------------------------------
      GPOBJ_LGTOPT_NORMAL    平行光源(ディレクショナルライト)
      GPOBJ_LGTOPT_POINT     点光源(ポイントライト)
      GPOBJ_LGTOPT_SPOT      スポットライト

      rangeパラメーターは、点光源及びスポットライトの影響範囲に関する設定を行ないます。
      また、inner,outerパラメーターは、スポットライトの減衰効果に関する設定を行ないます。
      現在のバージョンでは平行光源のみサポートされています。

      例:
      gpnull id_alight			; ヌルノードを生成する
      gplight id_alight, GPOBJ_LGTOPT_NORMAL	; ライトとして登録する
      gpuselight id_alight			; デフォルトのライトに設定

      シーン内に配置されたライトは、gpuselight命令により切り替えてからマテリアルを生成することで反映されます。
    </Setting>
  </command>
  <command>
    <Name>gpcamera</Name>
    <Title>カメラノードを設定</Title>
    <Format>
      id,fov,aspect,near,far
      id(0)      : オブジェクトのID
      fov(45)    : 視野(FOV)パラメーター
      aspect(1.5): アスペクト比
      near(0.5)  : ニアクリップZ値
      far(768)   : ファークリップZ値
    </Format>
    <Setting>
      生成済みのノードにカメラとしての機能を追加します。
      idパラメーターで、ノードのオブジェクトIDを指定します。
      fovパラメーターで視野(FOV)を設定します。45を指定した場合は、45度の視野となります。
      aspectパラメーターでアスペクト比(縦横比)を指定します。
      また、near,farパラメーターにより近くと遠くのZ座標(クリッピングに使われるZ座標)を指定することができます。

      例:
      gpnull id_camera			; ヌルノードを生成する
      gpcamera id_camera, 45, 1.5, 0.5, 768	; カメラとして設定する
      gpusecamera id_camera			; 使用するカメラを選択する
      setpos id_camera, 0,20,20		; カメラ位置を設定する

      シーン内に配置されたカメラは、gpusecamera命令により切り替えることができます。
    </Setting>
  </command>
  <command>
    <Name>gplookat</Name>
    <Title>指定座標に向けてノードを回転</Title>
    <Format>
      objid,x,y,z
      objid(0)  : オブジェクトID
      x(0)      : 目標となるX座標
      y(0)      : 目標となるY座標
      z(0)      : 目標となるZ座標
    </Format>
    <Setting>
      3Dノードを、指定した座標に向けて回転させます。
      カメラに適用した場合は、指定座標を注視する角度に設定されます。
    </Setting>
  </command>
  <command>
    <Name>gppbind</Name>
    <Title>ノードに標準的な物理特性を設定</Title>
    <Format>
      objid,mass,friction
      objid(0)      : オブジェクトID
      mass(1)       : 重さ
      friction(0.5) : 摩擦係数
    </Format>
    <Setting>
      ノードオブジェクトに対して、基本的な物理設定を行ないます。
      massパラメーターは物体の重さ。frictionパラメーターは摩擦係数です。値を省略した場合は、デフォルト値が使用されます。
      重さ(mass)を0にすることで静的剛体(衝突はするが、動かない)として設定されます。
      それ以外の場合は、物理法則に従って床のある場所まで落下します。

      ※物理挙動を設定する場合は、必ず床(地面)となる部分を作成しておいてください。
      gpfloor命令によって生成された床に標準的な物理特性を設定することで、固定された床面を生成することができます。
      床が存在しなかった場合、物体は永遠に落下を続けることになります。

      物理設定を行なったノードオブジェクトは、それ以降自立して動作するようになり、setposなどの座標変更は無効となります。
      物体に力を加えたい場合は、gppapply命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>getwork2</Name>
    <Title>ノードワーク値2を取得</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つwork2パラメーターを取得します。
      (x,y,z)は、実数型の変数として設定されます。
      命令の最後に「i」を付加することで、整数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>getwork2i</Name>
    <Title>ノードワーク値2を取得(整数値)</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 取得する変数
    </Format>
    <Setting>
      オブジェクトの持つwork2パラメーターを取得します。
      (x,y,z)は、整数型の変数として設定されます。
      getwork2命令を使用することで、実数値として値を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>selquat</Name>
    <Title>オブジェク回転情報をMOC情報に設定</Title>
    <Format>
      id
      id(0) : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをquat(クォータニオン回転情報)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>selwork2</Name>
    <Title>オブジェクトワーク2をMOC情報に設定</Title>
    <Format>
      id
      id(0) : オブジェクトID
    </Format>
    <Setting>
      MOC設定命令の対象となるMOCグループをwork2(ワーク2)に設定します
      idは、オブジェクトIDとなります。
    </Setting>
  </command>
  <command>
    <Name>setwork2</Name>
    <Title>work2グループ情報を設定</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      work2グループ(ワーク2値)に(x,y,z)で指定された値を設定します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>addwork2</Name>
    <Title>work2グループ情報を加算</Title>
    <Format>
      id,x,y,z
      id      : オブジェクトID
      (x,y,z) : 設定する値 (デフォルト=0)
    </Format>
    <Setting>
      オブジェクトの持つパラメーターを設定します。
      work2グループ(ワーク2値)に(x,y,z)で指定された値を加算します。
      (x,y,z)には、実数または整数値を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>gpcnvaxis</Name>
    <Title>3D座標の変換を行なう</Title>
    <Format>
      var_x,var_y,var_z,x,y,z,mode
      var_x   : X値が代入される変数
      var_y   : Y値が代入される変数
      var_z   : Z値が代入される変数
      x(0.0)  : 変換元のX値
      y(0.0)  : 変換元のY値
      z(0.0)  : 変換元のZ値
      mode(0) : 変換モード
    </Format>
    <Setting>(今後のバージョンでサポートするための予約キーワードです。機能は現在まだ実装されていません。)</Setting>
  </command>
  <command>
    <Name>gppset</Name>
    <Title>ノードの物理パラメーターを設定</Title>
    <Format>
      objid,prmid,x,y,z
      objid(0)  : オブジェクトID
      prmid(0)  : パラメーターID
      x(0.0)    : 設定パラメーターX値
      y(0.0)    : 設定パラメーターY値
      z(0.0)    : 設定パラメーターZ値
    </Format>
    <Setting>
      objidで指定されたノードの詳細な物理パラメーターを設定します。
      prmidパラメーターで、設定する項目を指定し、X,Y,Zに指定された値が、それぞれの項目に対応した値として適用されます。

      マクロ名                          内容
      ----------------------------------------------------------------------------
      GPPSET_ENABLE                     X=物理挙動のON/OFF(0=無効)
      GPPSET_FRICTION                   X=摩擦係数, Y=弾力設定
      GPPSET_DAMPING                    X=linear反発(0〜1.0), Y=angular反発(0〜1.0)
      GPPSET_KINEMATIC                  X=Kinematic設定のON/OFF(0=無効)
      GPPSET_ANISOTROPIC_FRICTION       X,Y,Z=異方性の摩擦
      GPPSET_GRAVITY                    X,Y,Z=重力
      GPPSET_LINEAR_FACTOR              X,Y,Z=ベクトルに沿った移動の設定
      GPPSET_ANGULAR_FACTOR             X,Y,Z=ベクトルに沿った回転の設定
      GPPSET_ANGULAR_VELOCITY           X,Y,Z=回転ベロシティー
      GPPSET_LINEAR_VELOCITY            X,Y,Z=リニアベロシティー

      必ずgppbind命令で基本的な物理特性を設定した後で詳細設定を行なうようにしてください。
      設定値が正しくない場合は、エラーが発生します。
    </Setting>
  </command>
  <command>
    <Name>gpobjpool</Name>
    <Title>オブジェクトID生成の設定</Title>
    <Format>
      start,num
      start(0) : 割り当て開始番号
      num(-1)  : 最大割り当て数
    </Format>
    <Setting>
      オブジェクトIDの割り当て方法を変更します。
      オブジェクトIDは、あらかじめ決められた最大数の中で、使用されていないID番号が割り当てられます。
      オブジェクト最大数は、デフォルトで1024個となっており、sysreq命令によって拡張することが可能です。

      例:
      setreq SYSREQ_MAXOBJ,4096	; オブジェクト最大数を4096に拡張する

      gpobjpool命令は、ID番号の割り当て範囲を任意に変更することができます。
      startパラメーターで指定された番号を割り当て開始番号に設定します。
      numパラメーターで指定された番号を割り当てられる最大数に設定します。
      numパラメーターがマイナス値か省略されていた場合は、割り当て開始番号から最大限取れる範囲が設定されます。

      例:
      gpobjpool 100,50	; オブジェクトID生成の設定変更

      上の例では、ID番号100〜150のみを割り当て対象に変更します。
      これ以降のオブジェクト生成命令(gpboxやgpnullなど)では、指定された範囲内のオブジェクトIDのみが割り当てられます。
      オブジェクト全体の中で特定の個数までしか生成されないように制限したい場合や、
      表示順序をある程度コントロールしたい場合に利用できます。
      gpobjpool命令によって、あらかじめ設定されたオブジェクト最大数を拡張することはできません。
      必ず最大数の範囲内で設定を行なうよう注意してください。
    </Setting>
  </command>
  <command>
    <Name>gppapply</Name>
    <Title>ノードに物理的な力を適用する</Title>
    <Format>
      objid,action,x,y,z
      objid(0)  : オブジェクトID
      action(0) : 力の種類(タイプ)
      x(0.0)    : 設定パラメーターX値
      y(0.0)    : 設定パラメーターY値
      z(0.0)    : 設定パラメーターZ値
    </Format>
    <Setting>
      ノードに対して(x,y,z)で指定したベクトルの物理的な力を適用します。
      actionパラメーターで設定できるタイプは、以下の通りです。

      マクロ名                     内容
      ----------------------------------------------------------------------------
      GPPAPPLY_FORCE               移動しようとする力を加算する
      GPPAPPLY_IMPULSE             瞬間的な衝撃を与える
      GPPAPPLY_TORQUE              トルク(ねじる)力を与える
      GPPAPPLY_TORQUE_IMPULSE      トルク+衝撃を与える

      必ずgppbind命令で基本的な物理特性を設定した後で力を適用するようにしてください。
      設定値が正しくない場合は、エラーが発生します。
    </Setting>
  </command>
  <command>
    <Name>gpmatprm1</Name>
    <Title>マテリアルのパラメーター設定(2)</Title>
    <Format>
      id,"name",value
      id(0)      : マテリアルID
      "name"     : パラメーター名
      value(0.0) : Xの設定値(実数値)
    </Format>
    <Setting>
      生成されたマテリアルのシェーダーパラメーターを設定します。
      gpmatprm命令と基本的に同じ機能です。
      gpmatprm1命令は、1項目のみの実数パラメーターを指定します。
    </Setting>
  </command>
  <command>
    <Name>gpmatprm4</Name>
    <Title>マテリアルのパラメーター設定(3)</Title>
    <Format>
      id,"name",x,y,z,w
      id(0)  : マテリアルID
      "name" : パラメーター名
      x(0.0) : Xの設定値(実数値)
      y(0.0) : Yの設定値(実数値)
      z(0.0) : Zの設定値(実数値)
      w(0.0) : Wの設定値(実数値)
    </Format>
    <Setting>
      生成されたマテリアルのシェーダーパラメーターを設定します。
      gpmatprm命令と基本的に同じ機能です。
      gpmatprm4命令は、4項目(x,y,z,w)の実数パラメーターを指定します。
    </Setting>
  </command>
  <command>
    <Name>setalpha</Name>
    <Title>オブジェクトの透明度(α値)設定</Title>
    <Format>
      objid,value
      objid(0)   : オブジェクトID
      value(255) : 設定する値(整数値)(0〜255)
    </Format>
    <Setting>
      オブジェクトの透明度(α値)を設定します。
      valueパラメーターで指定された値を、objidパラメーターのオブジェクトに設定します。
      valueパラメーターで指定する値は、透明度を示す0〜255の整数値(α値)となります。
      0は完全な透明、255は不透明が適用されます。
      α値が255以外(半透明)の状態となったオブジェクトは、描画順序が前面に変更されます。
      (OBJ_LATEのモードが指定されたのと同じ状態)
    </Setting>
  </command>
  <command>
    <Name>hsed_exist</Name>
    <Title>HSPスクリプトエディタの起動状態を取得</Title>
    <Format></Format>
    <Setting>
      HSPスクリプトエディタが起動しているかチェックします。
      起動していれば1が、起動していなければ0がシステム変数statに代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_capture</Name>
    <Title>HSPスクリプトエディタのAPIウィンドウを捕捉</Title>
    <Format></Format>
    <Setting>
      hsedsdkモジュール内の変数hIFにHSPスクリプトエディタのAPIウィンドウのハンドルを代入します。

      取得に成功した場合はシステム変数statに0が代入されます。

      この命令はhsedsdk.as内で利用される命令であり、通常は利用する必要はありません。
    </Setting>
  </command>
  <command>
    <Name>hsed_gettext</Name>
    <Title>編集中のテキストを取得</Title>
    <Format>
      p1, p2
      p1 : テキストを代入する変数
      p2 : 取得したいFootyのID
    </Format>
    <Setting>
      HSPスクリプトエディタで編集しているテキストを取得し、p1に代入します。

      取得に成功した場合はシステム変数statに0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_sendstr</Name>
    <Title>文字列を貼り付け</Title>
    <Format>
      p1
      p1 : スクリプトに挿入する文字列を格納した文字列型変数
    </Format>
    <Setting>編集中のテキストにp1に格納した文字列を貼り付けます。</Setting>
  </command>
  <command>
    <Name>hsed_cancopy</Name>
    <Title>コピーの可否を取得</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数
      p2 : FootyのID
    </Format>
    <Setting>
      コピーの可否を取得します。
      指定されたFootyからクリップボードにコピーすることができる場合はp1に1が返ります。

      実際にコピーや切り取りを行う場合はhsed_copyまたはhsed_cutを利用してください。
    </Setting>
  </command>
  <command>
    <Name>hsed_cut</Name>
    <Title>指定したFootyから文字列を切り取る</Title>
    <Format>
      p1
      p1 : 文字列を切り取るFootyのID
    </Format>
    <Setting>
      指定したFootyへ文字列をクリップボードに切り取るよう要請します。
      切り取りが行えるかどうかはhsed_cancopyで調べてください。
    </Setting>
  </command>
  <command>
    <Name>hsed_redo</Name>
    <Title>リドゥを行う</Title>
    <Format>
      p1
      p1 : リドゥを行うFootyのID
    </Format>
    <Setting>
      指定したFootyに対してリドゥを行うように要請します。
      リドゥが行えるかどうかはhsed_canredoで調べてください。
    </Setting>
  </command>
  <command>
    <Name>hsed_undo</Name>
    <Title>アンドゥを行う</Title>
    <Format>
      p1
      p1 : アンドゥを行うFootyのID
    </Format>
    <Setting>
      指定したFootyに対してアンドゥを行うように要請します。
      アンドゥが行えるかどうかはhsed_canundoで調べてください。
    </Setting>
  </command>
  <command>
    <Name>hsed_indent</Name>
    <Title>インデントを行う</Title>
    <Format>
      p1
      p1 : インデントを行うFootyのID
    </Format>
    <Setting>
      Footyに対してインデントを行うように要請します。
      インデントは選択範囲に対して行われます。
    </Setting>
  </command>
  <command>
    <Name>hsed_unindent</Name>
    <Title>アンインデントを行う</Title>
    <Format>
      p1
      p1 : アンインデントを行うFootyのID
    </Format>
    <Setting>
      Footyに対してアンインデントを行うように要請します。
      アンインデントは選択範囲に対して行われます。
    </Setting>
  </command>
  <command>
    <Name>hsed_uninitduppipe</Name>
    <Title>パイプハンドルの解放</Title>
    <Format></Format>
    <Setting></Setting>
  </command>
  <command>
    <Name>hsed_initduppipe</Name>
    <Title>パイプハンドルの作成</Title>
    <Format>
      p1
      p1 : 文字列の長さ
    </Format>
    <Setting></Setting>
  </command>
  <command>
    <Name>hsed_getmajorver</Name>
    <Title>メジャーバージョンを抽出</Title>
    <Format>
      (p1)
      p1 : バージョンを表す整数値
    </Format>
    <Setting>
      p1で指定されたバージョンからメジャー バージョンのみを抽出します。
      ここで指定できる値は、hsed_getverにHGV_PUBLICVERもしくはHGV_PRIVATEVERを指定して取得したバージョンのみです。
    </Setting>
  </command>
  <command>
    <Name>hsed_getminorver</Name>
    <Title>マイナーバージョンを抽出</Title>
    <Format>
      (p1)
      p1 : バージョンを表す整数値
    </Format>
    <Setting>
      p1で指定されたバージョンからマイナー バージョンのみを抽出します。
      ここで指定できる値は、hsed_getverにHGV_PUBLICVERもしくはHGV_PRIVATEVERを指定して取得したバージョンのみです。
    </Setting>
  </command>
  <command>
    <Name>hsed_getbetaver</Name>
    <Title>ベータバージョンを抽出</Title>
    <Format>
      (p1)
      p1 : バージョンを表す整数値
    </Format>
    <Setting>
      p1で指定されたバージョンからベータ バージョンのみを抽出します。
      ここで指定できる値は、hsed_getverにHGV_PUBLICVERもしくはHGV_PRIVATEVERを指定して取得したバージョンのみです。
    </Setting>
  </command>
  <command>
    <Name>hsed_getver</Name>
    <Title>スクリプトエディタのバージョンを取得</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数
      p2 : バージョンの種類を指定するための整数値
    </Format>
    <Setting>
      p2で指定された種類のエディタのバージョンを取得し、p1に代入します。
      取得に失敗した場合は、原則としてp1に-1を代入します。ただし、p2にHGV_HSPCMPVERが指定されていた場合は、"Error"を代入します。

      statに代入される値は以下の通りです。
      0: 取得に成功
      1: エディタが見つからなかった
      2: パイプが作れなかった
      3: エディタが正しい値を返せなかった(p2が正しくない場合含む)

      p2に指定する値は以下の通りです。HGV_で始まる定数を用いても、括弧内の数字を用いても構いません。
    </Setting>
  </command>
  <command>
    <Name>hsed_getwnd</Name>
    <Title>スクリプトエディタの各種ハンドルを取得</Title>
    <Format>p1, p2, p3</Format>
    <Setting>
      p2で指定された種類のエディタのウィンドウ ハンドルを取得し、p1に代入します。
      p2でHGW_EDITを指定した場合は、p3でFootyのIDを指定する必要があります。
      取得に失敗した場合は、p1に0を代入します。

      statに代入される値は以下の通りです。
      0: 取得に成功
      1: エディタが見つからなかった
      2: エディタが正しい値を返せなかった(p2が正しくない場合含む)

      p2に指定する値は以下の通りです。HGW_で始まる定数を用いても、括弧内の数字を用いても構いません。
      HGW_MAIN(0): メイン ウィンドウ
      HGW_CLIENT(1): クライアント ウィンドウ
      HGW_TAB(2): タブ ウィンドウ
      HGW_EDIT(3): Footy ウィンドウ
      HGW_TOOLBAR(4): ツールバー
      HGW_STATUSBAR(5): ステータスバー
    </Setting>
  </command>
  <command>
    <Name>hsed_cnvverstr</Name>
    <Title>バージョンの数値を文字列に変換</Title>
    <Format>
      p1
      p1 : バージョンを表す整数値
    </Format>
    <Setting>
      p1で指定されたバージョンを文字列に変換し、refstrに代入します。"(メジャーバージョン).(マイナーバージョン)"の形式です。ただし、ベータバージョンの場合は末尾に"b(ベータバージョン)"が加えられます。
      ここで指定できる値は、hsed_getverにHGV_PUBLICVERもしくはHGV_PRIVATEVERを指定して取得したバージョンのみです。
    </Setting>
  </command>
  <command>
    <Name>hsed_selectall</Name>
    <Title>テキストをすべて選択</Title>
    <Format>
      p1
      p1 : テキストを選択するFootyのID
    </Format>
    <Setting>Footyに対してテキストをすべて選択するように要請します。</Setting>
  </command>
  <command>
    <Name>hsed_gettextlength</Name>
    <Title>テキストの文字列長を取得</Title>
    <Format>
      p1, p2
      p1 : 文字列長を代入する変数
      p2 : 文字列長を取得するFootyのID
    </Format>
    <Setting>テキストの文字列長を取得し、p1へ代入します。</Setting>
  </command>
  <command>
    <Name>hsed_getlines</Name>
    <Title>テキストの行数を取得</Title>
    <Format>
      p1, p2
      p1 : 行数を代入する変数
      p2 : 行数を取得するFootyのID
    </Format>
    <Setting>テキストの行数をp1に代入します。コメント行や空行も1行としてカウントされます。</Setting>
  </command>
  <command>
    <Name>hsed_getlinelength</Name>
    <Title>行の文字列長を取得</Title>
    <Format>
      p1, p2, p3
      p1 : 文字列長を代入する変数
      p2 : 文字列長を取得するFootyのID
      p3 : 文字列長を取得する行の番号（1〜）
    </Format>
    <Setting>テキストのp3行目の文字列長を取得し、p1へ代入します。</Setting>
  </command>
  <command>
    <Name>hsed_getlinecode</Name>
    <Title>改行コードを取得</Title>
    <Format>p1, p2</Format>
    <Setting></Setting>
  </command>
  <command>
    <Name>hsed_copy</Name>
    <Title>指定したFootyから文字列をコピー</Title>
    <Format>
      p1
      p1 : 文字列をコピーするFootyのID
    </Format>
    <Setting>
      指定したFootyへ文字列をクリップボードにコピーするよう要請します。
      コピーが行えるかどうかはhsed_cancopyで調べてください。
    </Setting>
  </command>
  <command>
    <Name>hsed_paste</Name>
    <Title>指定したFootyへ文字列を貼り付け</Title>
    <Format>
      p1
      p1 : 文字列を貼り付けるFootyのID
    </Format>
    <Setting>
      指定したFootyへ文字列をクリップボードから貼り付けるよう要請します。
      貼り付けが行えるかどうかはhsed_canpasteで調べてください。
    </Setting>
  </command>
  <command>
    <Name>hsed_canpaste</Name>
    <Title>貼り付けの可否を取得</Title>
    <Format>
      p1
      p1 : 結果を格納する変数
    </Format>
    <Setting>
      貼り付けの可否を取得します。
      クリップボードから貼り付けすることができる場合はp1に1が返ります。

      実際に貼り付けを行う場合はhsed_pasteを利用してください。
    </Setting>
  </command>
  <command>
    <Name>hsed_canundo</Name>
    <Title>アンドゥの可否を取得</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数
      p2 : FootyのID
    </Format>
    <Setting>
      指定したFootyのアンドゥの可否を取得します。
      アンドゥが可能ならばp1に1が返ります。

      実際にアンドゥを行う場合はhsed_undoを利用してください。
    </Setting>
  </command>
  <command>
    <Name>hsed_canredo</Name>
    <Title>リドゥの可否を取得</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数
      p2 : FootyのID
    </Format>
    <Setting>
      指定したFootyのリドゥの可否を取得します。
      リドゥが可能ならばp1に1が返ります。

      実際にリドゥを行う場合はhsed_redoを利用してください。
    </Setting>
  </command>
  <command>
    <Name>hsed_getmodify</Name>
    <Title>変更フラグを取得</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数
      p2 : FootyのID
    </Format>
    <Setting>
      指定したFootyの変更フラグを取得します。
      変更されていればp1には1が返ります。
    </Setting>
  </command>
  <command>
    <Name>hsed_settext</Name>
    <Title>テキストを変更</Title>
    <Format>
      p1, p2
      p1 : 変更したいFootyのID
      p2 : 変更するテキスト
    </Format>
    <Setting>
      HSPスクリプトエディタで編集中のテキストをp2に変更します。

      変更に成功した場合はシステム変数statに0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_getfootyid</Name>
    <Title>タブのIDからFootyのIDを取得</Title>
    <Format>
      p1, p2
      p1 : FootyのIDを代入する変数
      p2 : タブのID
    </Format>
    <Setting></Setting>
  </command>
  <command>
    <Name>hsed_gettabid</Name>
    <Title>FootyのIDからタブのIDを取得</Title>
    <Format>
      p1, p2
      p1 : タブのIDを代入する変数
      p2 : FootyのID
    </Format>
    <Setting></Setting>
  </command>
  <command>
    <Name>hsed_gettabcount</Name>
    <Title>タブ数の取得</Title>
    <Format>
      p1
      p1 : タブ数を代入する変数
    </Format>
    <Setting>
      HSPスクリプトエディタのエディタ部上部に表示されているタブ数を取得してp1に代入します。

      取得に成功した場合はシステム変数statに0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_getactfootyid</Name>
    <Title>アクティブなFootyのIDの取得</Title>
    <Format>
      p1
      p1 : FootyのIDを代入する変数
    </Format>
    <Setting>
      HSPスクリプトエディタのアクティブなタブに表示されているFootyのIDを取得してp1に代入します。

      取得に成功した場合はシステム変数statに0が代入されます。

      取得に失敗した場合はシステム変数statに1が代入され、p1に-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_getacttabid</Name>
    <Title>アクティブなタブのIDの取得</Title>
    <Format>
      p1
      p1 : タブのIDを代入する変数
    </Format>
    <Setting>
      HSPスクリプトエディタのアクティブなタブのIDを取得してp1に代入します。

      取得に成功した場合はシステム変数statに0が代入されます。

      取得に失敗した場合はシステム変数statに1が代入され、p1に-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>hsed_getpath</Name>
    <Title>タブIDからファイルパスを取得</Title>
    <Format>
      p1, p2
      p1 : ファイルパスを代入する変数
      p2 : タブのID
    </Format>
    <Setting>
      HSPスクリプトエディタで開いているファイルのパス名を取得し、p1に代入します。

      取得に成功した場合はシステム変数statに0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>setreq</Name>
    <Title>システムリクエスト設定</Title>
    <Format>
      type,val
      type(0) : 設定タイプ(SYSREQ_???)
      val(0)  : 設定する値
    </Format>
    <Setting>
      HSP3Dishランタイムに対して様々なシステム設定を行ないます。
      設定タイプ名で指定できるのは以下のシンボルです。

      設定タイプ名      読み書き(*)   内容
      ------------------------------------------------------------------------
      SYSREQ_CLSMODE        RW        背景のクリアフラグ
      SYSREQ_CLSCOLOR       RW        背景クリア色
      SYSREQ_TIMER          R         ミリ秒単位のタイマー値
      SYSREQ_PLATFORM       R         HSP3Dishを実行しているプラットフォーム

      (*)項目ごとに、読み(R)書き(W)の可否が異なります


      ・SYSREQ_CLSMODE、SYSREQ_CLSCOLOR

      redraw 0による描画開始時に画面をクリアするかどうかを設定します。 SYSREQ_CLSMODEに1を設定した場合はクリア、0の場合はクリアを行ないません。 スクリプト内で画面のクリアを行なっている場合は、システム側で背景クリアをしない方が 処理速度の向上につながります。 SYSREQ_CLSCOLORでクリアする際の色コードを設定することができます。 色コードは、RGB24bit($rrggbb)を1つにした数値で設定します。

      ・SYSREQ_TIMER

      ミリ秒単位のタイマー値を返します。 プラットフォームごとに返される値は異なりますが、1ミリ秒につき1ずつ値が加算されていきます。

      ・SYSREQ_PLATFORM

      以下のHSP3Dishプラットフォーム値を返します。

      マクロ名            値  内容
      -------------------------------------------
      PLATFORM_WINDOWS    0   Windows版
      PLATFORM_IOS        1   iOS版
      PLATFORM_ANDROID    2   android版
    </Setting>
  </command>
  <command>
    <Name>getreq</Name>
    <Title>システムリクエスト取得</Title>
    <Format>
      var,type
      var  : 結果が代入される変数名
      type : 設定タイプ(SYSREQ_???)
    </Format>
    <Setting>
      HSP3Dishランタイムが保持するシステム設定を取得して変数に代入します。
      設定タイプ名で指定できる名称は、setreq命令と同様です。
    </Setting>
  </command>
  <command>
    <Name>gfilter</Name>
    <Title>テクスチャ補間の設定</Title>
    <Format>
      type
      type : 設定タイプ(FILTER_???)
    </Format>
    <Setting>
      HSP3Dishランタイムが描画を行なう際の、テクスチャ補間(フィルタリング)の設定を行ないます。
      設定タイプ名で指定できる名称は、以下の通りです。

      マクロ名        値      内容
      -------------------------------------------
      FILTER_NONE     0       補間なし(NEAREST)
      FILTER_LINEAR   1       直線補間(LINEAR)
      FILTER_LINEAR2  2       エリア補間(高度な補間処理)

      フィルタリングの設定により、画像の拡大・縮小時のドット補間方法を 選ぶことができます。FILTER_NONEを指定することで、補間なし(ニアレスト) の状態になります。FILTER_LINEARは、直線(リニア)補間、FILTER_LINEAR2は より高度な補間方法(バイリニアなど)を選択します。 gfilter命令の設定は、以降のすべての描画命令に適用されます。 また、「redraw 0」による画面クリア時には、フィルタリング設定は FILTER_NONEにリセットされます。
    </Setting>
  </command>
  <command>
    <Name>mtlist</Name>
    <Title>ポイントIDリスト取得</Title>
    <Format>
      var
      var  : 結果が代入される変数名
    </Format>
    <Setting>
      現在タッチされている情報を持つポイントIDリストを取得します。
      ポイントIDリストは、複数のポイントIDを返すもので、マルチタッチによる複数のポイントを含む情報になります。
      mtlist命令が実行されると、その時点で押されている(触れている)すべてのポイントID(整数値)を、varで指定した変数に配列として代入します。
      たとえば、ID0とID2、ID3の３つの情報があれば、var(0)に0、var(1)に2、var(2)に3という値が代入されることになります。
      代入されたポイントIDの数は、システム変数statに返されます。
      この命令で得られたポイントIDを使用して、mtinfo命令で詳細なタッチ情報を取得することができます。
      マルチタッチの情報を取得するためには、それぞれのデバイスでマルチタッチの設定を有効にする必要があります。
      また、Windows上では、Windows7以降のマルチタッチに対応したデバイスが必要になります。
    </Setting>
  </command>
  <command>
    <Name>mtinfo</Name>
    <Title>タッチ情報取得</Title>
    <Format>
      var,id
      var  : 結果が代入される変数名
      id(0): ポイントID
    </Format>
    <Setting>
      指定されたポイントIDに関連付けられたタッチ情報を取得します。
      タッチ情報は、varで指定した変数に配列として代入されます。

      要素値  内容
      -------------------------------------------
      0     タッチ状態(1=ON/0=OFF)
      1     タッチされたX座標
      2     タッチされたY座標
      3     タッチ識別用ID

      つまり、var(1)にはタッチされたX座標が、var(0)にはタッチの状態(1ならば押されている)が代入されます。
      varで指定された変数は必ず整数型の配列変数として初期化されます。
      var(3)のタッチ識別用IDは、他のタッチと識別するための整数値です。この値は、デバイスごとに異なります。
    </Setting>
  </command>
  <command>
    <Name>devinfo</Name>
    <Title>デバイス情報文字列取得</Title>
    <Format>
      var,"name"
      var    : 結果が代入される変数名
      "name" : デバイス情報名
    </Format>
    <Setting>
      特定のOS、及びデバイスに依存した情報を取得します。
      文字列"name"で示された情報を、varで指定した変数に代入します。(代入される情報は文字列となります。)
      実行後に、正しく情報が取得された場合は、システム変数statが0以上になります。
      情報が存在しないか、エラーが発生した場合はシステム変数statがマイナスの値となります。
    </Setting>
  </command>
  <command>
    <Name>devinfoi</Name>
    <Title>デバイス情報値取得</Title>
    <Format>
      var,"name"
      var    : 結果が代入される変数名
      "name" : デバイス情報名
    </Format>
    <Setting>
      特定のOS、及びデバイスに依存した情報を取得します。
      文字列"name"で示された情報を、varで指定した変数に代入します。(代入される情報は整数型の配列となります。)
      実行後に、正しく情報が取得された場合は、システム変数statが0以上になります。
      情報が存在しないか、エラーが発生した場合はシステム変数statがマイナスの値となります。
    </Setting>
  </command>
  <command>
    <Name>devprm</Name>
    <Title>デバイス制御用のパラメーター設定</Title>
    <Format>
      "name","value"
      "name" : パラメーター名を示す文字列
      "value" : 設定する文字列
    </Format>
    <Setting>
      devcontrol命令によりデバイス制御する際のパラメーター(付加情報)を設定します。
      実行後に、正しく実行が行なわれた場合は、システム変数statが0以上の値になります。
      パラメーターが存在しないか、エラーが発生した場合はシステム変数statがマイナスの値となります。
    </Setting>
  </command>
  <command>
    <Name>devcontrol</Name>
    <Title>デバイス制御を実行する</Title>
    <Format>
      "command",p1,p2,p3
      "command" : コマンド名を示す文字列
      p1(0)     : 制御パラメーター1
      p2(0)     : 制御パラメーター2
      p3(0)     : 制御パラメーター3
    </Format>
    <Setting>
      特定のOS、及びデバイスに依存したデバイス制御を実行します。
      実行後に、正しく実行が行なわれた場合は、システム変数statが0以上の値になります。
      パラメーターが存在しないか、エラーが発生した場合はシステム変数statがマイナスの値となります。
    </Setting>
  </command>
  <command>
    <Name>mmvol</Name>
    <Title>音量の設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : メディアバッファID
      p2(0)     : ボリューム(音量)値(-1000〜0)
    </Format>
    <Setting>
      mmplay命令によって再生されるメディアの音量を設定します。
      ボリューム値は、0が最大の音量、-1000が無音状態となります。
      このパラメーターはデフォルトで0(最大)が設定されています。
      ※ボリューム値は、dmmvol命令と同様にマイナス値が大きいほど無音に近づきます。
      ただし、dmmvol命令は-10000〜0までのデシベル値であるのに対して、mmvol命令は-1000〜0までのリニアな変化
      (聴感上の音量)を行なう値であることに注意してください。
    </Setting>
  </command>
  <command>
    <Name>mmpan</Name>
    <Title>パンニングの設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : メディアバッファID
      p2(0)     : パンニング値(-1000〜1000)
    </Format>
    <Setting>
      mmplay命令によって再生されるメディアのパンニング(ステレオの左右バランス)を設定します。
      -1000が最も左の定位、1000が最も右の定位の値となります。(0が中央の定位となります)
      このパラメーターはデフォルトで0(中央)が設定されています。
      ※Windows上でのmp3ファイルによる音楽再生時は反映されません
      ※dmmpan命令とは値の分解能が異なるので注意してください
    </Setting>
  </command>
  <command>
    <Name>mmstat</Name>
    <Title>メディアの状態取得</Title>
    <Format>
      p1,p2,p3
      p1 : 状態が取得される変数
      p2(0) : メディアバッファID
      p3(0) : 取得モード
    </Format>
    <Setting>
      mmplay命令によって再生されるメディアの状態を取得して、p1の変数に代入します。
      p3で取得するモードを指定することができます。
      取得モードの値は、以下の通りです。

      モード値  内容
      ------------------------------------------------------
      0     設定フラグ値
      1     ボリューム値
      2     パンニング値
      3     再生レート(0=オリジナル)
      16    再生中フラグ(0=停止中/1=再生中)
    </Setting>
  </command>
  <command>
    <Name>setcls</Name>
    <Title>画面クリア設定</Title>
    <Format>
      mode,color,tex
      mode(0)  : 画面クリアのモード
      color(0) : 画面クリア色(24bitRGBコード)
    </Format>
    <Setting>
      redraw 0による画面初期化時に行なわれる画面クリアのための設定を行ないます。
      mode値の設定により、画面クリアを行なうためのモードを設定します。
      1を設定した場合はクリア、0の場合はクリアを行ないません。
      スクリプト内で画面のクリアを行なっている場合は、システム側で背景クリアをしない方が処理速度の向上につながります。

      モード値  内容
      ------------------------------------------------------
      0     画面クリアを行なわない
      1     画面クリアを行なう

      colorでクリアする際の色を設定することができます。色は、24bitRGBコード($rrggbb)の数値で設定します。
    </Setting>
  </command>
  <command>
    <Name>celputm</Name>
    <Title>複数のセルをまとめて描画</Title>
    <Format>
      vxpos,vypos,vcelid,bufid,count
      vxpos    : 表示X座標が格納された整数型配列変数名
      vypos    : 表示Y座標が格納された整数型配列変数名
      vcelid   : セルIDが格納された整数型配列変数名
      bufid(0) : セルが格納されているバッファID
      count(1) : 配列変数から取り出す項目数
    </Format>
    <Setting>
      整数型の配列変数に代入された座標、セルIDをもとにcelputと同様の表示を配列要素ごとに実行します。
      配列に保存された複数の項目について、一度に処理が行なわれるため効率化と高速化につながります。
      countで配列変数から取り出す項目の数を指定します。配列変数からは、要素0から順番に値が取り出されます。
      vxposにはX座標、vyposにはY座標、vcelidにはセルIDが代入されている必要があります。
      セルIDがマイナス値の場合は、描画は行なわれません。
      celputm命令の実行後、実際に表示されたセルの数がシステム変数statに代入されます。
    </Setting>
  </command>
  <command>
    <Name>hspini </Name>
    <Title>HSP3IMP.DLLの初期化</Title>
    <Format>
      mode,xsize,ysize,handle
      mode : 初期化モード($100=子ウィンドウとして初期化)
      bit0 = window非表示(ON/OFF)
      bit1 = カレントディレクトリ変更禁止(ON/OFF)

      xsize  : HSPの初期化ウィンドウサイズ(X)
      ysize  : HSPの初期化ウィンドウサイズ(Y)
      handle : 親のウィンドウハンドル(HWND)
    </Format>
    <Setting>
      HSP3IMP.DLLを初期化します。
      HSP3の初期化と、オブジェクトファイルの読み込みを行ないます。
      hspiniを実行する前に、hspprm命令によって各種設定を行なっておく必要があります。
    </Setting>
  </command>
  <command>
    <Name>hspbye</Name>
    <Title>初期化されたHSP3のインスタンスの破棄</Title>
    <Format></Format>
    <Setting>
      hspini命令によって初期化されたHSP3のインスタンスを破棄します。
      最後に必ず実行して、HSP3の終了処理を行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>hspexec</Name>
    <Title>HSP3のタスクの実行</Title>
    <Format></Format>
    <Setting>
      hspini命令によって初期化されたHSP3のタスクを実行します。
      hspexec命令は、実行したコードが終了するか、エラーが発生するまで戻ってきません。(その間は、HSP3のタスクが動作します。)
      HSP3IMP.DLLは、あくまでもシングルタスクとして動作することを前提としているので注意してください。
    </Setting>
  </command>
  <command>
    <Name>hspprm</Name>
    <Title>HSP3IMP.DLLに関する設定と情報の取得</Title>
    <Format>
      p1,p2,p3,p4
      p1         : 設定または取得のモード
      p2, p3, p4 : p1 に応じたパラメーター
    </Format>
    <Setting>
      HSP3IMP.DLLに関する設定および、情報の取得を行ないます。
      p1の値によって、p2〜p4までに指定する内容が変わります。
      設定されるパラメーターは、以下を参考にしてください。

      p1(mode)
      -----------------------------------------------------------
      0        親ウィンドウからの表示オフセット指定
      (p2,p3でX,Yオフセット値を設定します)
      1        起動パラメーター指定(HSPTVでのみ使用します)
      0x100        HSPCTX構造体のポインタを取得
      (結果がp4で指定されたアドレスに書き込まれます)
      0x101        拡張命令を初期化するための関数指定
      (p4にHSP3TYPEINFOポインタを引数とする関数を登録します)
      0x102        HSP3オブジェクトファイル名を指定
      (p4にファイル名が格納されているアドレスを設定)
    </Setting>
  </command>
  <command>
    <Name>hsc_ini</Name>
    <Title>HSPCMP.DLLの初期化</Title>
    <Format>
      "filename"
      "filename" : コンパイルの対象となるファイル名
    </Format>
    <Setting>
      HSPCMP.DLLの初期化を行ないます。
      HSPCMP.DLLの機能を使用する場合は、最初に初期化をする必要があります。
      "filename"で指定したファイルをコンパイルの対象とします。
      ファイル名は、拡張子(asでなくても構いません)も含めて指定して下さい。
    </Setting>
  </command>
  <command>
    <Name>hsc_refname</Name>
    <Title>エラー表示ファイル名の指定</Title>
    <Format>
      "filename"
      "filename" : エラーメッセージで表示されるファイル名
    </Format>
    <Setting>
      エラーメッセージで表示されるソーススクリプトファイル名を指定します。
      これは、たとえば「test.as」という名前を一時的に「hsptmp」などの別名で保存してコンパイルする時にも、エラーメッセージには「test.as」ファイル内でエラーが起こっているということを表示させるためのものです。
      ソーススクリプトファイル名が、hsc_iniで指定したファイルから変更する必要がない場合は、指定しなくても構いません。
    </Setting>
  </command>
  <command>
    <Name>hsc_objname</Name>
    <Title>出力オブジェクトファイル名の指定</Title>
    <Format>
      "filename"
      "filename" : 出力オブジェクトファイル名
    </Format>
    <Setting>出力されるオブジェクトファイル名を指定します。</Setting>
  </command>
  <command>
    <Name>hsc_compath</Name>
    <Title>共通ディレクトリの指定</Title>
    <Format>
      "pathname"
      "pathname" : 共通ディレクトリパス
    </Format>
    <Setting>
      #includeでサーチされる共通ディレクトリを指定します。
      "pathname"は必ず「¥」で終わる文字列である必要があります。
      hsc_compathが指定されなかった場合は、hspcmp.dllを使用しているEXEの下にある「common」ディレクトリが参照されます。
    </Setting>
  </command>
  <command>
    <Name>hsc_comp</Name>
    <Title>オブジェクトファイル作成</Title>
    <Format>
      p1,p2,p3
      p1=0〜(0) : コンパイルの設定オプション
      p2=0〜(0) : プリプロセッサの設定オプション
      p3=0〜(0) : デバッグウィンドウ表示の有無
    </Format>
    <Setting>
      HSPコードコンパイラで、ソースファイルをコンパイルして、オブジェクトファイルを作成します。
      p1のパラメータで、デバッグ情報をオブジェクトファイルに出力するかを指定することができます。
      p1が0かまたは省略されている場合は、エラー行表示などに必要なデバッグ情報がオブジェクトファイルに付加されません。
      p1が1(bit0)の場合は、デバッグ情報が付加されます。
      p1が2(bit1)の場合はプリプロセス処理のみ行います。
      p1が4(bit2)の場合は文字列データをUTF-8コードに変換して出力します。
      p2が0の場合は「__hsp30__」マクロが定義された状態でコンパイルを行ないます。
      p2が1の場合は、マクロは定義されません。これは、スクリプトエディタの
      「HSP拡張マクロを使用する」フラグをコンパイラに渡すためのものです。
      p2の値を+4(bit2)すると、ソースに含まれる実行ファイル自動作成のための命令(#pack,#epack,#packopt)をもとにpackfile作成を行ないます。
      p3が0以外の場合は、デバッグウインドゥを表示するフラグをオブジェクトファイルに埋め込みます。
      hsc_comp命令を実行するためには、必ずhsc_ini命令で初期化とファイルの指定をする必要があります。
      また、必要があればhsc_objnameで出力されるオブジェクトファイル名を指定します。(出力ファイル名は、デフォルトではhdc_iniで指定したファイル名の拡張子が「.ax」になったものになります)
      さらに必要であれば、hsc_refname命令をあらかじめ実行しておいて下さい。コンパイルの手順としては、

      1.「hsc_ini」
      2.「hsc_refname」(省略可)
      3.「hsc_objname」(省略可)
      4.「hsc_comp」

      のようになります。
    </Setting>
  </command>
  <command>
    <Name>hsc_getmes</Name>
    <Title>エラーメッセージ出力先指定</Title>
    <Format>
      p1
      p1 : エラーメッセージを受け取る文字列型変数
    </Format>
    <Setting>p1で指定した文字列型の変数に、エラーなどHSPCMP.DLLが出力したメッセージを代入します。</Setting>
  </command>
  <command>
    <Name>hsc_clrmes</Name>
    <Title>エラーメッセージのクリア</Title>
    <Format></Format>
    <Setting>コンパイラが出力したメッセージのデータをすべてクリアします。</Setting>
  </command>
  <command>
    <Name>hsc_ver</Name>
    <Title>コンパイラのバージョンを取得</Title>
    <Format></Format>
    <Setting>システム変数refstrに、HSPコードコンパイラのバージョン情報を文字列として返します。</Setting>
  </command>
  <command>
    <Name>hsc_bye</Name>
    <Title>コンパイラの終了処理</Title>
    <Format></Format>
    <Setting>
      HSPコードコンパイラの終了処理を行ないます。
      この命令は自動的に実行されるので、通常は使用しません。
    </Setting>
  </command>
  <command>
    <Name>pack_ini</Name>
    <Title>PACKFILEマネージャの初期化</Title>
    <Format>
      "filename"
      "filename" : 操作対象ファイル名
    </Format>
    <Setting>
      PACKFILEマネージャの初期化を行ないます。
      PACKFILEの操作を行なう場合(「pack_」で始まる命令)は、最初に初期化をする必要があります。
      "filename"で指定したファイルを操作の対象とします。
      ファイル名は、拡張子のないものを指定して下さい。
    </Setting>
  </command>
  <command>
    <Name>pack_view</Name>
    <Title>PACKFILEの内容一覧を表示</Title>
    <Format></Format>
    <Setting>pack_iniで指定したファイルをDPMファイルとして内容一覧を表示します。pack_viewの結果は、hsc_getmes命令で取得して下さい。</Setting>
  </command>
  <command>
    <Name>pack_make</Name>
    <Title>DPMファイルを作成</Title>
    <Format>
      p1,p2
      p1 : 作成モード( 0=標準EXEファイル用 / 1=外部DPMファイル用 )
      p2 : 暗号化キー( 0=標準キーを使用する / その他=暗号化キー )
    </Format>
    <Setting>
      pack_iniで指定したファイル名でDPMファイルを作成します。
      p1で、標準EXEファイル用か、外部読み込み用のDPMファイルなのかを指定する必要があります。
      また、DPMファイルを作成する場合は、p2で暗号化キーについての設定を行なうことができます。
      p2に0を指定した場合は、標準の暗号化によるDPMファイル(2.61互換)を作成します。
      p2に0以外を指定した場合は、その値をキーとする暗号化を施します。
      この場合は、DPM読み込みの際にスクリプト側で同じ値のキーをchdpm命令によって指定しなければ、正しいファイルとして復号されなくなるので注意してください。
      DPMファイルに含めるファイルは、カレントディレクトリの「PACKFILE」内のテキストで指定されたファイルになります。
    </Setting>
  </command>
  <command>
    <Name>pack_exe</Name>
    <Title>実行ファイルを作成</Title>
    <Format>
      p1
      p1 : 作成モード(0=標準 / 1=フルスクリーンモード / 2=スクリーンセーバー)
    </Format>
    <Setting>
      pack_iniで指定したファイル名でEXEファイルを作成します。
      p1で3つのモード(標準・フルスクリーン・スクリーンセーバー)を指定することができます。
      EXEファイルに含めるファイルは、カレントディレクトリの「PACKFILE」内のテキストで指定されたファイルになります。
      また、HSPランタイムファイル(hsprt)が適切なディレクトリに置かれている必要があります。
    </Setting>
  </command>
  <command>
    <Name>pack_opt</Name>
    <Title>実行ファイル作成オプションを指定</Title>
    <Format>
      p1,p2,p3
      p1=0〜(640) : 画面Xサイズ
      p2=0〜(480) : 画面Yサイズ
      p3=0〜(0) : 起動時の動作スイッチ
    </Format>
    <Setting>
      pack_exe命令でEXEファイルを作成する場合のオプションを指定します。
      pack_exe命令を実行する前に、指定をしておく必要があります。
      p3で指定する起動時の動作スイッチには、以下の値を指定することで特殊な起動動作にすることができます。

      1 = 初期ウィンドウ非表示
      2 = ディレクトリ移動なし

      動作スイッチは、加算することで同時に機能を選択することが可能です。
      特に特殊な動作が必要ない場合は、0を指定して下さい。
    </Setting>
  </command>
  <command>
    <Name>pack_rt</Name>
    <Title>HSPランタイムファイルを指定</Title>
    <Format>
      "filename"
      "filename" : HSPランタイムファイル(hsprt)のあるフルパス名
    </Format>
    <Setting>
      pack_exe命令でEXEファイルを作成する場合に参照されるHSPランタイムファイル(hsprt)のあるフルパス名を指定します。
      HSPランタイムファイルがカレントディレクトリにない場合は、指定をしておいてください。
      (例: pack_rt "c:¥hsp¥hsprt")
    </Setting>
  </command>
  <command>
    <Name>pack_get</Name>
    <Title>packfileからファイルを取り出す</Title>
    <Format>
      "filename"
      "filename" : 取り出すファイル名
    </Format>
    <Setting>
      pack_iniで指定したファイル名をDPMファイルとして、格納されているファイルを取り出します。
      "filename"で指定したファイルが取り出され、カレントディレクトリにセーブされます。
    </Setting>
  </command>
  <command>
    <Name>hsc3_getsym</Name>
    <Title>シンボル名を取得</Title>
    <Format></Format>
    <Setting>
      コンパイラのメッセージバッファにHSPで使用されるシンボル名を出力します。
      出力は、「シンボル名,sys[|var/func/macro][|1/2]」の形式になります。
    </Setting>
  </command>
  <command>
    <Name>hsc3_messize</Name>
    <Title>コンパイラメッセージのサイズを取得</Title>
    <Format>
      val
      val : サイズを受け取る数値型変数
    </Format>
    <Setting>hsc_getmesで得られるメッセージ全体のサイズを、valで指定した変数に代入します。</Setting>
  </command>
  <command>
    <Name>hsc3_make</Name>
    <Title>実行ファイルの自動作成</Title>
    <Format>
      "path"
      "path" : HSPランタイムライブラリのあるフルパス
    </Format>
    <Setting>
      実行ファイルの自動作成を行ないます。
      "path"でHSPランタイムライブラリのあるフルパスを指定します。
      packfileのオプションに従って実行ファイルを作成します。
      オプション付きのpackfile作成は、hsc_compで行ないます。
    </Setting>
  </command>
  <command>
    <Name>hsc3_getruntime</Name>
    <Title>ランタイムファイルの取得</Title>
    <Format>
      val, "objfile"
      val       : ランタイム名を取得する変数
      "objfile" : オブジェクトファイル名
    </Format>
    <Setting>
      "objfile"で指定したオブジェクトファイルが必要とする
      ランタイムファイル名をvalで指定した変数に取得します。
      valの変数は文字列型で初期化されている必要があります。
      ランタイムファイル名が空("")の場合は、デフォルトのランタイム(hsp3.exe)を使用することを示しています。
    </Setting>
  </command>
  <command>
    <Name>hsc3_run</Name>
    <Title>ランタイム実行</Title>
    <Format>
      "string"
      "string"   : 実行コマンドライン
    </Format>
    <Setting>
      "string"の内容をランタイム実行用のコマンドラインとして処理します。
      "string"には、「ランタイム名」「オブジェクトファイル名」「起動オプション」をそれぞれスペースで区切った形で指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>cvreset</Name>
    <Title>HSPCVの初期化</Title>
    <Format></Format>
    <Setting>
      HSPCVが持つ「CVバッファ」をすべて破棄して、初期状態に戻します。
      HSPCVの開始、終了時には自動的に初期化が行なわれます。
      明示的に初期化したい時にcvreset命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>cvsel</Name>
    <Title>対象CVバッファの設定</Title>
    <Format>
      p1
      p1 : CVバッファID
    </Format>
    <Setting>
      標準の操作先CVバッファIDを設定します。
      パラメーターで、CVバッファIDを指定する時に省略した場合には、標準の操作先CVバッファIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvbuffer</Name>
    <Title>CVバッファを初期化</Title>
    <Format>
      p1,p2,p3
      p1(0)   : CVバッファID
      p2(640) : 横のピクセルサイズ
      p3(480) : 縦のピクセルサイズ
    </Format>
    <Setting>
      指定したサイズでCVバッファを初期化します。
      バッファを初期化することにより、各種画像処理が可能になります。
      CVバッファは、フルカラーモード(RGB各8bit)で初期化されます。
    </Setting>
  </command>
  <command>
    <Name>cvresize</Name>
    <Title>画像のリサイズ</Title>
    <Format>
      p1,p2,p3,p4
      p1(0) : 横のピクセルサイズ
      p2(0) : 縦のピクセルサイズ
      p3 : CVバッファID
      p4(1) : 補間アルゴリズム
    </Format>
    <Setting>
      CVバッファを(p1,p2)で指定したサイズに変更します。
      p3で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
      p4で補間アルゴリズムを指定します。
      p4で指定する内容は以下から1つ選ぶことができます。

      CV_INTER_NN - ニアレストネイバー
      CV_INTER_LINEAR - バイリニア(デフォルト)
      CV_INTER_AREA - ピクセル周辺をリサンプリング
      (モアレを低減することができます)
      CV_INTER_CUBIC - バイキュービック
    </Setting>
  </command>
  <command>
    <Name>cvgetimg</Name>
    <Title>画像の取得</Title>
    <Format>
      p1,p2
      p1(0) : CVバッファID
      p2(0) : 取得モード
    </Format>
    <Setting>
      CVバッファの内容をHSPのウィンドウバッファに転送します。
      転送先となるHSPのウィンドウバッファは、gsel命令で指定されている現在の操作先ウィンドウIDとなります。
      p1で転送元となるCVバッファIDを指定します。
      省略された場合は、ID0が使用されます。
      p2で、転送時の方法を指定することができます。
      p2が0の場合は、HSPのウィンドウバッファサイズはそのままで転送を行ないます。
      p2に1を指定した場合は、CVバッファと同じサイズにHSPのウィンドウバッファサイズを変更した上で転送を行ないます。
    </Setting>
  </command>
  <command>
    <Name>cvputimg</Name>
    <Title>CVバッファに書き込み</Title>
    <Format>
      p1
      p1 : CVバッファID
    </Format>
    <Setting>
      HSPのウィンドウバッファ内容をCVバッファに転送します。
      転送元となるHSPのウィンドウバッファは、gsel命令で指定されている現在の操作先ウィンドウIDとなります。
      p1で転送先となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvload</Name>
    <Title>画像ファイル読み込み</Title>
    <Format>
      "filename",p1
      "filename" : 画像ファイル名
      p1 : CVバッファID
    </Format>
    <Setting>
      CVバッファを指定された画像ファイルの内容で初期化します。
      p1で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      画像ファイルのフォーマットはファイル拡張子によって判断されます。
      使用できるフォーマットと拡張子は以下の通りです。

      Windows bitmaps - BMP, DIB
      JPEG files - JPEG, JPG, JPE
      Portable Network Graphics - PNG
      Portable image format - PBM, PGM, PPM
      Sun rasters - SR, RAS
      TIFF files - TIFF, TIF
      OpenEXR HDR images - EXR
      JPEG 2000 images - JP2

      処理が正常に終了した場合には、システム変数statが0になります。
      何らかのエラーが発生した場合には、システム変数statが0以外の値となります。
      #pack、#epack等で実行ファイル及びDPMファイルに埋め込まれたファイルは読み込むことができませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>cvsave</Name>
    <Title>画像ファイル書き込み</Title>
    <Format>
      "filename",p1,p2
      "filename" : 画像ファイル名
      p1 : CVバッファID
      p2 : オプション値
    </Format>
    <Setting>
      CVバッファの内容を指定された画像ファイル名で保存します。
      p1で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      画像ファイルのフォーマットはファイル拡張子によって判断されます。
      使用できるフォーマットと拡張子は以下の通りです。

      Windows bitmaps - BMP, DIB
      JPEG files - JPEG, JPG, JPE
      Portable Network Graphics - PNG
      Portable image format - PBM, PGM, PPM
      Sun rasters - SR, RAS
      TIFF files - TIFF, TIF
      OpenEXR HDR images - EXR
      JPEG 2000 images - JP2

      p2で指定するオプション値は、フォーマットごとの設定を指定するためのものです。
      現在は、JPEGフォーマット保存時の品質(0〜100)のみ指定可能です。
      p2の指定を省略した場合は、JPEGフォーマット保存時に、品質95が使用されます。
      処理が正常に終了した場合には、システム変数statが0になります。
      何らかのエラーが発生した場合には、システム変数statが0以外の値となります。
    </Setting>
  </command>
  <command>
    <Name>cvgetinfo</Name>
    <Title>CVバッファ情報を取得</Title>
    <Format>
      p1,p2,p3
      p1 : CVバッファ情報が取得される変数
      p2 : CVバッファID
      p3 : CVバッファ情報ID
    </Format>
    <Setting>
      CVバッファに関する情報を取得してp1の変数に代入します。
      p2で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      p3で取得する情報の種類を指定することができます。
      p3に指定できるマクロは以下の通りです。

      マクロ               内容
      -------------------------------------------
      CVOBJ_INFO_SIZEX     横方向サイズ
      CVOBJ_INFO_SIZEY     縦方向サイズ
      CVOBJ_INFO_CHANNEL   チャンネル数
      CVOBJ_INFO_BIT       チャンネルあたりのビット数
    </Setting>
  </command>
  <command>
    <Name>cvsmooth</Name>
    <Title>画像のスムージング</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1 : スムージングのタイプ
      p2 : param1
      p3 : param2
      p4 : param3
      p5 : CVバッファID
    </Format>
    <Setting>
      CVバッファにスムージングを適用します。
      p5で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      p1で指定することのできるマクロは以下の通りです。

      CV_BLUR_NO_SCALE
      (param1×param2の領域でピクセル値を足し合わせる)

      CV_BLUR
      (param1×param2の領域でピクセル値を足し合わせた後、
      1/(param1*param2)でスケーリングする)

      CV_GAUSSIAN
      (param1×param2ガウシアンフィルタ)

      CV_MEDIAN
      (param1×param2メディアンフィルタ)

      CV_BILATERAL
      (3×3バイラテラルフィルタ(param1=色分散, param2=空間分散))

      http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html

      「param1×param2」のパラメーターは、1以上の奇数を指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>cvthreshold</Name>
    <Title>画像を閾値で取得</Title>
    <Format>
      p1,p2,p3,p4
      p1 : ２値化タイプ
      p2 : 閾値(実数)
      p3 : 二値化後の画素値(実数)
      p4 : CVバッファID
    </Format>
    <Setting>
      CVバッファに対して閾値をもとに２値化を行ないます。
      p4で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
      p1で指定することのできるマクロは以下の通りです。

      CV_THRESH_BINARY     : val = (val > thresh ? MAX:0)
      CV_THRESH_BINARY_INV : val = (val > thresh ? 0:MAX)
      CV_THRESH_TRUNC      : val = (val > thresh ? thresh:val)
      CV_THRESH_TOZERO     : val = (val > thresh ? val:0)
      CV_THRESH_TOZERO_INV : val = (val > thresh ? 0:val)
    </Setting>
  </command>
  <command>
    <Name>cvrotate</Name>
    <Title>画像の回転</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1(0) : 角度(実数)
      p2(1) : スケール(実数)
      p3(0) : 中心座標のXオフセット(実数)
      p4(0) : 中心座標のYオフセット(実数)
      p5 : 補間アルゴリズム
      p6 : CVバッファID
    </Format>
    <Setting>
      CVバッファ全体を回転させます。
      p1で角度(360度で一周)を、p2でスケールを設定します。
      (p3,p4)で中心のオフセットを指定することがてきます。
      p5で、回転時の補間アルゴリズムを指定します。
      p5で指定する内容は以下から1つ選ぶことができます。

      CV_INTER_NN - ニアレストネイバー
      CV_INTER_LINEAR - バイリニア(デフォルト)
      CV_INTER_AREA - ピクセル周辺をリサンプリング
      (モアレを低減することができます)
      CV_INTER_CUBIC - バイキュービック

      また、p5に同時指定できるオプションが用意されています。

      CV_WARP_FILL_OUTLIERS - 外部ピクセルを埋める
      CV_WARP_INVERSE_MAP - 回転を逆行列で行なう

      デフォルトでは、CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERSが指定されています。
      p6で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvarea</Name>
    <Title>コピー元領域の指定</Title>
    <Format>
      p1,p2,p3,p4
      p1(0) : コピー元 X座標
      p2(0) : コピー元 Y座標
      p3(0) : コピー領域 Xサイズ
      p4(0) : コピー領域 Yサイズ
    </Format>
    <Setting>
      cvcopy命令で画像のコピーを行なう際のコピー元領域を指定します。
      パラメーターがすべて0の場合や、すべて省略してcvarea命令を実行した場合は、CVバッファ全体が対象になります。
    </Setting>
  </command>
  <command>
    <Name>cvcopy</Name>
    <Title>画像のコピー</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1(0) : コピー元CVバッファID
      p2(0) : コピー先 X座標
      p3(0) : コピー先 Y座標
      p4 : コピー先CVバッファID
      p5(0) : 演算オプション
    </Format>
    <Setting>
      CVバッファの内容を別なCVバッファにコピーします。
      p1で指定されたCVバッファIDがコピー元として使用されます。
      バッファの一部をコピーする場合には、cvarea命令で位置やサイズをあらかじめ設定しておく必要があります。
      p5の演算オプションにより、コピー時にいくつかの演算を行なうことが可能です。p5に指定できるマクロは以下の通りです。

      CVCOPY_SET (上書きコピー)
      CVCOPY_ADD (加算)
      CVCOPY_SUB (減算)
      CVCOPY_MUL (乗算)
      CVCOPY_DIF (差分)
      CVCOPY_AND (論理積)

      p4でコピー先となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      CVバッファの色モードは、コピー元とコピー先で合わせておく必要があります。
      グレイスケール(白黒)画面とフルカラー画面を混在してコピーすることはできません。
    </Setting>
  </command>
  <command>
    <Name>cvxors</Name>
    <Title>画像のXOR演算</Title>
    <Format>
      p1,p2,p3,p4
      p1(255) : XOR演算で使用するR値
      p2(255) : XOR演算で使用するG値
      p3(255) : XOR演算で使用するB値
      p4 : コピー先CVバッファID
    </Format>
    <Setting>
      CVバッファの内容に対してXOR演算を行ないます。
      p1〜p3までで、RGB値に対する演算値(0〜255)を指定します。
      p4で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvflip</Name>
    <Title>画像の反転</Title>
    <Format>
      p1,p2
      p1(0) : 反転のモード
      p2 : コピー先CVバッファID
    </Format>
    <Setting>
      CVバッファの内容を反転させます。
      p1で反転のモードを指定することができます。
      p1が0の場合は、上下反転になります。
      p1が1以上の場合は、左右反転になります。
      p1がマイナス値の場合は、上下左右ともに反転されます。

      p2で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvloadxml</Name>
    <Title>XMLファイルの読み込み</Title>
    <Format>
      "filename"
      "filename" : 読み込むXMLファイル名
    </Format>
    <Setting>
      "filename"で指定されたファイルをXMLファイルとして読み込みます。
      XMLファイルは、画像の顔認識等で必要な場合にあらかじめ読み込んでおく必要があります。

      処理が正常に終了した場合には、システム変数statが0になります。
      何らかのエラーが発生した場合には、システム変数statが0以外の値となります。

      #pack、#epack等で実行ファイル及びDPMファイルに埋め込まれたファイルは読み込むことができませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>cvfacedetect</Name>
    <Title>画像の顔認識</Title>
    <Format>
      p1,p2
      p1 : CVバッファID
      p2(1) : スケール値(実数)
    </Format>
    <Setting>
      CVバッファの画像から特定のパターンを認識します。
      パターンのパラメーターを持つxmlファイルを、あらかじめcvloadxml命令で読み込んでおく必要があります。

      p1で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      p2で処理時のスケールを設定することができます。
      ここで1より大きい値を指定すると、処理時にバッファサイズを縮小して処理されるようになります。大きな画像等で時間が
      かかる場合などに指定するといいでしょう。

      実行後に、システム変数statに認識された数が返されます。
      statが0の場合は、まったく認識されていないことを示します。
      statが1以上の場合は、cvgetface命令によって認識された領域を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>cvgetface</Name>
    <Title>認識された座標の取得</Title>
    <Format>
      p1,p2,p3,p4
      p1 : 認識されたX座標が代入される変数
      p2 : 認識されたY座標が代入される変数
      p3 : 認識されたXサイズが代入される変数
      p4 : 認識されたYサイズが代入される変数
    </Format>
    <Setting>
      cvfacedetect命令によって認識された領域を取得します。
      p1からp4までの変数に、座標値が整数で代入されます。
      cvfacedetect命令によって認識された個数だけ、繰り返して領域を取得することができます。

      正常に取得できた場合には、実行後にシステム変数statが0になります。
      取得できるデータがない場合には、システム変数statは1になります。
    </Setting>
  </command>
  <command>
    <Name>cvmatch</Name>
    <Title>画像のマッチング検査</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1 : 認識されたX座標が代入される変数
      p2 : 認識されたY座標が代入される変数
      p3 : マッチングのタイプ
      p4 : マッチング元のCVバッファID
      p5 : マッチング先のCVバッファID
    </Format>
    <Setting>
      マッチング先のCVバッファの中から、マッチング元のCVバッファに最も近い領域を探し出して結果を返します。
      実行後、(p1,p2)に指定した変数へ結果となる座標を代入します。
      p3でマッチングで使用する評価方法のタイプを指定します。
      p3で指定することのできるマクロは以下の通りです。

      CV_TM_SQDIFF
      R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2

      CV_TM_SQDIFF_NORMED
      R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2/sqrt[sumx',y'T(x',y')2・sumx',y'I(x+x',y+y')2]

      CV_TM_CCORR
      R(x,y)=sumx',y'[T(x',y')・I(x+x',y+y')]

      CV_TM_CCORR_NORMED
      R(x,y)=sumx',y'[T(x',y')・I(x+x',y+y')]/sqrt[sumx',y'T(x',y')2・sumx',y'I(x+x',y+y')2]

      CV_TM_CCOEFF
      R(x,y)=sumx',y'[T'(x',y')・I'(x+x',y+y')],
      where T'(x',y')=T(x',y') - 1/(w・h)・sumx",y"T(x",y")
      I'(x+x',y+y')=I(x+x',y+y') - 1/(w・h)・sumx",y"I(x+x",y+y")

      CV_TM_CCOEFF_NORMED
      R(x,y)=sumx',y'[T'(x',y')・I'(x+x',y+y')]/sqrt[sumx',y'T'(x',y')2・sumx',y'I'(x+x',y+y')2]

      p5で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      cvmatch命令は、あくまでも最も近い領域を検索するだけで、完全に同じであることを保障するものではありません。
    </Setting>
  </command>
  <command>
    <Name>cvconvert</Name>
    <Title>色モードの変換</Title>
    <Format>
      p1,p2
      p1(0) : 変換モード
      p2 : CVバッファID
    </Format>
    <Setting>
      CVバッファをp1で指定された色モードに変換します。
      p1が0の場合は、フルカラー画面をグレイスケール(白黒)画面に。
      p1が1の場合は、グレイスケール(白黒)画面をフルカラー画面に、それぞれ変換します。
      p2で対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。
    </Setting>
  </command>
  <command>
    <Name>cvcapture</Name>
    <Title>カメラキャプチャの開始</Title>
    <Format>
      p1,p2
      p1(0) : カメラID
      p2 : CVバッファID
    </Format>
    <Setting>
      キャプチャデバイスからの入力を開始します。
      p1で、カメラを特定するためのカメラIDを指定します。
      p1で指定できる値は以下の通りです。
      複数のデバイスが接続されている場合は、1づつ値を加算することで特定することが可能です。

      マクロ          値      内容
      -------------------------------------------------
      CV_CAP_ANY      0  	利用可能なデバイスすべて
      CV_CAP_MIL      100	Matrox Imaging Library
      CV_CAP_VFW      200	Video for Windows
      CV_CAP_IEEE1394 300	IEEE1394(現バージョンでは未対応です)

      p2でキャプチャした画像を保存する対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      カメラキャプチャの開始後は、cvgetcapture命令によってフレームごとの画像を取得することができます。
      また、不要になった場合には必ずcvendcapture命令でキャプチャを終了させる必要があります。
    </Setting>
  </command>
  <command>
    <Name>cvgetcapture</Name>
    <Title>キャプチャ画像の取得</Title>
    <Format></Format>
    <Setting>
      cvcapture命令によって開始されたキャプチャのフレーム画像を取得します。
      取得されるCVバッファは、cvcapture命令で設定されたIDになります。
    </Setting>
  </command>
  <command>
    <Name>cvendcapture</Name>
    <Title>カメラキャプチャの終了</Title>
    <Format></Format>
    <Setting>cvcapture命令によって開始されたキャプチャを終了します。</Setting>
  </command>
  <command>
    <Name>cvopenavi</Name>
    <Title>aviファイル取得の開始</Title>
    <Format>
      "filename",p1
      "filename" : avi動画ファイル名
      p1 : CVバッファID
    </Format>
    <Setting>
      avi動画ファイルからの入力を開始します。
      指定されたファイル内のフレームを取得することができるようになります。

      p1でキャプチャした画像を保存する対象となるCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      aviファイル取得の開始後は、cvgetavi命令によってフレームごとの画像を取得することができます。
      また、不要になった場合には必ずcvcloseavi命令でaviファイル取得を終了させる必要があります。

      cvopenavi命令は、あくまでもaviファイルの内容を簡易的に取り出すための機能で、正常な動画再生を行なうためのものではありません。あくまでも、フレームを取り出して処理を行なうための補助機能だとお考えください。
      また、cvopenavi命令が扱うことのできるaviファイルは、古い形式のaviフォーマットに限られており、すべてのaviファイルを開くことができるわけではありません。
    </Setting>
  </command>
  <command>
    <Name>cvgetavi</Name>
    <Title>aviファイル画像の取得</Title>
    <Format></Format>
    <Setting>
      cvopenavi命令によって開始されたaviファイルのフレーム画像を取得します。
      取得されるCVバッファは、cvcapture命令で設定されたIDになります。
    </Setting>
  </command>
  <command>
    <Name>cvcloseavi</Name>
    <Title>aviファイル取得の終了</Title>
    <Format></Format>
    <Setting>cvopenavi命令によって開始されたaviファイル取得を終了します。</Setting>
  </command>
  <command>
    <Name>cvmakeavi</Name>
    <Title>aviファイル出力の開始</Title>
    <Format>
      "filename",p1,p2,p3
      "filename" : 出力するavi動画ファイル名
      p1(-1) : 32bit Codecコード
      p2(29.97) : 実数によるフレームレート(fps)
      p3 : CVバッファID
    </Format>
    <Setting>
      avi動画ファイルへの出力を開始します。
      指定されたファイル名でaviファイルを作成します。

      p1でコーデックが持つ32bitのコード(FOURCC)を指定します。
      p1に-1を指定した場合は、コーデックを選択するダイアログが開きます。
      p2で実数によるフレームレート(fps)を指定します。
      p2の指定が省略された場合には、29.97fpsとなります。

      p3で出力画像を保持するCVバッファIDを指定します。
      省略された場合は、cvsel命令で設定されたIDが使用されます。

      出力の開始後は、cvputavi命令によってフレームごとの画像を登録して、最後にcvendavi命令を呼び出す必要があります。
    </Setting>
  </command>
  <command>
    <Name>cvputavi</Name>
    <Title>aviファイルに画像を出力</Title>
    <Format></Format>
    <Setting>
      cvmakeavi命令によって開始されたaviファイルに、フレーム画像を追加します。
      参照されるCVバッファは、cvmakeavi命令で設定されたIDになります。
    </Setting>
  </command>
  <command>
    <Name>cvendavi</Name>
    <Title>aviファイル出力の終了</Title>
    <Format></Format>
    <Setting>cvmakeavi命令によって開始されたaviファイル出力を終了します。</Setting>
  </command>
  <command>
    <Name>cvj2opt</Name>
    <Title>JPEG-2000保存オプション設定</Title>
    <Format>
      "format","option"
      "format" : フォーマット文字列
      "option" : オプション文字列
    </Format>
    <Setting>
      cvsave命令でJPEG-2000形式(.jp2)を指定した際の詳細設定を行ないます。
      フォーマット文字列には、以下のいずれかを指定することができます。
      (JPEG以外のフォーマットを指定した場合でも、拡張子はjp2のままになるので注意してください)

      フォーマット文字列     形式
      ----------------------------------------
      mif	    My Image Format
      pnm	    Portable Graymap/Pixmap
      bmp	    Microsoft Bitmap
      ras	    Sun Rasterfile
      jp2	    JPEG2000 JP2 File Format Syntax
      jpc	    JPEG2000 Code Stream Syntax
      jpg	    JPEG
      pgx	    JPEG2000 VM Format

      オプション文字列により、付加設定を行なうことができます。

      例:
      cvj2opt "jp2","rate=0.1"
      cvsave "test2000.jp2"

      オプション文字列は、フォーマットごとに設定方法が異なります。
      詳しくは、jasperライブラリに含まれる、コマンドラインツール
      jasperのオプションを参照してください。

      http://www.ece.uvic.ca/‾mdadams/jasper/
    </Setting>
  </command>
  <command>
    <Name>sortval</Name>
    <Title>配列変数を数値でソート</Title>
    <Format>
      p1 : 数値型の配列変数名
      p2 : 並び順 (0=小さい順/1=大きい順)
      p1,p2
    </Format>
    <Setting>
      数値が格納された配列変数を指定された並び順でソート(並び替え)します。
      p1で指定された配列変数を直接並べ替えます。

      並び替えに関する情報は、sortget命令で得ることができます。
    </Setting>
  </command>
  <command>
    <Name>sortstr</Name>
    <Title>配列変数を文字列でソート</Title>
    <Format>
      p1,p2
      p1 : 文字列型の配列変数名
      p2 : 並び順 (0=小さい順/1=大きい順)
    </Format>
    <Setting>
      文字列が格納された配列変数を指定された並び順でソート(並び替え)します。
      p1で指定された配列変数を直接並べ替えます。
      ソートの並び順は、 ASCIIコードの大きい小さいで比較されるので、 ABC順、あいうえお順に並べ替えられます。

      並び替えに関する情報は、sortget命令で得ることができます。
    </Setting>
  </command>
  <command>
    <Name>sortnote</Name>
    <Title>メモリノート文字列をソート</Title>
    <Format>
      p1,p2
      p1 : メモリノート形式の文字列型の変数名
      p2 : 並び順 (0=小さい順/1=大きい順)
    </Format>
    <Setting>
      メモリノートパッド形式の 文字列が格納された変数を、 指定された並び順でソート(並び替え)します。
      p1で指定された変数を直接並べ替えます。
      ソートの並び順は、 ASCIIコードの大きい小さいで比較されるので、 ABC順、あいうえお順に並べ替えられます。

      並び替えに関する情報は、sortget命令で得ることができます。
      メモリノートパッド形式は、 notesel,  noteget命令などで使用することのできる「¥n」(改行コード)で区切られたデータ列のことです。
    </Setting>
  </command>
  <command>
    <Name>sortget</Name>
    <Title>ソート元のインデックスを取得</Title>
    <Format>
      p1,p2
      p1 : 結果が代入される変数名
      p2 : インデックスNo.
    </Format>
    <Setting>
      sortstr, sortval, sortnote命令を実行後の配列において、格納されているデータは、ソートする前はどのインデックスに置かれていたものかを調べて結果を返します。
      たとえば、配列変数aをソートした後、 sortget n,4という命令で、1という値が返ってきたとすると、a.4という配列変数に現在入っている値は、ソートする前には、a.1 に入っていたことを示します。
      この命令は、データの一部だけをソートして、その情報をもとにほかのデータの並び替えも行なうような時に有効です。
    </Setting>
  </command>
  <command>
    <Name>csvstr</Name>
    <Title>CSVの１行を配列に変換</Title>
    <Format>
      p1,p2
      p1 : 結果が代入される文字列型の配列変数名
      p2 : CSVの１行を取り出した文字列
    </Format>
    <Setting>
      CSV形式のデータから取り出した１行だけのデータを、 文字列型の配列変数に展開します。
      CSV形式は、「,」で区切られたテキストのデータです。
      たとえば、「a,b,c,d」 のような 「,」 で区切られた4つの文字列があったとすると、csvstr命令を使うことで 「a.0="a"」 「a.1="b"」「a.2="c"」「a.3="d"」のように配列変数にそれぞれの要素を分けて代入することができます。
      p1で指定される配列変数は、必ず文字列型の配列変数である必要があります。

      配列変数に確保されている文字数や配列の限界を越えた部分は無視されます。(エラーになったり、データが破壊されることはありません)

      命令の実行中にエラーが起こった場合にはシステム変数 statが1になります。
      正常に変換された場合は、システム変数 statは、0になります。
    </Setting>
  </command>
  <command>
    <Name>csvnote</Name>
    <Title>CSVの１行をメモリノート変換</Title>
    <Format>
      p1,p2
      p1 : 結果が代入される文字列型の変数名
      p2 : CSVの１行を取り出した文字列
    </Format>
    <Setting>
      CSV形式のデータから取り出した１行だけのデータを メモリノートパッド形式の文字列型の変数に展開します。
      CSV形式は、「,」で区切られたテキストのデータです。
      たとえば、 「a,b,c,d」のような「,」で区切られた4つの文字列があったとするとcsvstr命令を使うことで「"a¥nb¥nc¥nd¥n"」のようにメモリノートパッド命令で扱うデータ("¥n"で区切られたデータ)として代入することができます。

      命令の実行中にエラーが起こった場合にはシステム変数 statが1になります。
      正常に変換された場合は、システム変数 statは、0になります。
    </Setting>
  </command>
  <command>
    <Name>xnotesel</Name>
    <Title>排他メモリノート初期化</Title>
    <Format>
      p1,p2
      p1 : 対象となる文字列型の変数名
      p2 : 項目の最大数(省略時は256)
    </Format>
    <Setting>
      排他メモリノートの初期化を行ないます。
      対象となる変数と、参照カウントのリセットが行なわれます。

      排他メモリノートは、メモリノートパッド命令で使用するものと同じく、１行に1つの項目を持つ長い文字列型のデータです。
      ただし、排他メモリノートは異なる項目(行)しか追加することができません。
      すでに持っている項目を追加しようとすると、参照カウントだけが更新され、実際には追加されません。これにより、同じ文字列を重複しないで格納することや、重複の統計、文字列サーチなどに応用することができます。

      排他メモリノートは、xnoteselで対象となる変数を指定して、必要な場合は、最大項目数も設定します。
      以降は、 xnoteadd命令 を実行するごとに、排他メモリノートの変数に項目が追加されていきます。
    </Setting>
  </command>
  <command>
    <Name>xnoteadd</Name>
    <Title>排他メモリノート項目追加</Title>
    <Format>
      p1
      p1 : 排他メモリノートに追加される文字列
    </Format>
    <Setting>
      排他メモリノートに項目を追加します。
      項目は、改行を含まない文字列でなければいけません。
      実行すると、項目が追加されたインデックスが、システム変数statに代入されます。

      すでに排他メモリノートに含まれる項目は、追加されません。
      その場合は、システム変数statにすでに含まれる項目のインデックスが代入され、項目の参照カウントが1つ増やされます。
      項目の参照カウントは、sortget命令で取得することが可能です。
    </Setting>
  </command>
  <command>
    <Name>csvsel</Name>
    <Title>CSV検索の対象バッファを選択</Title>
    <Format>
      val,mode
      val  : CSV検索の対象となる文字列を格納した変数名
      mode : 区切りキャラクタコード
    </Format>
    <Setting>
      CSV検索の対象となるバッファを選択します。
      CSV形式 またはノートパッド形式の文字列が格納されている変数を指定することができます。

      modeで区切りキャラクターを指定することができます。
      modeを省略または0にした場合は「,」が使用されます。
      9を指定することでタブ区切りのcsvファイルに対応することができます。
    </Setting>
  </command>
  <command>
    <Name>csvres</Name>
    <Title>CSV検索の結果出力バッファを指定</Title>
    <Format>
      val
      val : CSV検索結果を出力する変数名
    </Format>
    <Setting>
      CSV検索の結果出力バッファを指定します。
      必ずある程度のサイズを確保した文字列型の変数にする必要があります。
      想定される出力結果に応じて sdim命令 などでサイズをあらかじめ確保しておいてください。 通常は 32000バイト程度あれば十分です。
      出力結果のサイズがバッファを溢れてしまうような場合は、指定したバッファのサイズに収まる範囲で検索を中断しますので、バッファオーバーフローは起こりません。
    </Setting>
  </command>
  <command>
    <Name>csvflag</Name>
    <Title>CSV検索の項目フラグを設定</Title>
    <Format>
      id,val
      id  : 項目ID
      val : 設定値(0〜255)
    </Format>
    <Setting>
      CSV検索の対象となる項目単位でのフラグ設定を行ないます。
      設定値が0の場合は、CSV検索は行なわれません。
      0以外の場合は、CSV検索の対象項目となります。
      デフォルトでは、すべての項目が検索対象となっています。
      項目idは、最も左にある項目を0として以降区切り記号ごとに右に1づつ増加していきます。
    </Setting>
  </command>
  <command>
    <Name>csvopt</Name>
    <Title>CSV検索のオプションを設定</Title>
    <Format>
      p1
      p1 : オプション値
    </Format>
    <Setting>
      CSV検索のオプション設定を行ないます。
      以下の値を指定することができます。複数指定する場合は、「+」か「|」の演算子でつなげることができます。

      CCSV_OPT_ANDMATCH      ;AND検索
      CCSV_OPT_NOCASE        ;半角大文字小文字を同一視
      CCSV_OPT_ZENKAKU       ;全角半角を同一視
      CCSV_OPT_ADDLINE       ;行番号を先頭に付加
      CCSV_OPT_EXPRESSION    ;正規表現を指定(未実装)
    </Setting>
  </command>
  <command>
    <Name>csvfind</Name>
    <Title>CSV検索を実行</Title>
    <Format>
      "string",p1,p2
      "string" : 検索キーワード
      p1       : 結果出力の最大数(0=無制限)
      p2       : 結果出力の開始インデックス(0=先頭)
    </Format>
    <Setting>
      CSV検索を行ないます。
      必ず検索対象のバッファ(csvsel)と出力先(csvres)を指定しておく必要があります。
      "string"で指定されたキーワードを含むCSV行を結果バッファに抽出していきます。
      キーワードは、複数行に渡って(メモリノートパッド形式)指定することができます。
      csvopt命令で AND検索のオプションを入れた場合は、複数キーワードすべてに一致する行だけを取り出します。
      そうでない場合は、複数キーワードのいずれかに一致する行を取り出すOR検索となります。
    </Setting>
  </command>
  <command>
    <Name>rndf_ini</Name>
    <Title>実数乱数の初期化</Title>
    <Format>
      p1
      p1(-1) : 初期化のシード値
    </Format>
    <Setting>
      実数乱数の初期化を行ないます。
      p1で初期化に使用される種(シード値)を指定することができます。
      p1を省略するか、-1を指定するとクロックから得られたランダムなシード値が設定されます。
      プラグインの初期化時に実数乱数の初期化は行なわれるため、必ずしも rndf_ini命令 を入れておく必要はありません。
    </Setting>
  </command>
  <command>
    <Name>rndf_get</Name>
    <Title>実数乱数を取得</Title>
    <Format>
      p1
      p1 : 実数乱数を代入する変数名
    </Format>
    <Setting>
      実数乱数を取得してp1で指定した変数に代入します。
      実数乱数は、 0以上で 1未満の実数となるもので、 Mersenne Twister アルゴリズムにより生成されます。
    </Setting>
  </command>
  <command>
    <Name>rndf_geti</Name>
    <Title>乱数を取得</Title>
    <Format>
      p1,p2
      p1      : 実数乱数を代入する変数名
      p2(100) : 生成する乱数の範囲値
    </Format>
    <Setting>
      整数乱数を取得してp1で指定した変数に代入します。
      乱数は、 0以上でp2で指定した数値未満の整数となります。
      ここで取得される乱数は、 rndf_get で取得される実数乱数と同様のアルゴリズム (Mersenne Twister) により生成されます。
    </Setting>
  </command>
  <command>
    <Name>getvarid</Name>
    <Title>変数IDを取得</Title>
    <Format>
      p1,"name"
      p1 : 結果が代入される変数名
      "name" : 変数名
    </Format>
    <Setting>
      変数名から、変数IDに変換を行ないます。
      変数IDは、HSPシステム内部で管理されている番号で、0から始まる値が割り当てられています。
      結果は、p1で指定された変数に代入されます。
      該当する変数名が存在しなかった場合には、-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>getvarname</Name>
    <Title>変数名を取得</Title>
    <Format>
      p1,p2
      p1 : 結果が代入される変数名
      p2 : 変数ID
    </Format>
    <Setting>
      変数IDから変数名を取得します。
      変数IDは、HSPシステム内部で管理されている番号で、0から始まる値が割り当てられています。
      結果は、p1で指定された変数に代入されます。
      該当する変数IDが存在しなかった場合には、空の文字列("")が代入されます。
    </Setting>
  </command>
  <command>
    <Name>getmaxvar</Name>
    <Title>変数IDの最大数を取得</Title>
    <Format>
      p1
      p1 : 結果が代入される変数名
    </Format>
    <Setting>
      現在利用可能な変数IDの最大数を取得します。
      結果は、p1で指定された変数に代入されます。
      変数IDは、HSPシステム内部で管理されている番号で、0から始まる値が割り当てられています。
      最大数が10の場合、利用可能な変数IDは、0から9となります。
    </Setting>
  </command>
  <command>
    <Name>vsave</Name>
    <Title>すべての変数を保存</Title>
    <Format>
      "filename"
      "filename" : ファイル名
    </Format>
    <Setting>
      定義されているすべての変数データをファイルに保存します。
      "filename"で指定されたファイルが作成されます。
      保存されたファイルは、vload命令またはvload_start命令による変数データ読み込みに使用することができます。
      vsave命令は、すべての変数の内容を配列やモジュール変数も含めて保存しますが、クローンされた変数、comobj型、variant型の変数は対象となりません。
      また、label型の変数の保存が可能ですが、読み込み時に正常なラベル情報にならない可能性があるので注意してください。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vload</Name>
    <Title>すべての変数を読み込み</Title>
    <Format>
      "filename"
      "filename" : ファイル名
    </Format>
    <Setting>
      定義されているすべての変数をファイルから読み込みます。
      "filename"で指定されるファイルは、vsave命令またはvsave_start命令により変数データ保存されている必要があります。
      vload命令は、現在定義されているすべての変数名をファイルに保存されているデータから検索して、名前が一致したものを読み込みます。
      ファイルに保存されていない変数は、そのままの内容を保持します。
      また、モジュール型の変数は、保存した時点とモジュール名、モジュール変数定義数が同じでなければ読み込まれません。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vsave_start</Name>
    <Title>変数保存の開始</Title>
    <Format></Format>
    <Setting>
      個別指定による変数保存を開始します。
      必ず、vsave_start命令により開始した後、vsave_put命令によって必要な変数を指定した後、最後にvsave_end命令を実行する必要があります。
      個別指定による変数保存は、任意の変数データをファイルに保存することができる以外は、vsave命令と同様です。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vsave_put</Name>
    <Title>保存する変数の指定</Title>
    <Format>
      p1
      p1 : 保存する変数
    </Format>
    <Setting>
      個別指定による保存される変数を指定します。
      必ず、vsave_start命令を先に実行しておく必要があります。
      個別指定による変数保存は、任意の変数データをファイルに保存することができる以外は、vsave命令と同様です。
      すべての変数の内容を配列やモジュール変数も含めて保存しますが、クローンされた変数、comobj型、variant型の変数は対象となりません。
      また、label型の変数の保存が可能ですが、読み込み時に正常なラベル情報にならない可能性があるので注意してください。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vsave_end</Name>
    <Title>変数保存の終了</Title>
    <Format>
      "filename"
      "filename" : ファイル名
    </Format>
    <Setting>
      個別指定による変数保存を終了します。
      必ず、vsave_start命令を先に実行しておく必要があります。
      実行されると、"filename"で指定されたファイルが作成されます。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vload_start</Name>
    <Title>変数読み込みの開始</Title>
    <Format>
      "filename"
      "filename" : ファイル名
    </Format>
    <Setting>
      個別指定による変数読み込みを開始します。
      必ず、vload_start命令により開始した後、vload_get命令によって必要な変数を指定した後、最後にvload_end命令を実行する必要があります。
      個別指定による変数読み込みは、任意の変数データをファイルから読み込むことができる以外は、vload命令と同様です。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vload_get</Name>
    <Title>読み込む変数の指定</Title>
    <Format>
      p1
      p1 : 読み込みを行なう変数
    </Format>
    <Setting>
      個別指定によりファイルから読み込まれる変数を指定します。
      必ず、vload_start命令を先に実行しておく必要があります。
      個別指定による変数読み込みは、任意の変数データをファイルから読み込むことができる以外は、vload命令と同様です。
      vload_get命令は、指定された変数名をファイルに保存されているデータから検索して、名前が一致するデータがあった場合に読み込みます。
      ファイルに保存されていない場合は、変数の内容は保持されます。
      また、モジュール型の変数は、保存した時点とモジュール名、モジュール変数定義数が同じでなければ読み込まれません。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>vload_end</Name>
    <Title>変数読み込みの終了</Title>
    <Format></Format>
    <Setting>
      個別指定による変数読み込みを終了します。
      必ず、vload_start命令を先に実行しておく必要があります。
      正常に終了した場合は、システム変数statに0が代入されます。
      正しく処理が完了していない場合、システム変数statは0以外の値になります。
    </Setting>
  </command>
  <command>
    <Name>dbini</Name>
    <Title>ODBCの初期化を行なう</Title>
    <Format></Format>
    <Setting>
      ODBC の初期化を行ないます。 最初に１回だけ必ず実行する必要があります。
      実行後に結果がシステム変数 statに格納されます。
      0ならば正常終了、それ以外はエラーが発生したことを示しています。
    </Setting>
  </command>
  <command>
    <Name>dbbye</Name>
    <Title>HSPDBの終了処理を行なう</Title>
    <Format></Format>
    <Setting>
      HSPDB全体の終了処理を行ないます。
      通常、この命令はプログラム終了時に自動的に呼び出されるため、特にスクリプトに記述する必要はありません。
    </Setting>
  </command>
  <command>
    <Name>dbopen</Name>
    <Title>DBに接続を行なう</Title>
    <Format>
      p1,p2
      p1         : 接続指定文字列
      p2=0〜1(0) : 接続モード
    </Format>
    <Setting>
      接続指定文字列で指定されたDBに接続を開始します。
      接続指定文字列は、「DSN=TEST」 のようなDSN名を指定することができる他、ドライバやファイルなど、各種パラメーターを文字列で記述することが可能です。
      接続指定文字列についての詳細はODBC関連の資料を参考にしてください。
      接続モードが 1の場合は接続確認のためのダイアログがポップアップします。
      接続モードが 0の場合は、指定した文字列のまま接続を行ないます。
      実行後に結果がシステム変数 statに格納されます。0ならば正常終了、それ以外はエラーが発生したことを示しています。
    </Setting>
  </command>
  <command>
    <Name>dbclose</Name>
    <Title>DBの接続を切断する</Title>
    <Format></Format>
    <Setting>dbopen命令によって接続されたDBを切断します。</Setting>
  </command>
  <command>
    <Name>dbstat</Name>
    <Title>現在の状態を得る</Title>
    <Format></Format>
    <Setting>
      現在の接続状態などをシステム変数 statに代入します。

      stat : 状態
      -------------------------
      1  : エラーが発生
      2  : 切断中
      3  : 接続中
      4  : SQL応答待ち
    </Setting>
  </command>
  <command>
    <Name>dbspchr</Name>
    <Title>区切り文字を指定する</Title>
    <Format>
      p1
      p1 : 0〜255 : 文字コード
    </Format>
    <Setting>
      dbgets命令で取得される結果の項目を区切るための文字を設定します。
      通常は「,」で項目が区切られますが、 別な文字にしたい場合に設定を行なって下さい。たとえば、「dbspchr 9」を指定した場合はTABコードが区切り文字になります。
    </Setting>
  </command>
  <command>
    <Name>dbsend</Name>
    <Title>SQL文字列を送信する</Title>
    <Format>
      "..."
      "..." : SQL文字列
    </Format>
    <Setting>
      接続したDBにSQLの文法によるコントロール文字列を送信します。
      実行後に結果が、システム変数 statに格納されます。0ならば正常終了、それ以外はエラーが発生したことを示しています。
      正常終了した場合は、dbgets命令で結果を取得することができます。
    </Setting>
  </command>
  <command>
    <Name>dbgets</Name>
    <Title>結果文字列を取得する</Title>
    <Format>
      p1
      p1 : 結果の文字列が代入される変数名
    </Format>
    <Setting>
      dbsend命令により送信されたSQL文字列に対する結果を取得します。
      p1に、結果文字列が代入される変数名を指定する必要があります。

      p1で指定された変数は強制的に文字列型になり、変数バッファのサイズが許す限りデータを受け取ります(バッファがオーバーフローすることはありません)
      実行後に結果がシステム変数statに格納されます。 0ならば正常にデータを受け取ったことを示しています。 1の場合は、結果の取得中にエラーが発生したことを示しています。2の場合は、 これ以上受け取るべきデータがないことを示しています。

      データを取得する場合は、大きなデータを何度にも分けて取得する可能性もあるため、システム変数statの内容が0だった場合は、 再度dbgetsを実行して最後までデータを受け取るまでループさせるようにしてください。
    </Setting>
  </command>
  <command>
    <Name>gmode_sub</Name>
    <Title>色減算合成コピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードを色減算合成コピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_add</Name>
    <Title>色加算合成コピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードを色加算合成コピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_gdi</Name>
    <Title>通常のコピーモード</Title>
    <Format></Format>
    <Setting>
      gmodeの第1引数に指定することで、画面コピーモードを通常のコピーモードに設定できます。
      省略しても同じ結果が得られますので、省略しても構いません。
    </Setting>
  </command>
  <command>
    <Name>gmode_rgb0</Name>
    <Title>透明色付きコピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードを透明色付きコピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_mem</Name>
    <Title>メモリ間コピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードをメモリ間コピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_alpha</Name>
    <Title>半透明合成コピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードを半透明合成コピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_rgb0alpha</Name>
    <Title>透明色付き半透明合成コピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードを透明色付き半透明合成コピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>gmode_pixela</Name>
    <Title>ピクセルアルファブレンドコピーモード</Title>
    <Format></Format>
    <Setting>gmodeの第1引数に指定することで、画面コピーモードをピクセルアルファブレンドコピーモードに設定できます。</Setting>
  </command>
  <command>
    <Name>objinfo_mode</Name>
    <Title>モードおよびオプションデータを取得</Title>
    <Format>
      (p1)
      p1=0〜 : ウィンドウオブジェクトID
    </Format>
    <Setting>指定したウィンドウオブジェクトのモードおよびオプションデータを返します。</Setting>
  </command>
  <command>
    <Name>objinfo_bmscr</Name>
    <Title>オブジェクトが配置されているBMSCR構造体のポインタを取得</Title>
    <Format>
      (p1)
      p1=0〜 : ウィンドウオブジェクトID
    </Format>
    <Setting>指定したウィンドウオブジェクトが配置されているBMSCR構造体のポインタを返します。</Setting>
  </command>
  <command>
    <Name>objinfo_hwnd</Name>
    <Title>ウィンドウオブジェクトのハンドルを取得</Title>
    <Format>
      (p1)
      p1=0〜 : ウィンドウオブジェクトID
    </Format>
    <Setting>指定したウィンドウオブジェクトのハンドルを返します。</Setting>
  </command>
  <command>
    <Name>screen_normal</Name>
    <Title>通常のウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、通常のウィンドウを作成できます。
      省略しても同じ結果が得られますので、省略しても構いません。
    </Setting>
  </command>
  <command>
    <Name>screen_palette</Name>
    <Title>パレットモードのウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、パレットモードのウィンドウを作成できます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>screen_hide</Name>
    <Title>非表示のウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、非表示のウィンドウを作成できます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>screen_fixedsize</Name>
    <Title>サイズ固定ウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、サイズ固定のウィンドウを作成できます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>screen_tool</Name>
    <Title>ツールウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、ツールウィンドウを作成できます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>screen_frame</Name>
    <Title>深い縁のあるウィンドウを作成</Title>
    <Format></Format>
    <Setting>
      screen命令の第4引数に指定することで、深い縁のあるウィンドウを作成できます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>font_normal</Name>
    <Title>通常のスタイルでフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、通常のスタイルでフォントを設定することができます。
      省略しても同じ結果が得られますので、省略しても構いません。
    </Setting>
  </command>
  <command>
    <Name>font_bold</Name>
    <Title>太文字でフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、太文字のフォントを設定することができます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>font_italic</Name>
    <Title>イタリック体でフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、イタリック体のフォントを設定することができます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>font_underline</Name>
    <Title>下線付きでフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、下線付きのフォントを設定することができます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>font_strikeout</Name>
    <Title>打ち消し線付きでフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、打ち消し線付きのフォントを設定することができます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>font_antialias</Name>
    <Title>アンチエイリアスでフォント設定</Title>
    <Format></Format>
    <Setting>
      font命令の第3引数に指定することで、アンチエイリアスのフォントを設定することができます。
      他のマクロと組み合わせて指定する場合は、その和または論理和を指定してください。
    </Setting>
  </command>
  <command>
    <Name>objmode_normal</Name>
    <Title>HSP標準フォントを設定</Title>
    <Format></Format>
    <Setting>
      objmode命令の第1引数に指定することで、オブジェクト制御命令で使用されるフォントをHSP標準フォントに設定することができます。
      省略しても同じ結果が得られますので、省略しても構いません。
    </Setting>
  </command>
  <command>
    <Name>objmode_guifont</Name>
    <Title>デフォルトGUIフォントを設定</Title>
    <Format></Format>
    <Setting>objmode命令の第1引数に指定することで、オブジェクト制御命令で使用されるフォントをデフォルトGUIフォントに設定することができます。</Setting>
  </command>
  <command>
    <Name>objmode_usefont</Name>
    <Title>font命令で選択されているフォントを設定</Title>
    <Format></Format>
    <Setting>objmode命令の第1引数に指定することで、オブジェクト制御命令で使用されるフォントをfont命令で選択されているフォントに設定することができます。</Setting>
  </command>
  <command>
    <Name>msgothic</Name>
    <Title>MSゴシックフォント</Title>
    <Format></Format>
    <Setting>
      MSゴシックを示すフォントを示すキーワードです。
      font命令で指定するフォント名として使用することができます。
    </Setting>
  </command>
  <command>
    <Name>msmincho</Name>
    <Title>MS明朝フォント</Title>
    <Format></Format>
    <Setting>
      MS明朝を示すフォントを示すキーワードです。
      font命令で指定するフォント名として使用することができます。
    </Setting>
  </command>
  <command>
    <Name>and</Name>
    <Title>論理積(演算子)</Title>
    <Format></Format>
    <Setting>論理積を示す演算子「&amp;」と同様に使用することができるマクロです。</Setting>
  </command>
  <command>
    <Name>or</Name>
    <Title>論理和(演算子)</Title>
    <Format></Format>
    <Setting>論理和を示す演算子「|」と同様に使用することができるマクロです。</Setting>
  </command>
  <command>
    <Name>xor</Name>
    <Title>排他的論理和(演算子)</Title>
    <Format></Format>
    <Setting>排他的論理和を示す演算子「」と同様に使用することができるマクロです。</Setting>
  </command>
  <command>
    <Name>not</Name>
    <Title>否定(演算子)</Title>
    <Format></Format>
    <Setting>否定を示す演算子「!」と同様に使用することができるマクロです。</Setting>
  </command>
  <command>
    <Name>M_PI</Name>
    <Title>円周率</Title>
    <Format></Format>
    <Setting>円周率を表す定数です。3.14159265358979323846が定義されています。</Setting>
  </command>
  <command>
    <Name>rad2deg</Name>
    <Title>ラジアンを度に変換</Title>
    <Format>
      (p1)
      p1 : 度に変換する角度（ラジアン）
    </Format>
    <Setting>
      角度の単位をラジアンから度へ変換します。
      弧度法で表された角度を度数法での角度に変換するとも言えます。
    </Setting>
  </command>
  <command>
    <Name>deg2rad</Name>
    <Title>度をラジアンに変換</Title>
    <Format>
      (p1)
      p1 : ラジアンに変換する角度（度）
    </Format>
    <Setting>
      角度の単位を度からラジアンへ変換します。
      度数法で表された角度を弧度法での角度に変換するとも言えます。
    </Setting>
  </command>
  <command>
    <Name>es_xfer</Name>
    <Title>バッファ間画像コピー</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=転送先DirectXバッファID(-2〜)
      p2=転送元DirectXバッファID(-2〜)
      p3=コピー元X座標
      p4=コピー元Y座標
      p5=コピーするXサイズ
      p6=コピーするYサイズ
    </Format>
    <Setting>
      es_copy命令と同じく画像イメージのコピーを行ないますが、 コピー先を画面上だけではなく、別なバッファなども指定することができます。
      p1で指定したバッファIDに、p2で指定したバッファIDのイメージを転送します。
      pos命令で指定した座標に、(p5,p6)のサイズとgmodeで指定したモードで、(p3,p4)の座標から画像がコピーされます。
      p5,p6を省略した場合、gmodeで指定したサイズでコピーを行います。
      es_copy命令の頭に、 転送先のバッファIDが付加されたものと考えてください。
      p1とp2のバッファ指定は、オフスクリーンバッファIDの他にも以下の値が使用できます。

      DirectXバッファID = -1 : 現在表示中の画面イメージ
      DirectXバッファID = -2 : 現在描画中の画面イメージ

      es_copy命令では、転送先が-2にあたります。
      この命令を実行する際、 コピー先のバッファはあらかじめes_buffer命令によって確保されている必要があります (この命令でバッファを新規に作成することはできません)。
    </Setting>
  </command>
  <command>
    <Name>es_dist</Name>
    <Title>2点間距離算出</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=結果を代入する変数
      p2,p3=点Aの座標
      p4,p5=点Bの座標
    </Format>
    <Setting>(p2,p3)から(p4,p5)までの距離を求め、変数p1に代入します。計算結果は小数部8bitの固定小数です。</Setting>
  </command>
  <command>
    <Name>es_set</Name>
    <Title>スプライト設定</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=スプライトNo.
      p2=スプライトX座標
      p3=スプライトY座標
      p4=キャラクタNo.
      p5=描画モード(0=DirectDraw、1=Direct3D)
      p6=優先順位(-32768〜32767)
    </Format>
    <Setting>
      スプライトを登録します。
      p1は、スプライトNo.(0〜511)、(p2,p3)は画面上でのスプライトの座標になります。
      この座標を左上として、p4で指定したキャラクタNo.が表示されます。
      スプライト座標は、-32767〜32767までの範囲が設定可能です。

      p5で描画方法を選択します。es_effectでのエフェクトを使用する時は1に設定します。
      このパラメータは、 Direct3Dが使えない場合は強制的に0になり、使える場合は1がデフォルトになります。

      p6でスプライトの優先順位を指定します。優先順位は値が小さいほど手前に表示されるようになり、同一値の場合はスプライトの小さい方が優先されます。
      また、 従来通りスプライトNo.の小さい順に描画するようにすることもできます。
    </Setting>
  </command>
  <command>
    <Name>es_blink</Name>
    <Title>スプライト点滅設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.
      p2=点滅フラグ(1〜3)
      p3=点滅カウント初期値(-1or1〜)
    </Format>
    <Setting>
      点滅フラグ=1 : 点滅無し、カウントが0になったらスプライトを消滅させる
      点滅フラグ=2 : 点滅あり、カウントが0になったら点滅をやめる
      点滅フラグ=3 : 点滅あり、カウントが0になったらスプライトを消滅させる

      スプライトの点滅を設定します。 これまでes_flag命令で設定していたものを独立・拡張した命令です。
      ここでの設定は es_flag命令を実行するとリセットされます。
      p3に-1を設定すると、カウントは無限になります。
    </Setting>
  </command>
  <command>
    <Name>es_palfade</Name>
    <Title>パレットフェード</Title>
    <Format>
      p1,p2,p3
      p1=フェード値(-256〜256)
      p2=フェードするスピード(0〜128)
      p3=フェードする色(Direct3D使用時のみ)
    </Format>
    <Setting>
      p1で画像の明るさを設定します。 p1が0の時が通常(設定パレットのまま)です。
      p1がマイナス値になるほど画像は暗くなり、プラス値になるほど明るくなります。p1が-256で完全な黒になり、256で完全な白になります。

      p2でフェードのスピードを指定することができます。 p2を省略するか、0の場合はes_palfade命令が実行されるとすぐにp1の指定が反映されます。
      1〜128の場合は、現在設定されている値からp1で指定した値までなめらかに変化します。指定した数値が大きいほど変化のスピードは速くなります。

      画面モードが16bit以上の時、 Direct3D使用時にこの命令でフェードイン・アウトができます。この場合はフェード値の正負に関係なくp3で指定した色でフェードを行います。p3は16進数6桁のRGB値で指定します。
    </Setting>
  </command>
  <command>
    <Name>es_buffer</Name>
    <Title>VRAMイメージ転送</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=オフスクリーンバッファID(0〜63)
      p2=属性スイッチ(0〜2)
      p3=透明色(パレットモード時:-1〜255、ハイカラー以上:-1〜$ffffff)
      p4=パレットモード時の転送方法(0〜2)
      p5=テクスチャ使用フラグ(0〜1)
    </Format>
    <Setting>
      属性スイッチ=0 : オフスクリーンバッファをVRAMに取る、
      失敗した場合は、メインメモリに取る
      属性スイッチ=1 : オフスクリーンバッファをメインメモリに取る
      属性スイッチ=2 : オフスクリーンバッファをVRAMに取る

      p4=0 : バッファ転送時にパレットを更新する
      p4=1 : パレットを更新しない
      p4=2 : DirectX側のパレットに色を合わせて転送する

      現在gsel命令で選択されているHSPのバッファ内容を、DirectXのオフスクリーンバッファにすべて転送します。
      この時、パレットも読み出されDirectX側のパレットに転送されます。
      オフスクリーンバッファに転送できる最大画像サイズは、グラフィックボードによって異なり、主に

      1.縦横ともに画面解像度以上のサイズで作成できる
      2.横は画面解像度と同サイズまで、縦はそれ以上のサイズで作成できる
      3.縦横ともに画面解像度と同サイズまで

      の3通りとなっています。

      p3にはes_copy命令などで透明色として使う色を指定します。
      パレットモードでは0〜255までのパレット番号を直接指定するほかに、-1を指定することで完全な黒(RGB=0) でパレット番号が一番若いパレットを自動的に透明色に設定します。
      ハイカラー以上では透明色に指定するRGB値を $rrggbbの16進数6桁で設定します。たとえば、$00ff00と指定することでRGB=(0,255,0)の色が透明色になります。 -1を指定した場合、(0,0)のドットの色を読み取り、透明色に設定されます。

      HSP側のバッファは、DirectXがパレットモードの時は同じくパレットモードで初期化されていないと正常に転送されませんが、ハイカラー以上の場合はパレット・フルカラーモードどちらでも転送されます。
      オフスクリーンバッファへの転送が成功した場合には、システム変数statの値は0になります。転送に失敗すると、statの値は1になります。転送に失敗する場合は、転送する画像が大きすぎるか、VRAMの容量が足りないことなどが考えられます。自分の環境では動作していても、別のマシンではエラーになる可能性がありますので、スクリプト側でチェックをするように心がけてください。

      すでに転送済みのオフスクリーンバッファIDを指定した場合には、一度その内容が削除され、新しいものに上書きされます。

      p5に0を指定することで、 このバッファをテクスチャとして使用しないようにできます。 そうすると、このバッファに対してes_excopy命令でコピーを行うことができなくなりますが、DirectDrawでの描画を行う場合にパフォーマンスが大きく低下するのを防げます。

      バッファをテクスチャとして使用する場合、　グラフィックボードによっては256ドットを越える画像や、サイズが2の累乗でない画像を転送できない物があります。なるべく多くの環境で正常に動作することを期待するのであれば、これらを守る必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_exboxf</Name>
    <Title>Direct3Dによる矩形描画</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
      p1,p2=塗りつぶし左上座標　　　　　 p11,12,13=各頂点色(順に右上、左下、右下)
      p3,p4=塗りつぶし右下座標
      p5=塗りつぶし色もしくは左上頂点色
      p6,p7,p8=回転角
      p9=ブレンドファクター
      p10=α値
    </Format>
    <Setting>
      (p1,p2)-(p3,p4)の矩形範囲をp5の色で塗りつぶします。 p5は16進数6桁でRGB値を指定します。
      p3,p4を省略するとgmode命令のサイズで塗りつぶしを行い、　p5を省略するとcolor命令で指定した色を使用します。

      p11〜13は矩形の各頂点に別々の色を指定するためのパラメータです。 頂点色を変更すると頂点から中央に向かってグラデーションがかかった表示になります。

      この命令を使用するには、Direct3D描画を有効にする必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_bye</Name>
    <Title>システム解放</Title>
    <Format></Format>
    <Setting>
      HSPDXFIX.DLLシステムの切り離しをします。
      画面モードをウインドゥモードに戻し、確保されていたメモリをすべて解放します。
      これは、クリーンアップ関数としてHSP終了時に自動的に呼び出されます。
    </Setting>
  </command>
  <command>
    <Name>es_caps</Name>
    <Title>DirectXシステム情報取得</Title>
    <Format>
      p1,p2,p3,p4
      p1=情報が代入される変数名(数値型)
      p2=情報ID
      p3=情報ビット(1〜32)
      p4=対象となるレイヤー( 0=HAL / 1=HEL )
    </Format>
    <Setting>
      DirectXのドライバがどのような機能を持っているかを調べて、 結果をp1で指定する変数に代入します。

      p2の情報IDと、p3の情報ビットについての詳細は、hspdx.txtのDDCAPS一覧を参照してください。
    </Setting>
  </command>
  <command>
    <Name>es_palset</Name>
    <Title>パレット変更</Title>
    <Format>
      p1,p2,p3,p4
      p1=パレット番号(0〜255)
      p2=設定するR値(0〜255)
      p3=設定するG値(0〜255)
      p4=設定するB値(0〜255)
    </Format>
    <Setting>
      パレットの色を設定します。p1で指定したパレット番号に、p2,p3,p4がそれぞれR,G,Bとなる色を設定します。

      es_palset命令による設定変更は、命令実行時すぐには反映されません。
      実際に設定が反映されるのは、 次にes_sync命令かes_palfade命令が実行される時になります。
    </Setting>
  </command>
  <command>
    <Name>es_boxf</Name>
    <Title>矩形塗りつぶし</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=塗りつぶし左上X座標
      p2=塗りつぶし左上Y座標
      p3=塗りつぶし右下X座標
      p4=塗りつぶし右下Y座標
      p5=描画先バッファNo.
    </Format>
    <Setting>
      (p1,p2)-(p3,p4)の矩形範囲を現在選択されている色で塗りつぶします。
      色の選択は、color命令で行ないます。
    </Setting>
  </command>
  <command>
    <Name>es_fill</Name>
    <Title>矩形塗りつぶし</Title>
    <Format>
      p1,p2,p3,p4
      p1=塗りつぶし左上X座標
      p2=塗りつぶし左上Y座標
      p3=塗りつぶす色のパレット番号(0〜255)
      p4=描画先バッファNo.
    </Format>
    <Setting>
      es_boxf命令と同じく指定した矩形範囲を塗りつぶすための命令です。
      異なる点は、es_fill命令では、塗りつぶす色をパレット番号あるいはRGB値で指定することです。

      塗りつぶす大きさ(サイズ)は、gmode命令で指定したサイズになります。
      (p1,p2)からgmode命令で指定した矩形範囲を指定したパレットで塗りつぶします。es_boxf命令よりも速度の面で有利です。
    </Setting>
  </command>
  <command>
    <Name>es_cls</Name>
    <Title>画面クリア</Title>
    <Format>
      p1,p2,p3
      p1=画面クリア時のR値
      p2=画面クリア時のG値
      p3=画面クリア時のB値
    </Format>
    <Setting>
      この命令は、画面全体を指定した色でクリアします。
      p1,p2,p3でクリアする色をRGBコードで指定可能です。
      パレットモードでは、 指定したRGBに最も近い色を持つパレットでクリアされます。
      p1,p2,p3の指定を省略すると、黒でクリアします。
    </Setting>
  </command>
  <command>
    <Name>es_put</Name>
    <Title>キャラクタ画面表示</Title>
    <Format>
      p1,p2,p3
      p1=putする左上X座標
      p2=putする左上Y座標
      p3=putするキャラクタNo.
    </Format>
    <Setting>
      スプライト用のキャラクタパターンとして登録されているデータを、指定した座標に表示します。
      この命令は、スプライトとは関係なく画面にキャラクタを転送する命令です。
    </Setting>
  </command>
  <command>
    <Name>es_window</Name>
    <Title>スプライト表示エリア設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=スプライト表示基点X座標
      p2=スプライト表示基点Y座標
      p3=スプライトを表示するX座標
      p4=スプライトを表示するY座標
    </Format>
    <Setting>
      この命令により、スプライトを画面内の限られた範囲内にのみ表示することが可能です。指定した範囲内がスプライトの表示エリアになります。

      スプライト以外の描画命令には、この範囲は適用されません。
    </Setting>
  </command>
  <command>
    <Name>es_area</Name>
    <Title>スプライト有効エリア設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=有効エリアの左上X座標
      p2=有効エリアの左上Y座標
      p3=有効エリアの右下X座標
      p4=有効エリアの右下Y座標
    </Format>
    <Setting>
      スプライトの有効エリアを設定します。
      スプライト座標が(p1,p2)-(p3,p4)の範囲内にないものは、 自動的に削除されます。

      スプライトの表示範囲が設定されると(es_window命令)自動的に、 スプライト有効エリアも再設定されます。
    </Setting>
  </command>
  <command>
    <Name>es_find</Name>
    <Title>スプライト検索</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=スプライトNo.が代入される変数名
      p2=検索対象となるtype値
      p3=検索を開始するスプライトNo.
      p4=検索を終了するスプライトNo.
      p5=増分
    </Format>
    <Setting>
      登録されているスプライトの中で指定したtype値を持つスプライトNo. を検索します。
      p2のtype値には、複数のtypeを同時に指定することができます。
      たとえば、type1とtype4を対象にする場合は、1+4で5を指定します。

      p2の指定を省略するか、 0を指定した場合にはすべてのtype値を持つスプライトが検索の対象になります。

      検索は、p3で指定されたスプライトNo.からp4で指定されたNo.まで順番に探していきます。
      これを省略すると、No.0からすべてのスプライトを検索します。
      該当するスプライトが見つかった時点で、p1に結果を代入して終わります。
      検索の結果、該当するスプライトがなかった場合には、-1が代入されます。

      p5は検索するスプライトNo.の増分を指定するもので、 省略するとp3、p4から自動的に設定されますので通常は指定しなくても構いません。
    </Setting>
  </command>
  <command>
    <Name>es_size</Name>
    <Title>キャラクタサイズ指定</Title>
    <Format>
      p1,p2,p3,p4
      p1=キャラクタのXサイズ
      p2=キャラクタのYサイズ
      p3=ヒットチェック領域(%)
      p4=不透明フラグ( 0=透明 / 1=不透明 )
    </Format>
    <Setting>
      スプライトのキャラクタパターンを定義する際の、サイズを指定します。
      (p1,p2)がキャラクタのX,Yサイズになります。

      p3は当たり判定を行なう際のヒットチェック領域が、 何%になるかを指定します。100を指定すると、(p1,p2)で指定したサイズいっぱいにヒットチェックを行ないます。 0を指定すると、そのキャラクタは当たり判定を持たなくなります。
      p4は、0ならば透明色を透過し、1ならば不透明のキャラクタパターンになります。

      キャラクタのX,Yサイズには特に制限はありませんが、 オフスクリーンバッファからはみ出すようなキャラクタパターンの指定は無効になります。es_size命令の設定は、以降のキャラクタ定義でずっと有効になります。
    </Setting>
  </command>
  <command>
    <Name>es_link</Name>
    <Title>アニメーション設定</Title>
    <Format>
      p1,p2
      p1=キャラクタNo.
      p2=ループアニメーションするキャラクタNo.
    </Format>
    <Setting>
      キャラクタのループアニメーションを設定するための命令です。
      p1で指定したキャラクタNo.が、指定されたフレームだけ表示した後に、 p2で指定したキャラクタNo.に戻るように設定を行ないます。
    </Setting>
  </command>
  <command>
    <Name>es_check</Name>
    <Title>衝突判定取得</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=結果が代入される変数名
      p2=チェックの対象となるスプライトNo.
      p3=検索対象となるtype値
      p4=判定フラグ(0=回転を考慮しない、1=回転を考慮する)
      p5=検索を開始するスプライトNo.
      p6=検索を終了するスプライトNo.
    </Format>
    <Setting>
      スプライト同士の衝突判定を行ないます。

      p2で指定されたスプライトNo.と衝突している(重なっている) スプライトを検索して、p1で指定した変数に結果を代入します。

      p3で衝突判定の対象となるtype値を指定することができます。
      p3が省略されるか、 0の場合は、すべてのスプライトとの衝突を判定します。
      p3のtype値には、複数のtypeを同時に指定することができます。
      たとえば、type1とtype4を対象にする場合は、1+4で5を指定します。

      衝突判定には、キャラクタパターンを登録した時に指定したヒットチェック領域(%)が使用されます。 実際に画像が重なっていても、ヒットチェック領域の範囲が重ならない限りは衝突とみなされません。

      結果はp1で指定した変数に代入されます。もし、衝突しているスプライトがなかった場合には-1が、 衝突しているスプライトがあれば、そのスプライトNo.が代入されます。衝突しているスプライトが複数あった場合には、スプライトNo.の小さいものが優先されます。

      es_effect命令を使ってスプライトを回転表示した場合、 そのままだと回転していない状態での衝突判定を行ってしまいます。そこで、es_check命令実行時にp4に 1を指定することでスプライトの回転を当たり判定に反映させることができるようになります。

      p5,p6で衝突判定を検索するスプライトの始点・終点を指定できます。 p5がp6より大きなスプライトNo.を指定した場合、通常とは逆に小さいスプライトNo.に向かって検索を行います。
    </Setting>
  </command>
  <command>
    <Name>es_offset</Name>
    <Title>オフセット座標設定</Title>
    <Format>
      p1,p2
      p1=オフセットX値
      p2=オフセットY値
    </Format>
    <Setting>
      すべてのスプライトの表示を、オフセット値で指定した数だけずらして表示します。
      この命令で設定したオフセット値は、 es_draw命令で描画を行なった時に反映されます。
    </Setting>
  </command>
  <command>
    <Name>es_flag</Name>
    <Title>flag値設定</Title>
    <Format>
      p1,p2
      p1=スプライトNo.
      p2=flag値
    </Format>
    <Setting>
      p1で指定したスプライトのflag値を変更します。
      flag値は、スプライトが有効になっている場合は、 $100(256)が自動的に設定されています。通常は特にいじる必要はありません。

      flag値=
      0    :  スプライト未登録
      bit 0-6 : 1〜127 カウントダウンタイマー
      bit 7   : カウントダウン消失SWITCH
      bit 8 :  $100 スプライト表示ON
      bit 9 :  $200 スプライト移動ON
      bit10 :  $400 自由落下移動ON
      bit11 :  $800 BGとリンクして移動(未実装)
      bit12 : $1000 ボーダー消去無効ON
      bit13 : $2000 ボーダーXで反転SWITCH
      bit14 : $4000 ボーダーYで反転SWITCH
      bit15 : $8000 カウントダウンタイマー時点滅SWITCH
    </Setting>
  </command>
  <command>
    <Name>es_chr</Name>
    <Title>chr値設定</Title>
    <Format>
      p1,p2
      p1=スプライトNo.
      p2=キャラクタNo.
    </Format>
    <Setting>p1で指定したスプライトのキャラクタNo.を変更します。</Setting>
  </command>
  <command>
    <Name>es_type</Name>
    <Title>type値設定</Title>
    <Format>
      p1,p2
      p1=スプライトNo.
      p2=type値
    </Format>
    <Setting>
      p1で指定したスプライトのtype値を変更します。
      type値についての詳細は、 hspdx.txtの「type値の設定について」を参照してください。
    </Setting>
  </command>
  <command>
    <Name>es_kill</Name>
    <Title>スプライト削除</Title>
    <Format>
      p1
      p1=スプライトNo.
    </Format>
    <Setting>p1で指定したスプライトNo.を削除します。</Setting>
  </command>
  <command>
    <Name>es_clear</Name>
    <Title>複数スプライト削除</Title>
    <Format>
      p1,p2
      p1=スプライトNo.
      p2=削除される個数
    </Format>
    <Setting>
      p1で指定したスプライトNo. 以降のスプライトが削除され未登録になります。
      p2で削除されるスプライトの数を指定することができます。
      p1とp2の指定を省略した場合は、すべてのスプライトが削除されます。
    </Setting>
  </command>
  <command>
    <Name>es_pos</Name>
    <Title>スプライト座標設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.
      p2=スプライトX座標
      p3=スプライトY座標
    </Format>
    <Setting>
      スプライトの座標を変更します。
      p1でスプライトNo.を指定して、(p2,p3)でX,Y座標を設定します。

      es_posは、設定済みのスプライトの座標だけを変更する命令です。
    </Setting>
  </command>
  <command>
    <Name>es_apos</Name>
    <Title>スプライト移動設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=スプライトNo.
      p2=1フレームにX方向に移動するドット数
      p3=1フレームにY方向に移動するドット数
      p4=移動スピード(%)
    </Format>
    <Setting>
      スプライトを自動的に移動させるための設定をします。
      p1でスプライトNo.、p2,p3でX,Y方向の増分を指定します。

      p4で移動スピードを%で指定します。p4を省略するか、100を指定した場合は、100%のスピードとなり、1フレームに(p2,p3)で指定した増分だけ移動し続けます。
      もし、移動スピードを50(%)にして、増分が(+4,-2)に指定された場合は、実際には、(+2,-1)の増分になります。
      増分の単位は、1ドット以下になった場合でも正確に移動を行ないます。 たとえば、1フレームに(1,0)の移動を10%で行なった場合でも、10フレーム後に1ドット移動するように計算されます。
    </Setting>
  </command>
  <command>
    <Name>es_sync</Name>
    <Title>画面更新とウェイト</Title>
    <Format>
      p1,p2
      p1=ウェイト時間(ms)
      p2=VSync待ちフラグ
    </Format>
    <Setting>
      p2=0 : VSyncを待つ
      p2=1 : VSyncを待たずにフリップする
      p2=2 : VSyncを待たずにBltで裏画面の内容を表画面にコピーする

      描画された画面を更新するとともに、 以前のes_sync命令実行時から経過した時間を測定して、システム変数statに返します。

      p1で、最低でも何msのウェイトを取るかを指定することができます。
      p1を省略するか、0を指定した場合は最低ウェイト時間はなくなります。
      es_sync命令は、垂直帰線(VSync)を待って画面を更新します。
      つまり、最低でも以前es_sync命令が呼ばれてから、1フレーム分の時間はウェイトが取られます。

      1フレーム分の時間は、 モニタに出力されている映像周波数にもよりますが、多くの場合1/60秒程度になっています。これは、多くのビデオゲームや家庭用ゲーム機が画面更新しているサイクルと同じです。
      通常は、es_sync命令のみでウェイトの指定をしなくても、 約1/60秒ごとのウェイトとなります。プログラムの処理が多かったり、画面の書き換えに要する時間が多くなると、 更新が1フレームごとに行なわれなくなる時が出てきて、動きがガタガタとしたぎこちない、いわゆる「処理落ち」の状態になります。
      このような時は、最低ウェイト時間を入れて、 画面の更新を2フレームごとにするなどして対処することができます。

      また、p1にマイナスの値を入れることで前回の実行で取りすぎたウェイトをできるだけ取り戻すようにすることもできます。 FPSが安定しない場合はこちらを使うことで改善されるかもしれません。

      先述の通り、 es_sync命令はVSyncを待ってウェイトを取りますが、p2に1または2を指定するとVSyncを待たずに画面を更新することができます。これによりリフレッシュレート以上の速度でウェイトを取ることができますが、画面がブレたりちらつきが発生しますので、普段は指定する必要はありません。
      なお、ウィンドウモードでは基本的にVSyncは待ちませんので、 ウィンドウモードで動かすときは必ずウェイトを設定して下さい。

      p2でVSyncを待たない場合の画面の切り替え方法を選択できます。1の場合は単に表示する画面を切り替えるだけなので処理は一瞬で行われますがグラフィックボードによってはサポートしていない場合があり、 2の場合はすべての環境で動作しますが1の時に比べて多少切り替えが遅くなります。

      es_sync命令を実行した後には、 システム変数statに経過時間が代入されています。これはプログラムの実行にかかっている時間を計測する最も簡単な手段です。この数値がそのままベンチマークとなります。
    </Setting>
  </command>
  <command>
    <Name>es_aim</Name>
    <Title>スプライト参照座標設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=スプライトNo.
      p2=移動先のX座標
      p3=移動先のY座標
      p4=移動スピード(%)
    </Format>
    <Setting>
      es_aim命令は、 es_adir命令と同じく指定した方向にスプライトを移動させるためのものです。
      es_aim命令では、方向の替わりに移動する目標となるX,Y座標を指定します。スプライトは、現在の座標から、目標となる座標への方向を計算し移動を開始します。

      この命令は、たとえば敵から発射されるミサイルがプレイヤーを狙って移動するようにしたい時などに役立ちます。

      p4で移動スピードを%で指定します。 p3を省略するか、100(%)を指定した場合には、指定した方向に1フレームにつき1ドットの距離を移動します。

      この命令を実行するとシステム変数statに移動方向が返ります。
      これを利用して自機を狙う3方向弾などを作成することができます。
    </Setting>
  </command>
  <command>
    <Name>es_ang</Name>
    <Title>角度取得</Title>
    <Format>
      p1,p2,p3,p4
      p1=基準点のX座標
      p2=基準点のY座標
      p3=目的点のX座標
      p4=目的点のY座標
    </Format>
    <Setting>
      システム変数statに(p1,p2)から見た(p3,p4)の方向が返ります。
      es_aimを使っても方向を得ることはできますが、この命令を使えばスプライトを使わずに方向を得ることができます。
    </Setting>
  </command>
  <command>
    <Name>es_getfps</Name>
    <Title>FPS取得</Title>
    <Format>
      p1
      p1=結果が代入される変数名
    </Format>
    <Setting>1秒間にes_sync命令が実行された回数を、p1で指定した変数に代入します。</Setting>
  </command>
  <command>
    <Name>es_palcopy</Name>
    <Title>パレット転送</Title>
    <Format></Format>
    <Setting>現在gsel命令で選択されているHSP側のバッファのパレットをDirectX側のパレットに転送します。</Setting>
  </command>
  <command>
    <Name>es_get</Name>
    <Title>スプライト情報取得</Title>
    <Format>
      p1,p2,p3
      p1=情報が代入される変数名
      p2=スプライトNo.
      p3=info number
    </Format>
    <Setting>
      p1で指定した変数名に、p2のスプライトNo.の情報を代入します。
      情報の種類は、p3のinfo numberで指定します。
      []内はヘッダファイルで定義されている定数です。

      info number :
      0 = flag値                                    [ESI_FLAG_LOW]
      3 = スプライトのX座標                         [ESI_POSX_INT]
      5 = スプライトのY座標                         [ESI_POSY_INT]
      7 = 1フレームに移動する距離X                  [ESI_SPDX_INT]
      9 = 1フレームに移動する距離Y                  [ESI_SPDY_INT]
      10 = プログレスカウント値(未使用)              [ESI_PRGCOUNT]
      11 = アニメーションカウント値                [ESI_ANIMECOUNT]
      12 = キャラクタNo.                                [ESI_CHRNO]
      13 = type値                                        [ESI_TYPE]
      14,15 = 特殊動作情報(未使用)                   [ESI_EXECPTR_LOW,
      ESI_EXECPTR_HIGH]
      16 = 自由落下加速度X                             [ESI_ACCELX]
      17 = 自由落下加速度Y                             [ESI_ACCELY]
      18 = 弾みやすさ                               [ESI_BOUNCEPOW]
      19 = バウンドフラグ                          [ESI_BOUNCEFLAG]
      20 = 点滅フラグ                               [ESI_BLINKFLAG]
      22,23 = 点滅カウント値                      [ESI_BLINKCOUNT_LOW,
      ESI_BLINKCOUNT_HIGH]
      24 = Direct3D使用フラグ                         [ESI_D3DFLAG]
      25 = 表示Xサイズ                                  [ESI_DISPX]
      26 = 表示Yサイズ                                  [ESI_DISPY]
      27 = X軸回転角                                     [ESI_ROTX]
      28 = Y軸回転角                                     [ESI_ROTY]
      29 = Z軸回転角                                     [ESI_ROTZ]
      30 = ブレンドファクター                     [ESI_BLENDFACTOR]
      31 = α値                                         [ESI_ALPHA]
      32 = 点滅用スプライト表示フラグ                [ESI_DISPFLAG]
      34,35 = ライト値                                 [ESI_LIGHT_LOW,
      ESI_LIGHT_HIGH]
      36 = 優先順位                                  [ESI_PRIORITY]
    </Setting>
  </command>
  <command>
    <Name>es_ini</Name>
    <Title>システムの初期化</Title>
    <Format>
      p1,p2
      p1=スプライトの最大数
      p2=キャラクタ定義の最大数
      p3=周の精度(64〜4096)
    </Format>
    <Setting>
      HSPDXFIX.DLLシステムの初期化を行ないます。
      パラメータを省略すると、スプライトは512個まで、 キャラクタ定義数は1024個までを最大としてスプライトを初期化します。es_ini命令は何度でも実行することができるので、スプライトをすべてクリアしたい時などにも使用可能です。

      p3はes_adir命令などで使用する角度を、一周何度にするかを指定します。 指定できる数値は、64と256の倍数、そして360の倍数です。それ以外の数値を指定した場合は、指定した値未満で条件に合う一番近い数値が設定されます。

      空きメモリが不足しているなど、何らかの理由でメモリ確保に失敗した時は、statに1が返ります。
    </Setting>
  </command>
  <command>
    <Name>es_gravity</Name>
    <Title>落下加速度設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.(-1〜)
      p2=X方向の加速度(-32767〜32767)
      p3=Y方向の加速度(-32767〜32767)
    </Format>
    <Setting>
      es_flag命令で自由落下移動をONにしたときの加速度を設定します。

      p2、p3は1フレームごとに加算される移動量で、256で1ドットとなります。
      p1に-1を指定すると、デフォルト値を設定することができます。　この値は、es_set命令を実行した時に設定される値で、初期値はp2が0、p3が256となっています。
    </Setting>
  </command>
  <command>
    <Name>es_exnew</Name>
    <Title>新規スプライト取得</Title>
    <Format>
      p1,p2,p3,p4
      p1=新規No.が代入される変数名
      p2=検索を開始するスプライトNo.
      p3=検索を終了するスプライトNo.
      p4=増分
    </Format>
    <Setting>
      この命令は、スプライトNo.の中で使われていないNo.を検索します。
      p2〜p3で指定したNo.の間で空きのあるNo.を、p1で指定した変数に代入します。
      空きがない場合は、-1が代入されます。

      p4には検索するスプライトNo.の増分を指定します。 省略するとp2、p3から自動的に設定するため、通常は明示する必要はありません。

      ※es_new命令と同様の処理を行いたい場合は、p3に-1を指定してください。
    </Setting>
  </command>
  <command>
    <Name>es_new</Name>
    <Title>新規スプライト取得</Title>
    <Format>
      p1,p2
      p1=新規No.が代入される変数名
      p2=検索を開始するスプライトNo.
    </Format>
    <Setting>
      この命令は、スプライトNo.の中で使われていないNo.を検索します。
      p2で指定したNo.以降で空きのあるNo.を、p1で指定した変数に代入します。空きがない場合は、-1が代入されます。

      この命令は、以前のバージョンとの互換性のために残された命令です。
      以前のバージョンを使用して作成されたスクリプトを動かす時以外はes_exnew命令を使用するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>es_timer</Name>
    <Title>タイマー取得</Title>
    <Format>
      p1,p2
      p1=結果が代入される変数名
      p2=タイマーの取得方法
    </Format>
    <Setting>
      Windowsを起動してからの経過時間をミリ秒単位で、 p1に指定した変数に代入します。精度は環境に依存します。

      p2でタイマーの取得方法を選択できます。 0がtimeGetTime、1がGetTickCountでタイマーを取得します。一般に前者の方が精度がよく、後者の方が処理が軽いとされています。
    </Setting>
  </command>
  <command>
    <Name>es_cos</Name>
    <Title>三角関数</Title>
    <Format>
      p1,p2
      p1=結果が代入される変数名
      p2=角度(0〜±n)
      ※n=es_ini第3パラメータで設定した精度
    </Format>
    <Setting>
      変数p1に、角度p2のコサインを代入します。
      p2の範囲はes_iniで設定した値までです。
      得られる値は、小数部10ビットの固定小数です。つまり、本来得られるべき値を1024倍した整数が返ってきます。

      ※角度は正の数であればある程度は範囲をオーバーしても正確に動作するようにしてありますが、負の数についてはそれを保証していませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_sin</Name>
    <Title>三角関数</Title>
    <Format>
      p1,p2
      p1=結果が代入される変数名
      p2=角度(0〜±n)
      ※n=es_ini第3パラメータで設定した精度
    </Format>
    <Setting>
      変数p1に、角度p2のサインを代入します。
      p2の範囲はes_iniで設定した値までです。
      得られる値は、小数部10ビットの固定小数です。つまり、本来得られるべき値を1024倍した整数が返ってきます。

      ※角度は正の数であればある程度は範囲をオーバーしても正確に動作するようにしてありますが、負の数についてはそれを保証していませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_getbuf</Name>
    <Title>VRAMイメージ読み出し</Title>
    <Format>
      p1
      p1=DirectXバッファID(-2〜)
    </Format>
    <Setting>
      DirectXが管理する画像バッファの内容を、HSPのウインドゥに読み出しコピーします。
      読み出しは、現在gsel命令で選択されているHSPのウインドゥIDに対して行なわれます。
      p1で、DirectXのバッファIDを指定します。これは、es_buffer命令などで使用するオフスクリーンバッファIDの他に以下の値が使用できます。

      DirectXバッファID = -1 : 現在表示中の画面イメージ
      DirectXバッファID = -2 : 現在描画中の画面イメージ

      DirectXの使用中は、通常のHSPウインドゥ上に対しての描画処理を行なうことができないので、用途は限られてしまいます。
      es_getbuf命令は、主にバッファの内容確認のためや、 実行中の画面をキャプチャして保存したい場合など、テスト的な用途に使用できます。

      HSPウィンドウ側のバッファのモードやサイズに制限はありませんが、 転送元よりバッファのサイズが小さい場合は右下が切れて転送されます。
    </Setting>
  </command>
  <command>
    <Name>es_buffer_np</Name>
    <Title>VRAMイメージ転送(パレット読み込みなし)</Title>
    <Format>
      p1,p2,p3
      p1=オフスクリーンバッファID
      p2=属性スイッチ(0〜2)
      p3=透明色(パレットモード時:-1〜255、ハイカラー以上:-1〜$ffffff)
    </Format>
    <Setting>
      属性スイッチ=0 : オフスクリーンバッファをVRAMに取る、
      失敗した場合は、メインメモリに取る
      属性スイッチ=1 : オフスクリーンバッファをメインメモリに取る
      属性スイッチ=2 : オフスクリーンバッファをVRAMに取る

      現在gsel命令で選択されているHSPのバッファ内容を、DirectXのオフスクリーンバッファにすべて転送します。

      オフスクリーンバッファに転送する際にパレットを転送しない点以外は、全てes_buffer命令と同じです。

      この命令を使うことで、パレットや既存のバッファに影響を与えることなくオフスクリーンバッファを作成することができますが、パレットがHSP側とDirectX側で異なる場合は正しい色で表示されませんので注意してください。

      なお、この命令は旧バージョンの互換性を保つために用意されています。現在はes_buffer命令で同様の動作を行えますのでそちらを使用してください。
    </Setting>
  </command>
  <command>
    <Name>es_buffer_pm</Name>
    <Title>VRAMイメージ転送(近似色変換あり)</Title>
    <Format>
      p1,p2,p3
      p1=オフスクリーンバッファID
      p2=属性スイッチ(0〜2)
      p3=透明色(パレットモード時:-1〜255、ハイカラー以上:-1〜$ffffff)
    </Format>
    <Setting>
      属性スイッチ=0 : オフスクリーンバッファをVRAMに取る、
      失敗した場合は、メインメモリに取る
      属性スイッチ=1 : オフスクリーンバッファをメインメモリに取る
      属性スイッチ=2 : オフスクリーンバッファをVRAMに取る

      現在gsel命令で選択されているHSPのバッファ内容を、DirectXのオフスクリーンバッファにすべて転送します。

      オフスクリーンバッファに転送する際にパレットを転送しない点以外は、全てes_buffer命令と同じです。

      es_buffer_np命令ではパレットがHSP側とDirectX側で一緒でなければなりませんが、この命令では自動的に近い色を探し出して変換するため、パレットが違っていてもある程度色化けを防ぐことができます(HSP側のバッファの画像を変換する
      わけではありません)。

      なお、ディザをかけたり新しく色を作成することはありませんので、なるべくパレットはいっぱいまで用意しておいてください。

      なお、この命令は旧バージョンの互換性を保つために用意されています。現在はes_buffer命令で同様の動作を行えますのでそちらを使用してください。
    </Setting>
  </command>
  <command>
    <Name>es_fmesbuf</Name>
    <Title>バッファへのフォント指定文字列表示</Title>
    <Format>
      "str",p1
      "str"=表示文字列
      p1=オフスクリーンバッファID
    </Format>
    <Setting>
      p1で指定したIDのバッファのカレントポジション(pos命令で指定されたX,Y座標)へ、指定した文字列を表示します。
      文字の色は、現在選択されている色(color命令で指定)になり、フォントはfont命令で選択されているものが使用されます。

      描画先のIDが指定できること以外は全て、es_fmesと同じです。

      この命令は、旧バージョンとの互換性を保つために用意されているものです。
    </Setting>
  </command>
  <command>
    <Name>es_mesbuf</Name>
    <Title>バッファへの文字列表示</Title>
    <Format>
      "str",p1
      "str"=表示文字列
      p1=オフスクリーンバッファID
    </Format>
    <Setting>
      p1で指定したIDのバッファのカレントポジション(pos命令で指定されたX,Y座標)へ、指定した文字列を表示します。
      es_fmes命令と似ていますが、文字の色やフォントが選べないかわりに、こちらの方が高速に処理されます。
      文字の色は、常に白(RGB=255)となり、標準フォントが使用されます。

      描画先のIDが指定できること以外は全て、es_fmes並びにes_mesと同じです。

      この命令は、旧バージョンとの互換性を保つために用意されている物です。
    </Setting>
  </command>
  <command>
    <Name>es_mes</Name>
    <Title>文字列表示</Title>
    <Format>
      "str",p1
      "str"=表示文字列
      p1=描画を行うバッファNo.(デフォルト=-2)
    </Format>
    <Setting>
      カレントポジション(pos命令で指定されたX,Y座標)から、指定した文字列を表示します。
      es_fmes命令と似ていますが、 文字の色やフォントが選べないかわりに、こちらの方が高速に処理されます。
      文字の色は、常に白(RGB=255)となり、標準フォントが使用されます。

      p1には、描画を行うバッファNo.を指定します。 表示される画面イメージに対して描画を行う場合には省略して構いません。
    </Setting>
  </command>
  <command>
    <Name>es_fmes</Name>
    <Title>フォント指定文字列表示</Title>
    <Format>
      "str",p1
      "str"=表示文字列
      p1=描画を行うバッファNo.(デフォルト=-2)
    </Format>
    <Setting>
      カレントポジション(pos命令で指定されたX,Y座標)から、指定した文字列を表示します。
      文字の色は、現在選択されている色(color命令で指定)になり、フォントはfont命令で選択されているものが使用されます。

      p1には、描画を行うバッファNo.を指定します。 表示される画面イメージに対して描画を行う場合には省略して構いません。
    </Setting>
  </command>
  <command>
    <Name>es_adir</Name>
    <Title>スプライト移動方向設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.
      p2=移動する方向(0〜)
      p3=移動スピード(%)
    </Format>
    <Setting>
      スプライトを自動的に移動させるための設定をします。

      p1でスプライトNo.、p2で方向を指定します。 方向は、es_iniで指定した数値までで指定します。0が真下となり、反時計回りに増加していきます。

      p3で移動スピードを%で指定します。 p3を省略するか、100(%)を指定した場合には、指定した方向に1フレームにつき1ドットの距離を移動します。

      p4で移動スピードを%で指定します。p4を省略するか、100を指定した場合は、100%のスピードとなり、1フレームに1ドットの速度で移動し続けます。
    </Setting>
  </command>
  <command>
    <Name>es_copy</Name>
    <Title>画像コピー</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=オフスクリーンバッファID
      p2=コピー元X座標
      p3=コピー元Y座標
      p4=コピーするXサイズ
      p5=コピーするYサイズ
    </Format>
    <Setting>
      es_copy命令では、pos命令で指定した座標にgmodeで指定したモードで、 p1で指定したIDの(p2,p3)の座標から(p4,p5)のサイズの画像がコピーされます。

      HSPのcopy命令とは若干違いがありますが、 ほぼ同じ記述でコピーが可能です。

      gmode命令により、 コピーの際に透明色の処理をするかどうかを指定しておく必要があります。
      コピーモードが0の場合は、コピー元の画像が完全にコピーされます。
      コピーモードが1か2の場合は、コピー元の画像で透明色に指定された色はコピーされません。図形のまわりだけを切り抜いたようにコピーしてくる場合に有効です。

      p4,p5を省略した場合は、gmodeで指定したサイズでコピーを行います。
    </Setting>
  </command>
  <command>
    <Name>es_zoom</Name>
    <Title>拡大縮小画像コピー</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7
      p1=オフスクリーンバッファID
      p2,p3=コピー元座標
      p4,p5=コピーするサイズ
      p6,p7=コピー先サイズ
    </Format>
    <Setting>
      es_zoom命令では、pos命令で指定した座標にgmodeで指定したモードで、 p1で指定したIDの(p2,p3)の座標から(p4,p5)のサイズの画像がコピーされます。
      ただし、コピー先のサイズは(p6,p7)で指定したサイズが使われます。
      これにより、コピー元とは違ったサイズでコピー先に転送することが可能です。

      (p4,p5)を省略するとgmodeで指定したサイズが、(p6,p7)を省略するとobjsizeで指定したサイズがそれぞれのパラメータの代わりに使用されます。

      この機能は、ビデオカードのハードウェアが変倍コピーをサポートしている時は高速に動作しますが、そうでない場合はソフトウェアで処理されるため劇的に速度が低下するので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_gdi</Name>
    <Title>GDI描画モード設定</Title>
    <Format>
      p1
      p1=描画モード設定(0〜1)
    </Format>
    <Setting>
      描画モード=0 : GDI描画を終了する
      描画モード=1 : GDI描画を開始する

      この命令を実行して、　GDI描画を開始した時点でHSPの標準描画命令を使ってDirectXのスクリーンに点や線などを描画できるようになります。
      GDI描画モード中はDirectXによる描画命令は使えなくなります。

      描画モードの切り替えに失敗した時は、システム変数statに1が返ります。

      この命令は、 使い方を誤るとWindowsの再起動が必要になる危険性があります。
      使用する際は、以下の点に注意してください。

      ・この命令を実行する前に一度だけ「redraw 0」を実行して、画面の更新が行われないようにする
      ・GDI描画モードを多重に開始、終了しないようにする
      ・GDI描画が終了したら必ず「es_gdi 0」を実行して描画モードを元に戻す
      ・GDI描画中にフォーカスの移動などが発生すると、 それ以降正常に動作しなくなる恐れがあるため、GDI描画モードはできるだけ短い時間で済ませる
    </Setting>
  </command>
  <command>
    <Name>es_d3dopt</Name>
    <Title>Direct3D描画オプション設定</Title>
    <Format>
      p1,p2,p3
      p1=テクスチャアドレッシング設定(0〜2、デフォルト=0)
      p2=テクスチャ補間設定(0〜1、デフォルト=0)
      p3=パースペクティブ補正設定(0〜1、デフォルト=0)
    </Format>
    <Setting>
      p1=0 : クランプアドレッシングに設定する
      p1=1 : ラップアドレッシングに設定する
      p1=2 : ミラーアドレッシングに設定する

      p2=0 : テクスチャの補間を行わない
      p2=1 : テクスチャの補間を行う

      p3=0 : パースペクティブ補正を無効にする
      p3=1 : パースペクティブ補正を有効にする

      Direct3Dで描画を行う際の描画処理を設定します。

      p1でテクスチャアドレッシングの設定を行います。テクスチャアドレッシングとは、テクスチャ座標がバッファからはみ出る場合にはみ出した部分をどのように表示するかを決めるもので、それぞれ次のようになっています。

      クランプアドレッシング：バッファの端をのばすように表示する。
      ラップアドレッシング　：バッファの(0,0)に戻り、 繰り返し表示する。
      ミラーアドレッシング　：バッファの端に到達したところで折り返す。

      この機能を使う場合、 バッファサイズが2の累乗になっていないと強制的にクランプアドレッシングで表示されてしまいます。グラフィックボードによってはバッファサイズを補正するため、その点に注意しないと環境依存の問題が発生しますので注意してください。

      p2はテクスチャの補間を行うかどうかを設定します。 このパラメータを1にすると画像がぼやけますが、拡大・縮小を行う際にドットの粗が目立たなくなります。

      p3でパースペクティブ補正を設定します。これは、ポリゴンが傾いたときに奥行きが出るように表示させるためのものです。ただし、当たり判定はこれに対応していないため、スプライトに対してパースペクティブ補正を有効にすると見た目と若干判定が異なって見えます。
    </Setting>
  </command>
  <command>
    <Name>es_move</Name>
    <Title>スプライト移動</Title>
    <Format>
      p1,p2,p3
      p1=移動を行うフレーム数(1〜)
      p2=移動開始スプライトNo.
      p3=移動するスプライトの個数
      p4=アニメーション制御フラグ(0〜1)
    </Format>
    <Setting>
      p4=0 : アニメーションを行う
      p4=1 : アニメーションを行わない

      スプライトの移動を行います。 es_draw命令からスプライトの描画を抜いたもので、主に処理落ち時のフレームスキップに用います。
      偶数フレームのスキップが行われた際に点滅が止まるのを防ぐため、スプライトの点滅はパラメータの設定に関係なく es_draw命令で行われます。
    </Setting>
  </command>
  <command>
    <Name>es_draw</Name>
    <Title>スプライト描画</Title>
    <Format>
      p1,p2,p3,p4
      p1=描画開始スプライトNo.
      p2=描画するスプライトの個数
      p3=スプライト固定フラグ(0〜)
      p4=描画順序(0〜1)
    </Format>
    <Setting>
      p3=0 : 通常の動作を行う
      bit1 : スプライトを移動させない
      bit2 : アニメーションを行わない

      p4=0 : スプライトNo.順に描画する
      p4=1 : 優先順位順に描画する

      登録されているスプライトを画面に描画します。
      通常は、 p1,p2のパラメータを省略して使用すれば、すべてのスプライトを描画することが可能です。

      登録されているスプライトの一部だけを描画したい場合は、p1に開始スプライトNo.、p2に描画する個数を指定してください。

      p4に1を指定すると、es_set命令やes_setpri命令で指定した優先順位の順にスプライトを描画します。ただし優先順位のソートには多少時間がかかるため、必要が無ければ従来通りスプライトNo. 順で描画をすることをおすすめします。

      この命令を実行すると、描画されたスプライトは移動を行いますが、 p3に1を指定すること描画のみを行うようにすることができます。 また、2を指定することでアニメーションを停止させることができます。
    </Setting>
  </command>
  <command>
    <Name>es_bound</Name>
    <Title>弾みやすさ設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.(-1〜)
      p2=弾みやすさ(0〜256)
      p3=フラグ(1=X方向 2=Y方向 3=両方 デフォルト=3)
    </Format>
    <Setting>
      es_flag命令で自由落下移動をONにしたときに、 画面下部(または上部)で跳ね返る際の弾みやすさを設定します。この値が大きいほど跳ね返り時に勢いが失われなくなります。

      p3は画面の上下端、あるいは左右端に当たった際に跳ね返りを行うか行わないかを設定できます。ただし、このフラグは自由落下が発生する方向にのみ適用されます。

      p1に-1を指定すると、デフォルト値を設定することができます。　この値は、es_set命令を実行した時に設定される値で、初期値は128となっています。
    </Setting>
  </command>
  <command>
    <Name>es_effect2</Name>
    <Title>スプライト特殊効果設定(マクロ)</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=スプライトNo.
      p2=表示サイズを指す配列変数
      p3=回転角を指す配列変数
      p4=半透明パラメータを指す配列変数
      p5=ライト色
    </Format>
    <Setting>
      es_effect 命令のパラメータをまとめてスクリプトを見やすくするためのマクロです。

      パラメータの代入の仕方は次のようになっています。

      ・p1、p5は数値変数を指定しても、直接数値を代入しても可
      ・p2には要素0にXサイズ、要素1にYサイズの値が入った配列変数の変数名を指定する
      ・p3には要素0から順にX方向、Y方向、Z方向の回転角が入った配列変数の変数名を指定する
      ・p4には要素0にブレンドファクター、要素1にα値が入った配列変数の変数名を指定する
      ・全パラメータは省略不可

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_excopy2</Name>
    <Title>Direct3D描画による画像コピー(マクロ)</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7
      p1=オフスクリーンバッファID(0〜63)
      p2=コピー元座標を指す配列変数
      p3=コピーするサイズを指す配列変数
      p4=表示するサイズを指す配列変数
      p5=回転角を指す配列変数
      p6=半透明パラメータを指す配列変数
      p7=ライト色
    </Format>
    <Setting>
      es_excopy命令のパラメータをまとめてスクリプトを見やすくするためのマクロです。

      パラメータの代入の仕方は次のようになっています。

      ・p1、p7は数値変数を指定しても、直接数値を代入しても可
      ・p2〜p4には要素0にサイズまたは座標のX方向、要素1にY方向の値が入った配列変数の変数名を指定する
      ・p5には要素0から順にX方向、Y方向、Z方向の回転角が入った配列変数の変数名を指定する
      ・p6には要素0にブレンドファクター、要素1にα値が入った配列変数の変数名を指定する
      ・全パラメータは省略不可

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_screen</Name>
    <Title>画面モードの変更</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=DirectX使用時の解像度X
      p2=DirectX使用時の解像度Y
      p3=DirectX使用時のカラーモード(bpp)
      p4=パレット変換モード(0=236色/1=254色/2=256色)
      p5=画面モード(0=フルスクリーン/1or2=ウィンドウモード)
      p6=Direct3D使用フラグ(0=使わない/1=使う)
    </Format>
    <Setting>
      画面の解像度を変更し、DirectXが使用可能な状態にします。
      (p1,p2)で解像度を指定します。

      p3はカラーモードを指定します。 パレットモードを使用する場合は8、ハイカラー以上を使用する場合は16,24,32のいずれかを指定します。
      ただし、 グラフィックボードによっては24または32bitの画面モードをサポートしていないものもありますが、その場合は自動的にサポートしている方のモードで初期化を行います。

      p4のパレット変換モードは、画面で使用するパレットの数を設定します。
      通常は0を指定して下さい。 パレットの数を254または、256にしたい場合に値を変更します。 ただし、236よりも多いパレット数を指定すると、フルスクリーンモード以外では動作しなくなります。 また、254よりも多いパレットを指定できないグラフィックボードが存在するので、なるべくパレット変換モードは、0または1で使用してください。

      また、パレット変換モード0の時に使用するパレットは0〜235までです。HSPの通常ウィンドウとは異なりますので注意してください。
      p5=1または2の時は、DirectXをウィンドウモードで動かします。
      ウィンドウモードで動かす際の注意点などは、hspdx.txtの「ウィンドウモードについて」の項を参照してください。

      p6は半透明などの特殊描画を行うためにDirect3Dを使用するかどうかのフラグです。このパラメータを1に設定するとDirect3Dの初期化を行い、es_excopy命令を実行できるようになります。
    </Setting>
  </command>
  <command>
    <Name>es_bfcalc</Name>
    <Title>ブレンドファクター算出(マクロ)</Title>
    <Format>
      (p1,p2)
      p1=SRC側のブレンドファクター
      p2=DEST側のブレンドファクター
      ※ctypeマクロのため、必ず括弧でくくること
    </Format>
    <Setting>
      それぞれに指定するブレンドファクターをプラグインに渡す形に変換するためのマクロで、主にes_excopy命令で使うためのものです。指定する値は0〜10もしくはヘッダファイルで定義されている、以下の定数名を使用します。
      #define ESB_ZERO 0
      #define ESB_ONE 1
      #define ESB_SRCCOLOR 2
      #define ESB_INVSRCCOLOR 3
      #define ESB_SRCALPHA 4
      #define ESB_INVSRCALPHA 5
      #define ESB_DESTALPHA 6
      #define ESB_INVDESTALPHA 7
      #define ESB_DESTCOLOR 8
      #define ESB_INVDESTCOLOR 9
      #define ESB_SRCALPHASAT 10
    </Setting>
  </command>
  <command>
    <Name>es_rgbcalc</Name>
    <Title>RGB値算出(マクロ)</Title>
    <Format>
      p1,p2,p3
      p1=R値(0〜255)
      p2=G値(0〜255)
      p3=B値(0〜255)
      ※ctypeマクロのため、必ず括弧でくくること
    </Format>
    <Setting>
      RGB値を一つの値にまとめるためのマクロです。
      パラメータのチェックは行わないため、範囲外の値を代入するとおかしな値になりますので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_clip</Name>
    <Title>クリッピング範囲設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=左上のX座標
      p2=左上のY座標
      p3=右下のX座標
      p4=右下のY座標
    </Format>
    <Setting>
      描画命令のクリッピング範囲を設定します。
      クリッピング範囲が反映される命令は、es_copy、es_zoom、es_excopyです。 なお、画面外に範囲を指定することはできません。
    </Setting>
  </command>
  <command>
    <Name>es_excopy</Name>
    <Title>Direct3D描画による画像コピー</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13
      p1=オフスクリーンバッファID(0〜63)  p12=α値(0〜256)
      p2,p3=コピー元座標                  p13=ライト色(0〜$ffffff)
      p4,p5=コピーするサイズ
      p6,p7=表示するサイズ
      p8,p9,p10=回転角(0〜4095)
      p11=ブレンドファクター（0〜120)
    </Format>
    <Setting>
      オフスクリーンバッファIDp1の (p2,p3)から(p4,p5)のサイズの画像を(p6,p7)の大きさで、pos命令で指定した座標にコピーします。 (p4,p5)と(p6,p7)に異なる値を指定することで、拡大縮小コピーを行えます。
      es_copy命令と同様に、gmodeで透明色を透過することができます。

      (p4,p5)か(p6,p7)のいずれかに負の数を指定すると、反転表示が可能になります。このとき、

      ・(p4,p5)で反転を指定した場合、(p2,p3)はコピー元の左(上)座標ではなく、右(下)座標を指定することになる
      ・(p6,p7)で反転を指定した場合、pos命令で指定した座標から左(上)に表示される

      と言うように、パラメータの指定方法などが通常とは異なりますので注意してください。

      p10で画像の回転を行います。 回転角は一周4096度で固定ですので注意してください。

      p11とp12で半透明処理のためのブレンドファクターとα値を設定します。
      詳しくはhspdx.txtの命令リファレンスを参照してください。

      p13のライト色とは、画像を表示するためのライトの色のことで、 この値を変更することで画像内の特定の色成分を押さえて表示することができます (強調することはできません)。
      パラメータは16進数6桁のRGB値で指定しますが、後述のes_rgbcalcマクロを利用することで RGB値を個別に指定することもできます。

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_effect</Name>
    <Title>スプライト特殊効果設定</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8,p9
      p1=スプライトNo.
      p2,p3=表示サイズ
      p4,p5,p6=回転角
      p7=ブレンドファクター(-1で合成OFF)
      p8=α値(0〜256)
      p9=ライト色(0〜$ffffff)
    </Format>
    <Setting>
      スプライトをDirect3D描画する際のエフェクトを設定します。省略されたパラメータは前回実行時の設定を保持します。
      回転角の有効範囲はes_excopy命令と違って es_ini命令での設定に依存しますので注意してください。

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。

      なお、現バージョンでは回転を行っても当たり判定が変わりませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_pat</Name>
    <Title>キャラクタ画像定義</Title>
    <Format>
      p1,p2,p3,p4
      p1=キャラクタNo.
      p2=キャラクタパターンの左上X座標
      p3=キャラクタパターンの左上Y座標
      p4=表示フレーム数(0)
    </Format>
    <Setting>
      スプライトのキャラクタパターンを定義します。

      p1で指定したキャラクタNo.に、 (p2,p3)の座標からes_sizeで設定した大きさのキャラクタが登録されます。
      ここで対象となる画像は、直前にes_buffer命令でVRAMに転送された画像データとなります。この画像の中の一部を切り出し
      てきてキャラクタパターンとして登録しておきます。
      es_pat命令1回で、指定したキャラクタNo.にキャラクタパターンが登録されます。たくさんのキャラクタパターンが必要な場合は、そのぶん登録をしておく必要があります。

      p4のパラメータは、キャラクタアニメーションをするための設定です。
      0ならば、アニメーションなし。1以上ならば、指定したフレーム数だけそのキャラクタを表示した後、 次のキャラクタ(キャラクタNo.+1)を表示するように設定されます。
    </Setting>
  </command>
  <command>
    <Name>es_setp</Name>
    <Title>スプライトパラメータ設定</Title>
    <Format>
      p1,p2,p3
      p1=スプライトNo.
      p2=info number
      p3=変更する値(-32768〜32767)
    </Format>
    <Setting>スプライトの情報を直接変更します。p2についてはes_getの説明を参照してください。</Setting>
  </command>
  <command>
    <Name>es_expat</Name>
    <Title>キャラクタ画像定義(マクロ)</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=キャラクタNo.
      p2=バッファNo.
      p3=キャラクタパターンの左上X座標
      p4=キャラクタパターンの左上Y座標
      p5=表示フレーム数
    </Format>
    <Setting>
      スプライトのキャラクタパターンを定義します。es_pat命令に、登録する画像のバッファNo.を指定できるようにしたものです。

      マクロのため、es_pat命令と違いパラメータを省略できませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>es_cursor</Name>
    <Title>マウスカーソル表示</Title>
    <Format>
      p1
      p1=表示フラグ(0=表示しない/1=表示する)
    </Format>
    <Setting>
      マウスカーソルの表示を制御します。
      通常、フルスクリーンモードではマウスカーソルは表示されませんが、この命令を実行することで必要に応じてカーソルの表示／非表示を切り替えることができます。
      また、ウィンドウモード時でもこの命令を実行することにより、マウスカーソルがウィンドウ内に入ったときに限り表示を抑制することができるようになります。

      なお、この命令はハードウェアがフルスクリーンでのウィンドウレンダリングに対応していない場合はうまく動かない可能性があります。
    </Setting>
  </command>
  <command>
    <Name>es_dialog</Name>
    <Title>ダイアログ表示(マクロ)</Title>
    <Format>
      "message",p1,"option"
      p1=ダイアログのタイプ設定
    </Format>
    <Setting>
      フルスクリーンモードでダイアログを表示するためのマクロです。
      このマクロ実行後はマウスカーソルを消去しますので、ウィンドウモードで実行しているときなどにはes_cursor命令で再度表示する必要があります。
      パラメータの詳細についてはdialog標準命令を参照してください。

      このマクロでは、 ダイアログ表示後にes_cursor命令を実行している関係で、dialog命令が返したstatを得ることができませんが、代わりにesr_statという命令にstat値を待避させるようにしてありますので、ダイアログ上での操作によって処理を振り分けたりしたい場合はこの値を参照して下さい。その他のシステム変数は保持されますので、直接参照できます。

      なお、この命令はハードウェアがフルスクリーンでのウィンドウレンダリングに対応していない場合はうまく動かない可能性があります。
    </Setting>
  </command>
  <command>
    <Name>es_exput</Name>
    <Title>Direct3Dによるキャラクタ画面表示</Title>
    <Format>
      p1,p2,p3,...,p11
      p1,p2   =表示する左上X,Y座標
      p3      =表示するキャラクタNo.
      p4,p5   =表示サイズ
      p6,p7,p8=回転角
      p9      =ブレンドファクター
      p10     =α値
      p11     =ライト値
    </Format>
    <Setting>
      スプライト用キャラクタパターンとして登録されている画像を表示します。
      es_put命令のDirect3D対応版です。

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_exput2</Name>
    <Title>D3Dによるキャラクタ画面表示(マクロ)</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=表示座標を指す配列変数
      p2=表示するキャラクタNo.
      p3=表示サイズを指す配列変数
      p4=回転角を指す配列変数
      p5=半透明パラメータを指す配列変数
      p6=ライト色
    </Format>
    <Setting>
      es_exput命令のパラメータをまとめたマクロです。

      パラメータの代入の仕方は次のようになっています。

      ・p2、p6は数値変数を指定しても、直接数値を代入しても可
      ・p1、p3には要素0にXサイズ、要素1にYサイズの値が入った配列変数の変数名を指定する
      ・p4には要素0から順にX方向、Y方向、Z方向の回転角が入った配列変数の変数名を指定する
      ・p5には要素0にブレンドファクター、要素1にα値が入った配列変数の変数名を指定する
      ・全パラメータは省略不可

      この命令を実行するには、 es_screen命令でDirect3Dを使用するように指定する必要があります。
    </Setting>
  </command>
  <command>
    <Name>es_setpri</Name>
    <Title>スプライト優先順位設定</Title>
    <Format>
      p1,p2
      p1=スプライトNo.
      p2=優先順位(-32768〜32767)
    </Format>
    <Setting>スプライトの優先順位を変更します。</Setting>
  </command>
  <command>
    <Name>es_showdia</Name>
    <Title>GDIウィンドウ表示</Title>
    <Format></Format>
    <Setting>
      フルスクリーンモードでダイアログを表示するための準備をします。

      この命令を実行すると、 GDIがウィンドウを描画できるサーフェスが表示面にくるようにフリッピングを行い、以後dialog標準命令が画面に表示できるようになります。そのため、実行するタイミングによっては描画途中の画面が表示されてしまいますので注意してください。

      今後のバージョンアップではこの命令を使って HSPの標準ウィンドウを表示できるようにする予定ですが、現在のところはそれをサポートしていないためこの命令を単体で実行する必要性はありません。
    </Setting>
  </command>
  <command>
    <Name>es_release</Name>
    <Title>スクリーンバッファ削除</Title>
    <Format>
      p1
      p1=オフスクリーンバッファID
    </Format>
    <Setting>p1で指定されたオフスクリーンバッファを削除します。</Setting>
  </command>
  <command>
    <Name>es_bufcheck</Name>
    <Title>バッファロストチェック(モジュール)</Title>
    <Format></Format>
    <Setting>
      フルスクリーンモードで動作中にAlt+Tabが押されるなどして、 別ウィンドウにフォーカスが移るとバッファが消失することがあります。

      このモジュールは、ウィンドウのフォーカスとバッファのロストを監視し、フォーカスが別ウィンドウに移ったときは実行を停止し、バッファのロストが生じたときはそのバッファの復元を行った後statに1を返します。

      復元されたバッファは再び描画命令で使用することができるようになりますが、バッファの内容が残っているとは限りませんので、バッファのロストが検出されたときは一度すべてのバッファに対して画像を転送し直すことをおすすめします。
    </Setting>
  </command>
  <command>
    <Name>aplsel</Name>
    <Title>任意のウィンドウ捕獲</Title>
    <Format>
      "window name",p1
      "window name" : 取得するウィンドウのタイトル名
      p1=0〜(0)     : 開始ID
    </Format>
    <Setting>
      指定したウィンドウを捕獲して、メッセージを送信する準備をします。

      "window name" に、ウィンドウのタイトルに表示されている文字列を指定することで、ウィンドウを検索します。
      "window name"は、終わりの文字列を省略することが可能です。
      たとえば、"ＨＳＰスクリプトエディタ"という名前のウィンドウは、"ＨＳＰ"だけでも、"ＨＳＰスクリ"という文字列でもマッチします。
      ただし、同じ名前のタイトルがあった場合には、どのウィンドウがマッチするかは不明になります。

      p1で開始IDを指定することで検索を開始する検索IDを決めることができます。
      この検索IDは、 すべてのウィンドウ (およびタスク) のID番号で、0から順番に値がつけられています。
      「aplsel "",p1」と記述すると、検索IDがp1のウィンドウを捕獲することができます。

      aplsel命令が実行されて、ウィンドウの検索に成功した場合は、システム変数statに0が代入されて、システム変数 refstrに正確なウィンドウタイトル名が代入されます。
      ウィンドウの検索に失敗した場合は、システム変数 statに1が代入されメッセージの送信を行なうことはできません。
    </Setting>
  </command>
  <command>
    <Name>aplobj</Name>
    <Title>任意のオブジェクト捕獲</Title>
    <Format>
      "object name",p1
      "object name" : 取得するオブジェクトのクラス名
      p1=0〜(0)     : 開始オブジェクトID
    </Format>
    <Setting>
      aplsel命令で捕獲したウィンドウに属するオブジエクト(コントロール)を捕獲して、メッセージを送信する準備をします。

      "object name" に、オブジェクト(コントロール)のクラス名を指定することで、オブジェクトを検索します。

      p1で、開始IDを指定することで検索を開始する検索オブジェクトIDを決めることができます。このIDは、0から順番に値がつけられています。
      「aplsel "",p1」と記述すると、オブジェクトIDを捕獲することができます。

      aplobj命令が実行されて、オブジェクトの検索に成功した場合は、システム変数 statに0が代入されて、システム変数refstrに正確なオブジェクトのクラス名が代入されます。
      ウィンドウの検索に失敗した場合は、システム変数statに1が代入され、メッセージの送信を行なうことはできません。
    </Setting>
  </command>
  <command>
    <Name>aplact</Name>
    <Title>ウィンドウをアクティブにする</Title>
    <Format></Format>
    <Setting>
      aplsel命令、およびaplobj命令で捕獲したウィンドウをアクティブにして、キーボード入力が可能な状態にします。

      aplkey命令などで、 HSP以外のウィンドウにキーを送信する場合には、aplact命令で、ウィンドウをアクティブにしておく必要があります。
    </Setting>
  </command>
  <command>
    <Name>aplfocus</Name>
    <Title>キー送信先をデフォルトにする</Title>
    <Format></Format>
    <Setting>
      キー送信の対象となるウィンドウをデフォルトに戻します。

      デフォルト設定では、現在アクティブなウィンドウの、キーボード入力フォーカスがあるオブジェクトに対してキー送信されます。
    </Setting>
  </command>
  <command>
    <Name>aplstr</Name>
    <Title>文字列をキー送信</Title>
    <Format>
      "strings"
      "strings" : キー送信する文字列
    </Format>
    <Setting>
      "strings" で指定した文字列を、キーボード入力データとして、捕獲先のオブジェクトに送信します。

      aplstr命令は文字列をそのまま送信することができますが、 [ALT]キーなどの特殊キーの情報は送信できません。
      aplstr命令は、キーの情報をキューにためるだけです。
      実際に押した結果を反映するためには、waitや await命令を後に入れる必要があります。
      一度に大量の情報を送りすぎると、キューがあふれてうまく送信されなくなる可能性があります。
      aplstr命令は、すべてのアプリケーションにおいて、認識されるとは限りません。aplstr命令の送信を受け付けない場合は、aplkey命令などで試してみてください。
    </Setting>
  </command>
  <command>
    <Name>aplkey</Name>
    <Title>キーコード送信</Title>
    <Format>
      p1,p2
      p1=0〜(0) : キーコード
      p2=0〜(0) : 特殊キーコード

      ( 1 = SHIFT / 2 = CTRL / 4 = ALT )
    </Format>
    <Setting>
      キーを押した情報を捕獲先のオブジェクトに送信します。

      p1で、キーコードを指定します。これは、getkey命令で使用しているキーコードと同一のものです。(下の表を参照)

      p2で特殊キーの指定をします。 1ならば、シフトキー、2ならばCTRLキー、4ならばALTキーが同時に押されていることになります。

      aplkey命令は、キーの情報をキューにためるだけです。
      実際に押した結果を反映するためには、waitやawait命令を直後に入れる必要があります。
      p1に0を指定した場合には、特殊キーコードの情報のみが送信されます。

      キーコード一覧
      ---------------------------------------------
      3 : キャンセル（[CTRL]+[BREAK]）
      4 : ３ボタンマウスのまん中のボタン
      8 : [BACKSPACE]（PC98の[BS]）
      9 : [TAB]
      13 : [ENTER]
      16 : [SHIFT]
      17 : [CTRL]
      18 : [ALT]（PC98の[GRPH]）
      20 : [CAPSLOCK]
      27 : [ESC]
      32 : スペースキー
      33 : [PAGEUP]（PC98の[ROLLDOWN]）
      34 : [PAGEDOWN]（PC98の[ROLLUP]）
      35 : [END]（PC98の[HELP]）
      36 : [HOME]（PC98の[HOMECLR]）
      37 : カーソルキー[←]
      38 : カーソルキー[↑]
      39 : カーソルキー[→]
      40 : カーソルキー[↓]
      ---------------------------------------------
      48〜57  : [0]〜[9]（メインキーボード）
      65〜90  : [A]〜[Z]
      96〜105 : [0]〜[9]（テンキー）
      112〜121 : ファンクションキー [F1]〜[F10]
      ---------------------------------------------
    </Setting>
  </command>
  <command>
    <Name>aplkeyd</Name>
    <Title>キー押し下げ送信</Title>
    <Format>
      p1,p2
      p1=0〜(0) : キーコード
      p2=0〜(0) : 特殊キーコード

      ( 1 = SHIFT / 2 = CTRL / 4 = ALT )
    </Format>
    <Setting>
      キーを押した情報を捕獲先のオブジェクトに送信します。

      p1でキーコードを指定します。これは、getkey命令で使用しているキーコードと同一のものです。

      p2で特殊キーの指定をします。1ならば、シフトキー、2ならばCTRLキー、 4ならばALTキーが同時に押されていることになります。

      aplkey命令とは違い、aplkeyd命令は、キーを押した情報だけを送信します。
      キーを押しつづけたい場合や、当時に複数のキーを押した状態を作り出したい時に使用してください。
      また、 aplkeyd命令でキーを押した情報を送信した後は、必ずキーを離したという情報をaplkeyu命令で送信しなければなりません。aplkeyd命令は、キーの情報をキューにためるだけです。
      実際に押した結果を反映するためには、waitや await命令を直後に入れる必要があります。
      p1に0を指定した場合には、特殊キーコードの情報のみが送信されます。
    </Setting>
  </command>
  <command>
    <Name>aplkeyu</Name>
    <Title>キー押し上げ送信</Title>
    <Format>
      p1,p2
      p1=0〜(0) : キーコード
      p2=0〜(0) : 特殊キーコード

      ( 1 = SHIFT / 2 = CTRL / 4 = ALT )
    </Format>
    <Setting>
      キーを離した情報を捕獲先のオブジェクトに送信します。

      p1でキーコードを指定します。これは、getkey命令で使用しているキーコードと同一のものです。

      p2で特殊キーの指定をします。1ならば、シフトキー、2ならばCTRLキー、 4ならばALTキーが同時に押されていることになります。

      aplkeyu命令は、キーを離した情報だけを送信します。必ず、aplkeyd命令と対にして使用してください。
      p1の指定を省略すると、 aplkeyd命令で指定したキーコードと、特殊キーコードと同じものが使われます。
      aplkeyu命令は、キーの情報をキューにためるだけです。
      実際に押した結果を反映するためには、waitや await命令を直後に入れる必要があります。
    </Setting>
  </command>
  <command>
    <Name>aplget</Name>
    <Title>オブジェクトの文字列を取得</Title>
    <Format>
      p1,p2
      p1=変数    : オブジェクトの文字列を読み出す変数名
      p2=0〜(64) : 最大文字数
    </Format>
    <Setting>
      aplobj命令で選択されたオブジェクトに設定された文字列を取得します。

      オブジェクトが "BUTTON" などの場合はそこに設定されている文字列が、またウィンドウの場合はタイトルに表示されている文字列を読み出します。

      p2が省略されている場合は最大64文字まで読み出します。
      64文字以上の文字列を読み出す場合は、p2に最大文字数を指定してください。
      (あらかじめ読み出す変数に十分なバッファが確保されている必要があります)

      aplfocus命令で、ウィンドウの指定がデフォルトになっている場合は現在アクティブなウィンドウのタイトル文字列が読み出されます。
      aplget命令で "EDIT" オブジェクトの編集内容を呼び出すことはできません。
      "EDIT"オブジェクトの編集内容以外の情報は、 apledit命令で取得することが可能です。
    </Setting>
  </command>
  <command>
    <Name>apledit</Name>
    <Title>エディットコントロール情報取得</Title>
    <Format>
      p1,p2,p3
      p1=変数 : 情報が格納される数値型変数名
      p2=0〜2 : 取得情報No.
      p3=0〜  : 行インデックス指定
    </Format>
    <Setting>
      aplobj命令で選択された"EDIT"タイプのオブジェクトの情報を取得します。

      p1に読み出す先の変数名を指定して、p2で情報の種類を指定します。

      p2=0 : 現在のカーソル位置(1byte単位)
      p2=1 : 全体の行数
      p2=2 : p3で指定した行にある文字数

      パラメータp3は、p2に2が指定された時のみ意味を持ちます。
      また、p2が0の時 (カーソル位置取得)はp1で指定した変数に、先頭からカーソルまでのバイト数、もし選択範囲があれば、システム変数statにカーソル位置から選択されている範囲のバイト数が代入されます。
    </Setting>
  </command>
  <command>
    <Name>clipset</Name>
    <Title>クリップボードテキスト転送</Title>
    <Format>
      "strings"
      "strings" : クリップボードに送る文字列
    </Format>
    <Setting>
      "strings"で指定した文字列を、クリップボードに送ります。

      クリップボードに送られたテキストデータは、他のアプリケーションで貼り付け(ペースト)が可能になります。
    </Setting>
  </command>
  <command>
    <Name>clipsetg</Name>
    <Title>クリップボード画像転送</Title>
    <Format></Format>
    <Setting>
      現在選択されている画面をビットマップデータとして、クリップボードに送ります。

      クリップボードに送られた画像データは、 他のアプリケーションで 貼り付け(ペースト)が可能になります。
    </Setting>
  </command>
  <command>
    <Name>clipget</Name>
    <Title>クリップボードテキスト取得</Title>
    <Format>
      p1,p2
      p1=変数    : 情報が格納される変数名
      p2=0〜(64) : 最大文字数
    </Format>
    <Setting>
      クリップボードに送られているテキストの内容を読み出し、p1で指定した文字列型変数に代入します。

      読み出す内容は他のアプリケーションなどでコピーされたテキストのみです。
      画像や音声は取り出すことができません。p2が省略されている場合は最大64文字まで読み出します。64文字以上の文字列を読み出す場合は、p2に最大文字数を指定してください。
      (あらかじめ読み出す変数に十分なバッファが確保されている必要があります)
    </Setting>
  </command>
  <command>
    <Name>comopen</Name>
    <Title>シリアルポートを初期化</Title>
    <Format>
      p1,"protocol"
      p1=0〜(0)  : COMポート番号
      "protocol" : プロトコル指定文字列
    </Format>
    <Setting>
      シリアルポートを初期化して送受信を可能な状態にします。

      シリアル通信命令セットを使う場合には、最初に comopen命令でポートの初期化をする必要があります。
      p1で、COMポートの番号を指定します。 1ならばCOM1、2ならばCOM2…が対応します。 p1が0の場合は、シリアルではなくプリンタ(パラレル)ポートが指定されます。
      "protocol"で、プロトコル指定文字列を記述することができます。
      プロトコル指定文字列は以下のような記述をする必要があります。

      "baud=1200 parity=N data=8 stop=1"

      上の例では、ボーレートが1200bps、パリティビットなし、データビット8、ストップビット1という指定になります。
      "protocol"に何も書かなかった場合(""を指定)は、現在のデフォルト値が使用されます。通常は、何も指定しなくても問題ありません。

      シリアル通信命令では、同時に１つのポートまでしか制御できません。
      複数のシリアルポートを同時に監視するソフトを構築することはできませんのでご注意ください。

      シリアルポートは、一度初期化されると、開放するまで他のアプリケーションが使用できなくなってしまうので、必ず最後にポートを開放することを忘れないでください。特に通信中にクローズボックスを押して終了してしまうことのないようにonexit命令などで、終了時に注意を促すようなスクリプトを作成してください。

      シリアルポートの初期化に成功すると、システム変数 statの値が0になります
      。もし、初期化に失敗した場合はシステム変数statの値は1になります。
    </Setting>
  </command>
  <command>
    <Name>comclose</Name>
    <Title>シリアルポートを解放</Title>
    <Format></Format>
    <Setting>
      シリアルポートとの通信を終了します。

      comopen命令で初期化されたシリアルポートは、必ず comclose命令で最後に解放する必要があります。
      comclose命令でポートが解放されないままプログラムが終了すると、他のプログラムがポートに二度とアクセスできなくなってしまうので注意してください。
      。
    </Setting>
  </command>
  <command>
    <Name>comput</Name>
    <Title>シリアルポートに送信</Title>
    <Format>
      "send-string"
      "send-string" : 送出文字列
    </Format>
    <Setting>
      "send-string"で指定された文字列をシリアルポートに送出します。

      命令の実行後、システム変数statに結果が返されます。
      システム変数 statが0ならば通信に失敗し送信されていないことを示します。
      1以上の場合は、送信に成功したバイト数(文字数)が代入されています。
    </Setting>
  </command>
  <command>
    <Name>computc</Name>
    <Title>シリアルポートに送信</Title>
    <Format>
      p1
      p1=0〜255(0) : 送信データ(1バイト)
    </Format>
    <Setting>
      p1で指定された1バイトの数値データをシリアルポートに送出します。

      命令の実行後、システム変数statに結果が返されます。
      システム変数 statが0ならば通信に失敗し送信されていないことを示します。
    </Setting>
  </command>
  <command>
    <Name>comgetc</Name>
    <Title>シリアルポートから受信</Title>
    <Format>
      p1
      p1=数値型変数 : 受信データが代入される変数名
    </Format>
    <Setting>
      シリアルポートから1バイト受信し、p1で指定した変数に代入します。

      命令の実行後、システム変数statに結果が返されます。
      システム変数 statが0ならば、受信バッファが空になっていることを示しています。
    </Setting>
  </command>
  <command>
    <Name>comget</Name>
    <Title>シリアルポートから文字列を受信</Title>
    <Format>
      p1,p2
      p1=文字列型変数 : 受信データが代入される変数名
      p2=1〜(64)      : 受信文字数指定
    </Format>
    <Setting>
      シリアルポートから文字列を受信し、p1で指定した変数に代入します。

      p2で、受信する文字数を指定することができます。命令の実行後、システム変数statに結果が返されます。
      システム変数 statが0ならば、受信バッファが空になっていることを示しています。
      受信に成功すると、p1に文字列が代入され、システム変数statに実際に受信した文字数が代入されます。
    </Setting>
  </command>
  <command>
    <Name>comcontrol</Name>
    <Title>シリアルポートの特殊コントロール</Title>
    <Format>
      p1
      p1=1〜9(0)      : 特殊コントロール機能指定
    </Format>
    <Setting>
      シリアルポートに対して特殊なコントロールを行ないます。
      p1で、コントロールする機能を以下の中から指定します。

      値      機能
      -----------------------------------------------------------------------
      SETXOFF    1       XOFF 文字を受信したときのように送信を行います。
      SETXON     2       XON 文字を受信したときのように送信を行います。
      SETRTS     3       RTS（ 送信要求）信号を送信します。
      CLRRTS     4       RTS（ 送信要求）信号を消去します。
      SETDTR     5       DTR（ データ端末準備完了）信号を送信します。
      CLRDTR     6       DTR（ データ端末準備完了）信号を消去します。
      RESETDEV   7       デバイスをリセットします
      SETBREAK   8       文字送信を中断し、送信回線を切断状態にします。
      CLRBREAK   9       送信回線の切断状態を解除して、文字送信を再開します。

      状態取得が正常に行なわれた場合にはシステム変数statが0になります。
      エラーが発生した場合には、システム変数statは1になります。
    </Setting>
  </command>
  <command>
    <Name>comstat</Name>
    <Title>シリアルポートの状態取得</Title>
    <Format>
      p1
      p1=数値型配列変数 : 状態データが代入される変数名
    </Format>
    <Setting>
      シリアルポートの状態を取得してp1で指定した変数に代入します。
      p1で指定する変数は、配列でp1.0〜p1.3までに以下の情報が代入されます。

      -----------------------------------------------------------------------
      a.0
      エラー発生時に以下のエラーフラグの組み合わせが代入されます。

      CE_RXOVER           0x0001  受信バッファのオーバーフロー。
      CE_OVERRUN          0x0002  オーバーランエラー。
      CE_RXPARITY         0x0004  受信時のパリティエラー。
      CE_FRAME            0x0008  フレーミングエラー。
      CE_BREAK            0x0010  ブレーク状態。
      CE_TXFULL           0x0100  送信バッファがいっぱいになりました。
      CE_PTO              0x0200  タイムアウト。
      CE_IOE              0x0400  一般 I/O エラー。
      CE_DNS              0x0800  デバイスが選択されていません。
      CE_OOP              0x1000  給紙切れエラー。
      CE_MODE             0x8000  サポート外のモードです。

      a.1
      以下のデバイス状態フラグが代入されます。

      bit0 fCtsHold  ON: 送信は CTS 待ち
      bit1 fDsrHold  ON: 送信は DSR 待ち
      bit2 fRlsdHold  ON: 送信は RLSD (CD) 待ち
      bit3 fXoffHold  ON: XOFF を送信したため 送信は停止中
      bit4 fXoffSent  ON: XOFF を送信したため 送信は停止中
      bit5 fEof  ON: EOF を受信した
      bit6 fTxim  ON: 送信バッファにデータが残っている

      a.2
      cbInQue  受信バッファにあるデータのバイト数
      a.3
      cbOutQue  送信バッファにあるデータのバイト数
      -----------------------------------------------------------------------

      状態取得が正常に行なわれた場合にはシステム変数statが0になります。
      エラーが発生した場合には、システム変数statは1になります。
    </Setting>
  </command>
  <command>
    <Name>gfini</Name>
    <Title>対象画面を設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : 画面操作を行なうXサイズ(dot単位)
      p2=0〜(0) : 画面操作を行なうYサイズ(dot単位)
    </Format>
    <Setting>
      フルカラー画面操作命令を行なう対象の画面を設定します。

      必ず gfini命令で対象の画面を設定してから、他のフルカラー画面操作命令を使用してください。
      gfini命令では、現在 gsel命令で選択されているウィンドウのカレントポジションから、p1,p2で指定したサイズを描画対象とします。
      必ずフルカラーモードで初期設定をした画面に対して行なってください。
    </Setting>
  </command>
  <command>
    <Name>gfcopy</Name>
    <Title>半透明コピー</Title>
    <Format>
      p1
      p1=0〜100(0) : 半透明コピーレート(%)
    </Format>
    <Setting>
      p1で指定したレートで画面イメージをコピーします。

      コピー先は、gfini命令で設定した画面になります。
      コピー元は、gfcopy命令が実行された時点に、描画先に設定されている画面のカレントポジションになります。
      p1のレートは 0〜100(%)で、100%は普通のコピーになります。この命令を実行しただけでは実際の画面は更新されません。
      「redraw 1」などで画面の更新を行なって初めて反映されます。
    </Setting>
  </command>
  <command>
    <Name>gfdec</Name>
    <Title>画面の色減算</Title>
    <Format>
      p1,p2,p3
      p1,p2,p3=0〜255(0) : 色コード（R,G,Bの輝度)
    </Format>
    <Setting>
      gfini命令で設定した画面内のすべてのドットに対して、p1,p2,p3 で指定した数値を減算します。

      p1はR、p2はG、p3は Bに対して行なわれます。これはフルカラーモードにおいて、ゆっくりと色を落としていく (フェードアウト) の効果を出す時に有効です。この命令を実行しただけでは実際の画面は更新されません。
      「redraw 1」などで画面の更新を行なって初めて反映されます。
    </Setting>
  </command>
  <command>
    <Name>gfinc</Name>
    <Title>画面の色加算</Title>
    <Format>
      p1,p2,p3
      p1,p2,p3=0〜255(0) : 色コード（R,G,Bの輝度)
    </Format>
    <Setting>
      gfini命令で設定した画面内のすべてのドットに対して、p1,p2,p3 で指定した数値を加算します。

      p1はR、p2はG、p3は Bに対して行なわれます。これはフルカラーモードにおいて、ゆっくりと色を白にしていく (ホワイトアウト) の効果を出す時に有効です。この命令を実行しただけでは実際の画面は更新されません。
      「redraw 1」などで画面の更新を行なって初めて反映されます。
    </Setting>
  </command>
  <command>
    <Name>fxcopy</Name>
    <Title>ファイルのコピー・移動</Title>
    <Format>
      p1,"dest",p2
      p1=変数    : コピー元のファイル名が格納された文字列型変数名
      "dest"     : コピー先のパス名
      p2=0,1 (0) : モード指定( 0=コピー / 1=移動 )
    </Format>
    <Setting>
      指定したファイルを、別のパスにコピーまたは移動をします。

      p1で、コピー元のファイル名をあらかじめ格納してある変数名を指定します。
      "dest"で、コピー先のディレクトリやドライブを指定します。
      p2のモードにより、コピーか移動のどちらかを指定することができます。
      p2の指定を省略した場合は、コピーになります。
      移動のモードを指定した場合は、元のファイルは削除されます。ただし、移動は同一ドライブ内でなければなりません。

      fxcopy命令は、Windowsのシェルを使って高速にコピー・移動を行ないます。HSPのbcopy命令よりも高速ですが、 packfile で指定したファイルへのアクセスはできませんので注意してください。
      命令の実行に失敗すると、システム変数 statに1が代入されます。正常に終了した場合は、システム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxren</Name>
    <Title>ファイル名を変更</Title>
    <Format>
      p1,"new name"
      p1=変数    : オリジナルのファイル名が格納された文字列型変数名
      "new name" : 新規ファイル名
    </Format>
    <Setting>
      指定したファイルを、"new name"で指定したファイル名に変更します。

      p1で、元のファイル名をあらかじめ格納してある変数名を指定します。
      "new name"で、新しいファイル名を指定します。
      命令の実行に失敗すると、システム変数 statに1が代入されます。正常に終了した場合は、システム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxinfo</Name>
    <Title>ドライブ情報を取得</Title>
    <Format>
      p1,p2,p3
      p1=変数   : 情報が格納される変数名
      p2=0〜(0) : ドライブ指定
      p3=0〜(0) : 情報タイプ指定
    </Format>
    <Setting>
      p2で指定したドライブについての情報をp1で指定した変数に代入します。

      p2で指定するドライブは、0だとカレントドライブ、1ならばAドライブ、2ならばBドライブ…というように1から26までが、A〜Zドライブに対応しています。
      p3で、情報タイプを指定することで様々なドライブ情報を取得することができます。p3で指定できる数値は以下の通りです。

      p3 : 変数型   : 情報の内容
      ---------------------------------------------------------
      0  : 数値型   : ドライブの残り容量(byte)
      1  : 数値型   : 1クラスタあたりのセクタ数
      2  : 数値型   : 1セクタあたりのバイト数
      3  : 数値型   : 空きクラスタ数
      4  : 数値型   : トータルのクラスタ数
      8  : 数値型   : ドライブのタイプ
      16  : 文字列型 : ボリュームラベル名
      17  : 文字列型 : ファイルシステム名
      18  : 数値型   : ボリュームシリアル番号
      19  : 数値型   : 使用可能な最大ファイル文字数
      20  : 数値型   : ファイルシステムフラグ
      32  : 文字列型 : ドライブの残り容量(byte) (大容量対応)

      指定するタイプにより、p1の変数に代入される型が違います。 タイプ16,17はあらかじめ文字列型の変数を指定しなければなりません。
      タイプ8で取得できるドライブのタイプ値の詳細は以下の通りです。

      タイプ : 内容
      --------------------------------
      0   : 不明なドライブ
      1   : ドライブなし
      2   : リムーバブルディスク
      3   : ハードディスク
      4   : リモート(ネットワーク)ドライブ
      5   : CD-ROMドライブ
      6   : RAMディスク

      命令の実行に失敗すると、システム変数 statに1が代入されます。正常に終了した場合は、システム変数statは0になります。

      p3に0を指定して得られるドライブの残り容量は 2Gbyteまでの値となります。
      2Gを超える値の場合はp3に32を指定して文字列としてサイズを得る方法をご使用下さい。
    </Setting>
  </command>
  <command>
    <Name>fxaget</Name>
    <Title>ファイル属性を取得</Title>
    <Format>
      p1,"file"
      p1=変数名 : 情報が格納される数値型変数名
      "file"    : ファイル名指定
    </Format>
    <Setting>
      "file"で指定したファイルの属性を読み出しp1で指定した変数に代入します。

      読み出した属性は以下のような数値が含まれています。

      属性  : 内容
      --------------------------------
      $1 : 書き込み禁止
      $2 : 隠しファイル
      $4 : システム
      $10 : ディレクトリ
      $20 : アーカイブ
      $80 : 標準タイプ
      $100 : 一時ファイル
      $800 : 圧縮ファイル
      $1000 : オフライン

      同時に複数の属性が設定されている場合は、それぞれの値を足した値になります。命令の実行に失敗すると、システム変数 statに1が代入されます。正常に終了した場合は、システム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxaset</Name>
    <Title>ファイル属性を設定</Title>
    <Format>
      "file",p1
      "file"    : ファイル名指定
      p1=0〜(0) : 設定する属性
    </Format>
    <Setting>
      "file"で指定したファイルに、p1で指定した属性を設定します。

      p1で指定する属性値は以下のような数値が使用できます。

      属性  : 内容
      --------------------------------
      $1 : 書き込み禁止
      $2 : 隠しファイル
      $4 : システム
      $10 : ディレクトリ
      $20 : アーカイブ
      $80 : 標準タイプ
      $100 : 一時ファイル
      $800 : 圧縮ファイル
      $1000 : オフライン

      同時に複数のファイル属性を設定する場合は、 それぞれの値を足した値にしてください。
      命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了した場合は、システム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxtget</Name>
    <Title>タイムスタンプを取得</Title>
    <Format>
      p1,"file"
      p1=変数名 : 情報が格納される数値型の配列変数名
      "file"    : ファイル名指定
    </Format>
    <Setting>
      "file"で指定したファイルのタイムスタンプ情報を取得して、p1で指定した変数に代入します。

      ただし、p1の変数は配列変数、数値型で24以上の要素を入れるだけのメモリ確保をしておかなければなりません。
      このためfxtgetおよび、fxtset命令で指定する変数はあらかじめ dim命令で、「dim a,24」などの配列宣言をしてから使用してください。取得されたタイムスタンプの情報は配列変数の各要素に代入されます。
      たとえば、「fxtget a,"test"」と指定した場合は、変数a.0〜a.23に情報が代入されます。配列の各要素に代入される値の詳細は以下の通りです。

      要素 : 内  容
      ----------------------------------------
      0   : 作成日の年(西暦)
      1   : 作成日の月
      2   : 作成日の曜日(日曜=0)
      3   : 作成日の日
      4   : 作成日の時
      5   : 作成日の分
      6   : 作成日の秒
      7   : 作成日のミリ秒
      ----------------------------------------
      8   : 更新日の年(西暦)
      9   : 更新日の月
      10   : 更新日の曜日(日曜=0)
      11   : 更新日の日
      12   : 更新日の時
      13   : 更新日の分
      14   : 更新日の秒
      15   : 更新日のミリ秒
      ----------------------------------------
      16   : 最終アクセス日の年(西暦)
      17   : 最終アクセス日の月
      18   : 最終アクセス日の曜日(日曜=0)
      19   : 最終アクセス日の日
      20   : 最終アクセス日の時
      21   : 最終アクセス日の分
      22   : 最終アクセス日の秒
      23   : 最終アクセス日のミリ秒
      ----------------------------------------

      命令の実行に失敗すると、システム変数statに1が代入されます。
      正常に終了した場合は、システム変数statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxtset</Name>
    <Title>タイムスタンプを設定</Title>
    <Format>
      p1,"file"
      p1=変数名 : 設定する情報が格納されている数値型の配列変数名
      "file"    : ファイル名指定
    </Format>
    <Setting>
      "file"で指定したファイルのタイムスタンプ情報を、p1で指定した変数のものに変更します。

      ただし、p1の変数は配列変数、数値型で24以上の要素を入れるだけのメモリ確保をしておかなければなりません。p1で指定する配列変数は、fxtget命令で使用するものと同一形式です。配列変数に指定する値の詳細は、fxtget命令の説明を参照してください。
      命令の実行に失敗すると、システム変数 statに1が代入されます。正常に終了した場合は、システム変数 statは0になります。

      fxtset命令で設定するタイムスタンプは、OSのファイルシステムによっては完全に設定されないことがあります。これは、ファイルシステムが完全な形で時間を保存していないためです。たとえば、Windows95(FAT)の場合は、最終アクセス日の時刻は記録されません。日付のみになります。また秒単位のデータも粗く記録されます。
    </Setting>
  </command>
  <command>
    <Name>selfolder</Name>
    <Title>フォルダ選択ダイアログ</Title>
    <Format>
      p1,"message"
      p1=変数名 : 選択されたパス名が格納される文字列型の変数名
      "message" : ダイアログに表示される文字列
    </Format>
    <Setting>
      Windowsのシステムで使用されている、 フォルダ選択ダイアログを表示してフォルダ名を取得します。

      選択が正常に終了すると、システム変数 statには0が代入されます。選択時にエラーまたは、キャンセルされた場合には、システム変数 statの値は1になります。
      正常に選択された場合には、フォルダまでのフルパス名がp1で指定した変数に代入されます。 また、フォルダ名がシステム変数 refstrに代入されます。
      "message" の部分に、ダイアログ表示の時に上に表示される文字列を指定することができます。
      指定を「""」にすると、「フォルダを選択してください」という標準的なメッセージが表示されます。
    </Setting>
  </command>
  <command>
    <Name>fxshort</Name>
    <Title>DOSファイルネームを取得</Title>
    <Format>
      p1,"file"
      p1=変数名 : 情報が格納される文字列型変数名
      "file"    : ファイル名指定
    </Format>
    <Setting>
      "file" で指定したファイルをDOSファイルネームに変換して、p1で指定した変数に代入します。

      "file" に指定するファイル名は、Windowsで使われているロングファイルネームでなければなりません。
      DOS プロンプトのアプリケーションなどに、渡すためのファイル名を取得する場合などに使用できます。

      尚、 DOSファイルネームをロングファイルネームに変換するには、標準命令のdirlist命令を使うことができます。
    </Setting>
  </command>
  <command>
    <Name>fxdir</Name>
    <Title>特殊なディレクトリ名を取得</Title>
    <Format>
      p1,p2
      p1=変数名 : 情報が格納される文字列型変数名
      p2=0〜(0) : 取得するディレクトリ情報の種類
    </Format>
    <Setting>
      p2で指定した種類のディレクトリ名を、p1で指定した変数に代入します。
      この命令で、 Windowsのシステムで使用される色々なディレクトリ名を取得することができます。

      p2で指定できる数値は以下の通りです。

      p2 : 取得される内容
      ------------------------------------------------------------
      -2  : Windowsのテンポラリ(一時)フォルダ
      -1  : Windowsのシステム(System)フォルダ
      2  : スタートメニュー「プログラム」グループのフォルダ
      5  :「マイドキュメント」のフォルダ
      6  :「お気に入り」のあるフォルダ
      7  :「スタートアップ」フォルダ
      8  :「最近使った書類」フォルダ
      9  :「送る」(SendTo)のフォルダ
      11  : スタートメニューのフォルダ
      16  : デスクトップのフォルダ
      21  : テンプレート(Template)フォルダ
      26  : ApplicationDataフォルダ
      27  : プリンタデバイスフォルダ
      32  : Internet キャッシュフォルダ
      33  : Internet Cookiesフォルダ
      34  : Internet 履歴フォルダ

      指定に誤りがあったり、エラーが発生するとシステム変数 statに1が代入されます。正常に終了するとシステム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>fxlink</Name>
    <Title>ショートカットを作成</Title>
    <Format>
      p1,"path"
      p1=変数名 : ショートカット名が格納されている文字列型変数名
      "path"    : 元になるファイルのフルパス名
    </Format>
    <Setting>
      p2で指定したファイルへのショートカットを、p1で指定された名前でカレントディレクトリに作成します。

      p1に指定するのは、ショートカット名が格納された文字列型の変数でなければなりません。また、ショートカット名には拡張子やドライブ、ディレクトリ名を含まない形で指定してください。
      (エクスプローラーでは表示されませんが、自動的に拡張子が.lnkになります)
      p2には、ショートカット先の場所をフルパスで指定してください。
      また、p2に「http://www.onionsoft.net/hsp/」などのURLを指定すると、インターネット・ショートカットが作成されます。

      指定に誤りがあったり、エラーが発生するとシステム変数 statに1が代入されます。正常に終了するとシステム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>lzdist</Name>
    <Title>圧縮解凍先ディレクトリ指定</Title>
    <Format>
      "path"
      "path" : lzcopy命令の解凍コピー先ディレクトリ
    </Format>
    <Setting>
      lzcopy命令の解凍コピー先ディレクトリを指定します。

      lzcopy命令を実行する場合は、必ずlzdist命令でコピー先をあらかじめ指定しておく必要かあります。
    </Setting>
  </command>
  <command>
    <Name>lzcopy</Name>
    <Title>圧縮解凍コピー</Title>
    <Format>
      "name"
      "name" : 圧縮ファイル名
    </Format>
    <Setting>
      Microsoftの compress.exe形式の圧縮ファイルを解凍しながらコピーを行ないます。

      カレントディレクトリにある"name"で指定された圧縮ファイルを、lzdist命令で指定したディレクトリに解凍された形でコピーします。
      "name"には、拡張子を含まない名前(8文字まで)を指定してください。
      lzcopy命令を実行する場合は、必ずlzdist命令でコピー先をあらかじめ指定しておく必要かあります。

      指定に誤りがあったり、エラーが発生するとシステム変数 statに1が代入されます。正常に終了するとシステム変数 statは0になります。
    </Setting>
  </command>
  <command>
    <Name>emath</Name>
    <Title>固定小数の精度を指定</Title>
    <Format>
      p1
      p1=2〜30(8) : 固定小数のビット精度
    </Format>
    <Setting>
      簡易数学関数命令セット全体で使われる固定小数の精度を設定します。

      p1で精度のビット数を指定します。たとえば、16を指定すると「整数16bit + 小数16bit」のフォーマットになります。
      固定小数のビット精度が高いほど、誤差のない正確な小数点演算が可能になりますが、そのぶん整数部で扱える範囲がせまくなります。
      デフォルトでは8bitに設定されています。
    </Setting>
  </command>
  <command>
    <Name>emstr</Name>
    <Title>固定小数を文字列に変換</Title>
    <Format>
      p1,p2,p3
      p1=変数名  : 文字列が格納される文字列型変数名
      p2=0〜     : 固定小数の値
      p3=1〜(10) : 変換される文字列の桁数
    </Format>
    <Setting>
      固定小数の値を、小数点を含む文字列に変換します。

      p1で指定した文字列型変数に、変換後の文字列が代入されます。
      p2に、変換の対象になる固定小数の値(が代入されている変数)を指定します。
      p3で、変換される桁数を指定することができます。
      p3の指定を省略した場合は、10桁になります。
    </Setting>
  </command>
  <command>
    <Name>emcnv</Name>
    <Title>文字列を固定小数に変換</Title>
    <Format>
      p1,"val"
      p1=変数名 : 固定小数が格納される数値型変数名
      "val"     : 固定小数を示す文字列
    </Format>
    <Setting>
      "val" で指定した文字列を固定小数の値に変換して、p1の変数に代入します。

      たとえば、"3.1415"という文字列を指定すると、それを固定小数に変換して格納します。
    </Setting>
  </command>
  <command>
    <Name>emint</Name>
    <Title>固定小数を整数に変換</Title>
    <Format>
      p1,p2
      p1=変数名 : 整数値が格納される数値型変数名
      p2=0〜    : 固定小数の値
    </Format>
    <Setting>
      "固定小数の値を、通常の32bit整数に変換し、p1で指定した数値型変数に代入します。

      整数に変換する際には、小数部分はすべて切り捨てられます。
    </Setting>
  </command>
  <command>
    <Name>emsin</Name>
    <Title>サインを求める</Title>
    <Format>
      p1,p2
      p1=変数名 : 結果が格納される数値列型変数名
      p2=0〜    : 角度(固定小数)
    </Format>
    <Setting>
      p2で指定した角度のサイン値を求めて、p1で指定された変数に代入します。

      p2の角度には、固定小数の値を指定します。
      単位は、0から始まって1.0で1回転する数値になっています。
      p2の値を32bit整数値として見ると、0から始まり、64で90度、128で180度、192で270度、256で360度となります(固定小数の精度が8bitの場合)。
    </Setting>
  </command>
  <command>
    <Name>emcos</Name>
    <Title>コサインを求める</Title>
    <Format>
      p1,p2
      p1=変数名 : 結果が格納される数値列型変数名
      p2=0〜    : 角度(固定小数)
    </Format>
    <Setting>
      p2で指定した角度のコサイン値を求めて、p1で指定された変数に代入します。

      p2の角度には、固定小数の値を指定します。
      単位は、0から始まって1.0で1回転する数値になっています。
      p2の値を32bit整数値として見ると、0から始まり、64で90度、128で180度、192で270度、256で360度となります(固定小数の精度が8bitの場合)。
    </Setting>
  </command>
  <command>
    <Name>emsqr</Name>
    <Title>平方根を求める</Title>
    <Format>
      p1,p2
      p1=変数名 : 結果が格納される数値列型変数名
      p2=0〜    : 固定小数
    </Format>
    <Setting>
      p2で指定した固定小数の平方根(ルート)を求めて、p1で指定された変数に代入します。

      p2にマイナスの値や0を指定した場合は、0が返されます。
    </Setting>
  </command>
  <command>
    <Name>ematan</Name>
    <Title>アークタンジェントを求める</Title>
    <Format>
      p1,p2,p3
      p1=変数名 : 結果が格納される数値列型変数名
      p2=0〜    : X値
      p3=0〜    : Y値
    </Format>
    <Setting>
      Y/Xのアークタンジェントを求めて、p1で指定された変数に代入します。

      これは、２点間の角度を求める場合に主に使用します。
      (X1,Y1) という座標と、(X2,Y2) の座標の角度を求める場合は、座標の差分、X値は(X2-X1)、Y値は(Y2-Y1)を指定します。
      p1に代入される角度の値は、emsinやemcos命令で使われる角度の単位(0から始まって、1.0で一回転)と同じです。
    </Setting>
  </command>
  <command>
    <Name>regkey</Name>
    <Title>レジストリキー指定</Title>
    <Format>
      p1,"key-name",p2
      p1=0〜(0)  : キーグループ指定
      "key-name" : キー名指定
      p2=0〜1(0) : 既存のキー(0)・新規作成(1) モードスイッチ
    </Format>
    <Setting>
      アクセスするレジストリのキーを指定します。レジストリの読み書きをする場合には、最初に必ずregkey命令でキーと読み書きのモードを指定しておかなければなりません。

      p1では、キーグループを指定します。これは以下の中から選びます。

      p1 : key group
      -----------------------------------------------------
      0  : HKEY_CURRENT_USER
      1  : HKEY_LOCAL_MACHINE
      2  : HKEY_USERS
      3  : HKEY_CLASSES_ROOT
      4  : HKEY_DYN_DATA ( Windows95/98のみ )
      5  : HKEY_PERFORMANCE_DATA ( WindowsNTのみ )

      "key-name"では、"Software¥¥OnionSoftware¥¥hsed" のように「¥¥」でツリーを区切って階層指定を行ないます。
      最後に、p2で読み書きモードの設定をします。 p2が0の場合は読み出しモードとなり、getreg命令で指定したセクションの内容を読み出すことができるようになります。p2が1の場合は、新規作成モードとなり、 setreg命令で指定したセクションを追加します。
      すでに存在するレジストリの読み出し、変更はp2を0に設定してください。

      regkey命令の実行後は、システム変数statに結果が返ります。
      システム変数 statが0以外の場合は、何らかのエラーが起こっていることを示しています。
    </Setting>
  </command>
  <command>
    <Name>getreg</Name>
    <Title>レジストリ読み出し</Title>
    <Format>
      p1,"section",p2,p3
      p1=変数名  : 読み出すための変数名
      "section"  : セクション名指定
      p2=0〜1(0) : タイプ指定
      p3=1〜(64) : 読み出しサイズ指定
    </Format>
    <Setting>
      指定されたセクションの内容をp1で指定した変数に読み出します。

      あらかじめregkey命令でアクセスするレジストリの位置を指定してから使う必要があります。対象となるレジストリ位置が指定されていない時は、エラーが表示されます。
      p2でタイプを指定します、タイプのコードは以下の通りです。

      p2 : type code
      --------------------------
      0  : 数値(32bit)
      1  : 文字列
      2  : バイナリデータ

      p3で読み出しサイズを指定します。これは、文字列かバイナリのタイプを選んだ場合に有効になります。

      命令の実行後は、システム変数 statに結果が返ります。
      システム変数 statが0以外の場合は、何らかのエラーが起こっていることを示しています。
    </Setting>
  </command>
  <command>
    <Name>setreg</Name>
    <Title>レジストリ書き込み</Title>
    <Format>
      p1,"section",p2,p3
      p1=変数名  : 書き込むための変数名
      "section"  : セクション名指定
      p2=0〜1(0) : タイプ指定
      p3=1〜(64) : 書き込みサイズ指定
    </Format>
    <Setting>
      p1で指定された変数の内容を、指定されたセクションに書き込みます。

      あらかじめregkey命令でアクセスするレジストリの位置を指定してから使う必要があります。対象となるレジストリ位置が指定されていない時は、エラーが表示されます。
      p2でタイプを指定します、タイプのコードは以下の通りです。

      p2 : type code
      ---------------------------
      0  : 数値(32bit)
      1  : 文字列
      2  : バイナリデータ

      p3で書き込みサイズを指定します。これは、バイナリのタイプを選んだ時にのみ有効になります。

      レジストリ操作命令では、すべての情報にアクセスが可能ですが、間違ったシステム情報を書き込むと、最悪システムが動作しなくなるなどの深刻な事態を引き起こすので、レジストリの操作は慎重に行なうようにしてください。

      命令の実行後は、システム変数 statに結果が返ります。
      システム変数 statが0以外の場合は、何らかのエラーが起こっていることを示しています。
    </Setting>
  </command>
  <command>
    <Name>regkill</Name>
    <Title>レジストリキー削除</Title>
    <Format>
      p1,"key-name"
      p1=0〜(0)  : キーグループ指定
      "key-name" : キー名指定
    </Format>
    <Setting>
      指定したレジストリのキーを削除します。

      p1では、キーグループを指定します。これは以下の中から選びます。

      p1 : key group
      ---------------------------------------------------
      0  : HKEY_CURRENT_USER
      1  : HKEY_LOCAL_MACHINE
      2  : HKEY_USERS
      3  : HKEY_CLASSES_ROOT
      4  : HKEY_DYN_DATA ( Windows95/98のみ )
      5  : HKEY_PERFORMANCE_DATA ( WindowsNTのみ )

      "key-name" では、"Software¥¥OnionSoftware¥¥hsed"のように「¥¥」でツリーを区切って階層指定を行ないます。

      命令の実行後は、システム変数statに結果が返ります。
      システム変数 statが0以外の場合は、何らかのエラーが起こっていることを示しています。

      指定したレジストリのキーの下に、さらにキーが含まれている場合には注意が必要です。 OSがWindowsNTの場合は、レジストリキーの下にさらにキーが含まれている場合にはエラーとなり削除できません。
      Windows95(98)/NTどちらでも動作するようなスクリプトを作る際には、この点に気をつけてください。
    </Setting>
  </command>
  <command>
    <Name>reglist</Name>
    <Title>レジストリ一覧取得</Title>
    <Format>
      p1,p2
      p1=変数名  : 読み出すための変数名
      p2=0〜1(0) : モード指定
    </Format>
    <Setting>
      指定された位置にあるレジストリキーの一覧を取得します。

      あらかじめregkey命令でアクセスするレジストリの位置を指定しておく必要があります。
      p2のモードが、0の時は「セクション一覧」を取得し、モード1の場合は、「キー一覧」を取得することになります。
      たとえば、"Software¥¥OnionSoftware¥¥hsed"と、"Software¥¥OnionSoftware¥¥hspcomm" という2つのレジストリキーが存在したとすると、"Software¥¥OnionSoftware"の位置から下にあるキー一覧は、「hsed」と「hspcomm」になります。
      これにより、レジストリツリーの中にどのようなキーやセクションが存在しているかを調べることができます。

      取得された情報は、p1で指定した文字列型の変数に代入されます。
      それぞれの項目は改行(¥n)で区切られた形で取得されるので、あらかじめ十分な変数のバッファを取っておいた方が安全です。
      取得した文字列は、 メモリノートパッド命令やlistbox命令、combox命令でそのまま使用することができます。
    </Setting>
  </command>
  <command>
    <Name>sysexit</Name>
    <Title>システムに終了を通知</Title>
    <Format>
      p1
      p1=0〜(0) : 終了タイプ指定
    </Format>
    <Setting>
      動作中のWindowsシステムを終了させます。

      p1で指定されたタイプに従って、 Windowsが終了します。この命令が実行されると、すべてのアプリケーションが終了処理を行ないます。作成中のスクリプトのセーブなど、十分注意して使用してください。
      また、sysexit命令の後は、 end命令を入れてHSPのスクリプトも終了させてください。 p1で指定するタイプ指定は以下の通りです。

      タイプ :  内容
      ----------------------------------
      0    : ログオフする
      1    : 再起動をする
      2    : シャットダウンをする
      3    : 電源を切る

      電源を切る場合は、「シャットダウン」→「電源を切る」の 2つを連続でリクエストするようにしてください。

      WindowsNTや2000 などリソース権限があるOSでは、管理者権限でログオンしていないと、この命令を実行することはできません。
    </Setting>
  </command>
  <command>
    <Name>pipeexec</Name>
    <Title>パイプ付き実行</Title>
    <Format>
      p1,"filename",p2
      p1=変数    : 標準出力が格納される文字列型変数名
      "filename" : 実行されるファイル名
      p2=0〜1(0) : ウィンドウ表示スイッチ
    </Format>
    <Setting>
      "filename"で指定したファイルを実行します。
      実行ファイルは、パイプを通じて標準入力、標準出力の設定取得が可能になります。 pipeexec命令は、おもにwin32コンソールアプリケーション(DOSプロンプトで動作する32bitアプリケーション)の実行を支援するための機能です。
      加えて、 16bitアプリケーションおよび、バッチファイルは指定できないので注意してください。

      "filename"で実行ファイルを指定します。フルパス指定でない場合は、標準の検索パスが使用されます。
      コマンドラインオプションを指定する場合は、ファイル名に続いて DOSプロンプトの要領で指定してください。(例:「notepad.exe readme.txt」)

      p1で指定した変数バッファに、実行時の標準出力が格納されます。
      あらかじめ「sdim buf,32000」などで大きいバッファを確保したものを指定するようにしてください。
      p2でウィンドウの表示ON/OFFを指定します。デフォルトでは、0 (表示しない)
      になります。pipeexec命令実行後は、必ず pipegetでプロセス終了までを監視してください。
    </Setting>
  </command>
  <command>
    <Name>pipeget</Name>
    <Title>パイプ付き実行監視</Title>
    <Format>
      p1
      p1=変数 : 結果が格納される文字列型変数名
    </Format>
    <Setting>
      pipeexec命令で実行されたプロセスを監視します。
      p1に、パイプの情報を取得するバッファとなる文字列型変数を指定する必要が
      あります。
      pipeexecによるファイル実行の状況は、システム変数statに返されます。

      stat値 | 内     容         | 変数p1の内容
      ---------------------------------------------------------
      0    | 実行終了          | 変化なし
      1    | 実行準備中        | 変化なし
      2    | StdOutputを取得中 | StdOutput
      3    | StdErrorを取得中  | StdError
      4    | 終了処理中        | 変化なし

      通常は、pipeexec命令の実行後はpipeget命令でstat値が0になる(実行終了)までwait/await命令を入れながら監視を続けて下さい。

      １回の実行で取得されるサイズは、p1で指定される文字列型の変数が確保しているバッファサイズまでになりますので、バッファが溢れることはありません。通常4096文字程度のバッファを割り当てるようにしていれば問題はないでしょう ( 例:「sdim buf,4096」)。
    </Setting>
  </command>
  <command>
    <Name>pipeput</Name>
    <Title>パイプに1byte送る</Title>
    <Format>
      p1
      p1=0〜255(0) : 送信コード
    </Format>
    <Setting>pipeexec命令で実行中のプロセスに対して、p1で指定したコードを標準入力として送ります。</Setting>
  </command>
  <command>
    <Name>dirlist2</Name>
    <Title>拡張ディレクトリ取得</Title>
    <Format>
      p1,"filemask",p2,p3
      p1=変数名  : ディレクトリ情報全体のサイズ
      "filemask" : 一覧のためのファイルマスク
      p2=0〜(0)  : 取得モード
      p3=0〜(0)  : ディレクトリ区切り記号
    </Format>
    <Setting>
      ディレクトリの情報を取得します。
      標準命令のdirlistよりもさらに詳しく検索することができます。
      dirlist2命令は、3つのステップで処理が完了します。

      1.dirlist2h命令で取得するものを選択
      ↓
      2.dirlist2命令で取得を開始
      ↓
      3.dirlist2r命令で結果を取得

      dirlist2命令は、決められたモードでディレクトリ情報の取得を行ないます。
      結果は、dirlist2r命令で取得することができます。
      dirlist2命令が正常に終了した場合には、システム変数statに情報を取得した
      ファイルの合計数が代入されます。取得モードの詳細は以下の通りです。

      "filemask"は、dirlist命令と同様に「*.*」のようなワイルドカード指定による検索ファイル名となります。

      p3で、取得時のディレクトリ区切り記号を指定することが可能です。0か、省略をした場合は「¥」が使用されます。

      モードの値は、合計して組み合わせることが可能です。
      モード1 (bit0) を指定した場合には、 カレントディレクトリ以下全てのディレクトリを再帰検索してファイル情報を取得します。

      モード :  取得される内容
      ---------------------------------------------------------------
      0    :  カレントディレクトリのファイル一覧
      1    :  カレントディレクトリ以下のすべてのファイル一覧
      2    :  隠しファイル、システム属性ファイルを一覧に含める
    </Setting>
  </command>
  <command>
    <Name>dirlist2h</Name>
    <Title>拡張ディレクトリ取得設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : 一覧リストフラグ
      p2=0〜(0) : リスト区切り記号
    </Format>
    <Setting>
      dirlist2命令によるディレクトリの情報取得の詳細を設定します。
      実際の情報取得の方法については、dirlist2命令の説明を参照してください。

      p1の一覧リストフラグにより指定された項目が、区切り記号により分けられテキスト情報として取得できるようになります。

      一覧リストフラグは、以下の通りです。

      フラグ : 取得される内容
      -----------------------------------------------------------------
      1   : カレントからの相対パスによるファイル名
      2   : パス名を除いたファイル名
      4   : ファイルのサイズ
      8   : ファイルの更新日付
      16   : ファイルの更新時間
      128   : カレントからの相対パス名のみ

      フラグ値は、加算して組み合わせることができます。p1が0か省略された場合は、すべてのフラグを指定したことになります。
      p2でリストを区切る記号を指定することができます。p2が0か省略された場合は、「,」が指定されます。
    </Setting>
  </command>
  <command>
    <Name>dirlist2r</Name>
    <Title>拡張ディレクトリ取得2</Title>
    <Format>
      p1
      p1=変数名 : ディレクトリ情報を取得する変数
    </Format>
    <Setting>
      dirlist2命令により取得された情報を変数に代入します。
      必ずdirlist2命令で返されたサイズ以上のメモリが確保されている変数に対して実行する必要があります。
      実際の情報取得の方法については、dirlist2命令の説明を参照してください。
    </Setting>
  </command>
  <command>
    <Name>netinit</Name>
    <Title>ネット接続の初期化</Title>
    <Format></Format>
    <Setting>
      Wininet.dllの初期化を行ないます。
      net〜で始まる命令を使用する際には、最初に１回だけ必ず実行する必要があります。
      実行後に結果がシステム変数statに格納されます。
      0ならば正常終了、それ以外はエラーが発生したことを示しています。
    </Setting>
  </command>
  <command>
    <Name>netterm</Name>
    <Title>ネット接続の終了</Title>
    <Format></Format>
    <Setting>
      Wininet.dllの終了処理を行ないます。
      通常、この命令はプログラム終了時に自動的に呼び出されるため、特にスクリプトに記述する必要はありません。
    </Setting>
  </command>
  <command>
    <Name>netexec</Name>
    <Title>最小単位の処理を実行</Title>
    <Format>
      p1
      p1 : 処理の結果が代入される変数
    </Format>
    <Setting>
      最小単位の処理を実行します。
      サーバーからの応答待ちや、ダウンロード中など時間のかかる処理を細かい単位で実行します。
      メインプログラムでは、await命令などで細かく待ち時間(ウェイト)を取りながらnetexec命令を呼び出す必要があります。

      例:
      ;	結果待ちのためのループ
      repeat
      netexec res
      if res : break
      await 50
      loop

      実行後、結果がp1で指定された変数に代入されます。
      内容が0の場合は、処理が継続中であることを意味します。
      内容が1の場合は、処理が正常に終了していることを意味します。
      内容がマイナス値の場合は、何らかのエラーが発生したことを示しています。
      statが0以外の値になった場合は、それに応じた処理を適宜スクリプト側で処理するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>netmode</Name>
    <Title>モードの取得</Title>
    <Format>
      p1
      p1 : モード値が代入される変数
    </Format>
    <Setting>
      現在の処理モードを取得します。
      p1で指定された変数にモード値が代入されます。
      モード値の内容は以下の通りです。
      httpリクエストは、INET_MODE_READYの状態で発行するようにしてください。
      ftpリクエストは、INET_MODE_FTPREADYの状態で発行するようにしてください。

      ラベル             | 値    状態
      ------------------------------------------------------
      INET_MODE_NONE     |  0    未初期化の状態
      INET_MODE_READY    |  1    待機状態
      INET_MODE_REQUEST  |  2    httpリクエスト受付
      INET_MODE_REQSEND  |  3    httpリクエスト送信中
      INET_MODE_DATAWAIT |  4    httpデータ受信中
      INET_MODE_DATAEND  |  5    httpデータ受信終了処理中
      INET_MODE_INFOREQ  |  6    http情報リクエスト送信中
      INET_MODE_INFORECV |  7    http情報データ受信中
      INET_MODE_FTPREADY |  8    ftp待機状態
      INET_MODE_FTPDIR   |  9    ftpディレクトリ情報取得中
      INET_MODE_FTPREAD  |  10   ftpファイル受信中
      INET_MODE_FTPWRITE |  11   ftpファイル送信中
      INET_MODE_FTPCMD   |  12   ftpコマンド送信終了処理中
      INET_MODE_FTPRESULT|  13   ftpサーバー返信データ受信中
      INET_MODE_ERROR    |  14   エラー状態
    </Setting>
  </command>
  <command>
    <Name>neterror</Name>
    <Title>ネットエラー文字列の取得</Title>
    <Format>
      p1
      p1 : エラー文字列が代入される変数
    </Format>
    <Setting>
      エラー発生時の詳細を示す文字列を取得します。
      p1で指定した変数に、文字列として代入されます。
    </Setting>
  </command>
  <command>
    <Name>neturl</Name>
    <Title>URLの設定</Title>
    <Format>
      "URL"
      "URL" : URLを示す文字列
    </Format>
    <Setting>
      httpリクエストを行なうURLを設定します。
      URLは、ファイル名を除いた形でスキーム名を含めて設定する必要があります。
      「http://www.onionsoft.net/hsp/index.html」の場合は、「http://www.onionsoft.net/hsp/」までを設定してください。
      httpリクエストは必ず、neturl命令によるURL設定を先に行なっておいてください。neturl命令実行の時点では、まだhttpリクエストは発行されません。
      httpリクエストの発行は、netrequest命令またはnetload命令によって行なわれます。
    </Setting>
  </command>
  <command>
    <Name>netrequest</Name>
    <Title>httpリクエスト発行</Title>
    <Format>
      "FileName"
      "FileName" : リクエストを行なうファイル名
    </Format>
    <Setting>
      httpリクエストを行ないます。
      先に、neturl命令によりファイル名を除いたURLを指定しておく必要があります。
      netrequest命令でhttpリクエストを発行した後は、netexec命令により受信処理をスクリプト側で行なう必要があります。
      受信処理を自動で行なうためのnetload命令も別途用意されています。
    </Setting>
  </command>
  <command>
    <Name>netload</Name>
    <Title>httpファイル取得</Title>
    <Format>
      "FileName"
      "FileName" : リクエストを行なうファイル名
    </Format>
    <Setting>
      httpリクエストを行ないます。
      先に、neturl命令によりファイル名を除いたURLを指定しておく必要があります。
      netload命令は、ファイルの取得が終了するまで、処理を中断します。
      手軽にファイルの取得を行なうことが可能ですが、大きなファイルや受信状態の悪い場合などは、そのまま画面が停止したままになる可能性もあるので注意してください。
      ファイルの受信中に、並行して別な処理を行ないたい場合には、netrequest命令を使用してhttpリクエストを行なってください。
    </Setting>
  </command>
  <command>
    <Name>netfileinfo</Name>
    <Title>httpファイル情報取得</Title>
    <Format>
      p1,"FileName"
      p1         : ファイル情報が代入される変数名
      "FileName" : リクエストを行なうファイル名
    </Format>
    <Setting>
      httpサーバー上にあるファイル情報を取得します。
      先に、neturl命令によりファイル名を除いたURLを指定しておく必要があります。
      取得に成功すると、システム変数statの値が0となり、p1で指定した変数に文字列型でサーバーが返した情報文字列が代入されます。
      取得に失敗した場合は、システム変数statに0以外が代入されます。
      サーバーが返す情報の種類は、httpサーバーによって異なります。
      詳しくは、RFCなどhttpプロトコルの解説を参照してください。
      netfileinfo命令は、ファイルの取得が終了するまで、処理を中断します。
    </Setting>
  </command>
  <command>
    <Name>netdlname</Name>
    <Title>ダウンロード名の設定</Title>
    <Format>
      "FileName"
      "FileName" : ダウンロードされた時のファイル名
    </Format>
    <Setting>
      ファイルを取得する際のファイル名を設定します。
      netdlname命令によってファイル名を設定していない場合は、httpリクエストを行なったファイル名が使用されます。
      netdlname命令に、空の文字列("")を指定した場合も、httpリクエストを行なったファイル名が使用されます。
    </Setting>
  </command>
  <command>
    <Name>netproxy</Name>
    <Title>プロキシの設定</Title>
    <Format>
      "ServerName",p1,p2
      "ServerName" : リクエストを行なうファイル名
      p1 (0)       : ポート番号
      p2 (0)       : ローカル接続フラグ
    </Format>
    <Setting>
      http接続の際に使用されるプロキシ(代理)サーバーを設定します。
      "ServerName"で、プロキシサーバー名を設定します。
      空の文字列("")を指定した場合には、プロキシは設定されません。
      p1でhttpが使用するプロキシサーバーのポート番号を指定します。
      p2で、ローカルアドレスをプロキシ経由のアクセスから除外するかどうかを設定します。1の場合は、ローカルアドレスのみプロキシから除外されます。0の場合は、ローカルアドレスも含めてプロキシを使用します。
      netproxy命令が実行されると、それまでのセッションが解除され、neturl命令や、netheader命令による設定はリセットされます。

      例:
      netinit
      if stat : dialog "ネット接続できません。" : end
      netproxy "proxy_server",8080,1
      neturl "http://www.onionsoft.net/hsp/"
      netload "index.html"
    </Setting>
  </command>
  <command>
    <Name>netagent</Name>
    <Title>エージェントの設定</Title>
    <Format>
      "AgentName"
      "AgentName" : 設定するエージェント名
    </Format>
    <Setting>
      http接続の際にサーバーに渡されるエージェント情報の文字列を設定します。"AgentName"で指定したエージェント名が設定されます。
      空の文字列("")を指定した場合には、デフォルトの設定になります。
      netagent命令が実行されると、それまでのセッションが解除され、neturl命令や、netheader命令による設定はリセットされます。
    </Setting>
  </command>
  <command>
    <Name>netheader</Name>
    <Title>ヘッダ文字列の設定</Title>
    <Format>
      "HeaderString"
      "HeaderString" : ヘッダに追加される文字列
    </Format>
    <Setting>
      http接続の際にサーバーに渡されるヘッダ文字列を設定します。
      空の文字列("")を指定した場合には、無設定になります。
      ヘッダ文字列は、通常設定する必要ありませんが、何からの付加情報や動作設定を行なう場合に使用することができます。
      netheader命令で設定したヘッダ文字列は、それ以降のリクエストすべてに適用されます。

      例:
      ; リファラーを追加する
      netheader "Referer:http://www.onionsoft.net/¥n¥n"
    </Setting>
  </command>
  <command>
    <Name>netsize</Name>
    <Title>ファイル受信サイズの取得</Title>
    <Format>
      p1
      p1 : ファイル受信サイズが代入される変数
    </Format>
    <Setting>
      netrequest命令で発行されたhttpリクエストに対するファイルがどれだけのサイズを受信したかを取得します。
      p1で指定された変数にファイル受信サイズが代入されます。
      ファイル受信サイズは、netexec命令で受信が行なわれた内容を調べるためのものです。あらかじめ、ファイル情報取得でファイルサイズを調べておけば、進行の割合を計ることが可能です。
    </Setting>
  </command>
  <command>
    <Name>filecrc</Name>
    <Title>ファイルのCRC32を取得</Title>
    <Format>
      p1,"FileName"
      p1         : CRC値が代入される変数名
      "FileName" : CRCチェックを行なうファイル名
    </Format>
    <Setting>
      指定されたファイルのCRC32を求めてp1の変数に代入します。
      CRC32は、ファイルの内容をもとに算出された32bitの数値です。
      ファイル内容のチェックなどに使用することができます。
    </Setting>
  </command>
  <command>
    <Name>filemd5</Name>
    <Title>ファイルのMD5を取得</Title>
    <Format>
      p1,"FileName"
      p1         : MD5値が代入される変数名
      "FileName" : MD5チェックを行なうファイル名
    </Format>
    <Setting>
      指定されたファイルのMD5を求めてp1の変数に代入します。
      MD5値は、文字列型で「f96b697d7cb7938d525a2f31aaf161d0」のような32文字の16進数として表現されます。
      MD5値は、ファイルの内容を一意に表わすハッシュ値として使用することができます。詳しくは、MD5についての資料などを参照してください。
      ファイル内容のチェックなどに使用することができます。
    </Setting>
  </command>
  <command>
    <Name>ftpopen</Name>
    <Title>FTPセッションの開始</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1 : ftpサーバーアドレス(文字列)
      p2 : ftpログインユーザー名(文字列)
      p3 : ftpログインユーザーパスワード(文字列)
      p4 : ポート番号(省略可能)
      p5 : PASSIVEモードフラグ(省略可能)
    </Format>
    <Setting>
      ftpサーバーに接続してセッションを開始します。
      p1にサーバーのアドレス、p2にユーザー名、p3にパスワードを指定してftpに接続します。
      p4パラメーターでポート番号を指定することができます。
      p4の指定を省略した場合は、標準のポート番号が使用されます。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      p5パラメーターで接続時のPASSIVEモードフラグを設定することができます。
      p5に1を設定した場合は、PASSIVEモードでftp接続を行ないます。0または省略した場合は、通常のftp接続となります。

      あらかじめ、netinit命令によって初期化を行なう必要があります。
      ftpセッションを開始した後は、ftp関連命令のみ使用することができます。httpなど他のネット操作を行なう場合には、必ずftpclose命令によりftpセッションを終了させるようにしてください。
    </Setting>
  </command>
  <command>
    <Name>ftpclose</Name>
    <Title>FTPセッションの終了</Title>
    <Format></Format>
    <Setting>ftpopen命令で開始されたセッションを終了させます。</Setting>
  </command>
  <command>
    <Name>ftpresult</Name>
    <Title>FTP処理結果文字列の取得</Title>
    <Format>
      p1
      p1 : FTP処理結果文字列が代入される変数
    </Format>
    <Setting>
      ftp関連命令による処理に対するサーバーの返信メッセージを
      取得して、p1に指定された変数に代入します。
      p1の変数には、文字列データとして代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpdir</Name>
    <Title>FTPディレクトリ移動</Title>
    <Format>
      p1,p2
      p1 : 現在のディレクトリ位置が代入される変数
      p2 : 移動先のディレクトリ名(文字列)
    </Format>
    <Setting>
      p1で指定した変数に、ftpサーバー上のカレントディレクトリ名を文字列データとして代入します。
      p2にディレクトリ名を指定した場合には、その場所へ移動を行ないます。
      p2の指定を省略した場合には、ディレクトリ移動は行なわれません。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpdirlist</Name>
    <Title>FTPディレクトリリスト取得1</Title>
    <Format></Format>
    <Setting>
      ftpサーバー上のカレントディレクトリにあるファイルリストを取得するためのリクエストを行ないます。
      実際のファイルリストは、ftpdirlist2命令で行ないます。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpdirlist2</Name>
    <Title>FTPディレクトリリスト取得2</Title>
    <Format>
      p1
      p1 : ファイルリストが代入される変数
    </Format>
    <Setting>
      この命令は、必ずftpopen命令によりftpセッションを開始し、ftpdirlist命令によりファイルリスト取得が終了した後で使用してください。
      以下は、ファイルリスト取得するまでの例です。

      例:
      ;	結果待ちのためのループ
      ftpdirlist
      repeat
      netexec mode
      if res : break
      await 50
      loop
      ftpdirlist2 res

      ファイルリスト取得は、ftpdirlist命令によるリクエスト、netexec命令による受信待ち、ftpdirlist2命令による結果の取得という３つの手順に分けて行なう必要があります。
      p1に代入されるファイルリストは、１行あたり１エントリごとに区切られている複数行文字列データになります。
      １行は、「"ファイル名"」、ファイルサイズ、更新日時の順番に「,」で区切られた形になります。
    </Setting>
  </command>
  <command>
    <Name>ftpcmd</Name>
    <Title>FTPコマンドの実行</Title>
    <Format>
      p1
      p1 : 実行するFTPコマンド文字列
    </Format>
    <Setting>
      p1で指定されたFTPコマンドを実行します。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftprmdir</Name>
    <Title>FTPディレクトリの削除</Title>
    <Format>
      p1
      p1 : 削除するディレクトリを示す文字列
    </Format>
    <Setting>
      p1で指定されたディレクトリを削除します。
      実行に成功した場合は、システム変数statに0が代入され、
      失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpmkdir</Name>
    <Title>FTPディレクトリの作成</Title>
    <Format>
      p1
      p1 : 作成するディレクトリを示す文字列
    </Format>
    <Setting>
      p1で指定されたディレクトリを作成します。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpget</Name>
    <Title>FTPファイル取得</Title>
    <Format>
      p1,p2,p3
      p1     : サーバー上から取得するファイル名(文字列)
      p2("") : ローカルに作成されるファイル名(文字列)
      p3(0)  : 転送モード(0=バイナリ/1=アスキー)
    </Format>
    <Setting>
      ftpサーバー上のファイルを取得します。
      p1でサーバー上のファイル名を指定します。
      p2でダウンロードして作成されるファイル名を指定します。
      p2の指定を省略または""にした場合は、p1と同じ名前が使用されます。
      p3で転送モードを指定します。転送モードを省略または0に指定した場合はバイナリデータとして、1に指定した場合は、アスキーデータとして転送を行ないます。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpput</Name>
    <Title>FTPファイル送信</Title>
    <Format>
      p1,p2,p3
      p1     : サーバー上に作成するファイル名(文字列)
      p2("") : ローカルから送信されるファイル名(文字列)
      p3(0)  : 転送モード(0=バイナリ/1=アスキー)
    </Format>
    <Setting>
      ftpサーバー上にファイルを送信します。
      p1でサーバー上に作成するファイル名を指定します。
      p2でローカルから送信されるファイル名を指定します。
      p2の指定を省略または""にした場合は、p1と同じ名前が使用されます。
      p3で転送モードを指定します。転送モードを省略または0に指定した場合はバイナリデータとして、1に指定した場合は、アスキーデータとして転送を行ないます。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftprename</Name>
    <Title>FTPファイル名前変更</Title>
    <Format>
      p1,p2
      p1 : 変更元のファイル名(文字列)
      p2 : 新しいファイル名(文字列)
    </Format>
    <Setting>
      ftpサーバー上のファイル名を変更します。
      p1で変更元のファイル名を、p2で新しいファイル名を指定します。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>ftpdelete</Name>
    <Title>FTPファイル削除</Title>
    <Format>
      p1
      p1 : 削除するファイル名(文字列)
    </Format>
    <Setting>
      ftpサーバー上のファイルを削除します。
      実行に成功した場合は、システム変数statに0が代入され、失敗した場合はそれ以外の値が代入されます。
      この命令は、必ずftpopen命令によりftpセッションを開始してから使用してください。
    </Setting>
  </command>
  <command>
    <Name>netrequest_get</Name>
    <Title>httpリクエスト発行(GET)</Title>
    <Format>
      "FileName"
      "FileName" : リクエストを行なうファイル名
    </Format>
    <Setting>
      httpリクエストを行ないます。
      netrequest命令と同様ですが、ダウンロードしたデータイメージをファイルではなく、メモリ上のデータとして取得できます。

      "FileName"で、リクエストを行なうファイル名を指定します。
      先に、neturl命令によりファイル名を除いたURLを指定しておく必要があります。

      netrequest命令でhttpリクエストを発行した後は、netexec命令により受信処理を
      スクリプト側で行なう必要があります。
      処理が完了した後は、netgetv命令により任意の変数でデータを受け取ることができます。
      POST形式でCGIにデータをリクエストする場合は、netrequest_post命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>netrequest_post</Name>
    <Title>httpリクエスト発行(POST)</Title>
    <Format>
      "FileName",p1
      "FileName" : リクエストを行なうファイル名
      p1         : POST用のデータを格納した文字列型変数名
    </Format>
    <Setting>
      httpリクエストを行ないます。
      netrequest命令と同様ですが、ダウンロードしたデータイメージをファイルではなく、メモリ上のデータとして取得できます。
      また、POST形式によるCGIパラメーター受け渡しに対応しています。

      "FileName"で、リクエストを行なうファイル名を指定します。
      先に、neturl命令によりファイル名を除いたURLを指定しておく必要があります。
      p1に、POST用のデータを格納した変数名を指定します。
      あらかじめ、変数は文字列型でPOST形式のデータを格納しておく必要があります。
      POST形式のデータは、GET形式のURLで指定される「&amp;」で区切られたパラメーターと同様のものになります。
      ただし、バイナリデータを送付する場合は、データを文字列にエンコードする必要があります。
      netrequest_post命令は、渡された文字列をそのままPOSTデータとして発行するため、このエンコードは事前に行なっておいてください。

      例:

      neturl "http://www.onionsoft.net/hsp/beta/"


      prm = "mode=find&amp;cond=and&amp;log=0&amp;word=script"
      netrequest_post "betabbs.cgi",prm

      netrequest命令でhttpリクエストを発行した後は、netexec命令により受信処理をスクリプト側で行なう必要があります。
      処理が完了した後は、netgetv命令により任意の変数でデータを受け取ることができます。
      GET形式でCGIにデータをリクエストする場合は、netrequest_get命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>netgetv</Name>
    <Title>httpリクエストの結果を取得</Title>
    <Format>
      p1
      p1 : データが代入される変数
    </Format>
    <Setting>
      netrequest_get、netrequest_post命令によるhttpリクエストの結果を取得します。
      必ず、netexec命令による受信処理で、ダウンロードが完了したことを確認してから、データを取得するようにしてください。
      p1で指定された変数は、自動的に必要なサイズを確保した文字列型として初期化されます。
      (あらかじめ変数を初期化したり、メモリを確保しておく必要はありません。)
      命令実行後に、システム変数statにデータサイズが代入されます。
    </Setting>
  </command>
  <command>
    <Name>varmd5</Name>
    <Title>変数バッファのMD5を取得</Title>
    <Format>
      p1,p2,p3
      p1    : MD5値が代入される変数名
      p2    : 参照される変数名
      p3(0) : バッファサイズ
    </Format>
    <Setting>
      指定された変数バッファの内容からMD5を求めてp1の変数に代入します。
      MD5値は、文字列型で「f96b697d7cb7938d525a2f31aaf161d0」のような32文字の16進数として表現されます。
      MD5値は、メモリの内容を一意に表わすハッシュ値として使用することができます。詳しくは、MD5についての資料などを参照してください。
      ファイルの内容からMD5を求める場合は、filemd5命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>b64encode</Name>
    <Title>BASE64エンコード</Title>
    <Format>
      p1,p2,p3
      p1     : BASE64変換された文字列が代入される変数名
      p2     : 変換元データを持つ変数名
      p3(-1) : バッファサイズ
    </Format>
    <Setting>
      p2で指定された変数バッファの内容をBASE64エンコード(変換)してp1の変数に代入します。
      p3の値を省略またはマイナス値にした場合は、p2に含まれるデータを文字列として自動的にサイズが決定されます。
      BASE64は、文字列型として格納されます。バイナリデータなどを一時的に文字列に変換する場合などに使用されます。
      BASE64形式の文字列をもとのデータにデコード(戻す)場合は、b64decode命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>b64decode</Name>
    <Title>BASE64デコード</Title>
    <Format>
      p1,p2,p3
      p1     : デコードされたデータが代入される変数名
      p2     : BASE64形式のデータを持つ変数名
      p3(-1) : バッファサイズ
    </Format>
    <Setting>
      p2で指定された変数バッファの内容をBASE64デコードしてp1の変数に代入します。
      p2の変数には、BASE64エンコードされた文字列が代入されている必要があります。
    </Setting>
  </command>
  <command>
    <Name>rc4encode</Name>
    <Title>RC4エンコード</Title>
    <Format>
      p1,p2,p3
      p1     : 変数名
      p2     : パスワード文字列
      p3(-1) : バッファサイズ
    </Format>
    <Setting>
      p1で指定された変数バッファの内容をRC4互換(ARCFOUR)アルゴリズムで暗号化します。
      暗号化の際に、p2で指定されたパスワード文字列をキーとして使用します。
      p3でバッファサイズを指定します。p3を省略またはマイナス値とした場合には、変数バッファの内容を文字列として自動的にサイズを決定します。
      RC4暗号では、暗号化する前と後でデータサイズに変更はありません。
      また、エンコードとデコードは同じプロセスで行われるため、エンコードを行ったデータに対して、再度同じキーで暗号化することでもとのデータに復号されます。
    </Setting>
  </command>
  <command>
    <Name>urlencode</Name>
    <Title>URLエンコード</Title>
    <Format>
      p1,p2
      p1     : URLエンコードされた文字列が代入される変数名
      p2     : 変換元データを持つ変数名
    </Format>
    <Setting>
      p2で指定された変数バッファの内容(文字列)をURLエンコード(変換)してp1の変数に代入します。
      p1で指定される変数は自動的に文字列型として初期化されます。
      URLエンコードで出力される文字数は最大で4095文字までの制限がありますので注意してください。
      URLエンコード形式の文字列をもとのデータにデコード(戻す)場合は、urldecode命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>urldecode</Name>
    <Title>URLデコード</Title>
    <Format>
      p1,p2
      p1     : デコードされたデータが代入される変数名
      p2     : URLエンコード形式のデータを持つ変数名
    </Format>
    <Setting>
      URLエンコードされた文字列を元の文字列に戻します。
      p2で指定された変数バッファの内容をデコードしてp1の変数に代入します。
      デコードで出力される文字数は最大で4095文字までの制限がありますので注意してください。
    </Setting>
  </command>
  <command>
    <Name>jsonopen</Name>
    <Title>JSON形式を開く</Title>
    <Format>
      p1,p2
      p1     : JSONポインタ値が代入される変数名
      p2     : JSON形式のデータを持つ変数名
    </Format>
    <Setting>
      JSON形式の文字列を読み込み、内容にアクセス可能な状態にします。
      p2で指定された変数に格納されている文字列をJSON形式とみなして、データのパースを行ないます。
      読み込み後は、p1で指定された変数にJSONポインタ値が代入されます。
      JSON形式を扱う命令でJSONポインタ値を指定することにより、各種データにアクセスすることが可能になります。
      jsonopen命令でデータを読み込ませた後は、必ず最後にjsonclose命令を実行してメモリを解放する必要があります。
    </Setting>
  </command>
  <command>
    <Name>jsonclose</Name>
    <Title>JSON形式の終了処理</Title>
    <Format></Format>
    <Setting>jsonopen命令で読み込ませたデータのメモリを解放します。</Setting>
  </command>
  <command>
    <Name>jsonout</Name>
    <Title>JSON形式データを変数に出力する</Title>
    <Format>
      p1,p2
      p1     : JSON形式のデータが代入される変数名
      p2(-1) : JSONポインタ値
    </Format>
    <Setting>
      JSON形式データをp1で指定した変数に出力します。
      p2で出力するJSONデータのポインタ値を指定します。
      p2を省略またはマイナス値とした場合は、jsonopen命令で読み込まれたデータが対象になります。
      p1で指定された変数は文字列型として初期化されサイズも自動的に確保されます。
    </Setting>
  </command>
  <command>
    <Name>jsongetobj</Name>
    <Title>JSONオブジェクトを得る</Title>
    <Format>
      p1,"name",p2
      p1     : JSONポインタ値が代入される変数名
      "name" : オブジェクト識別名
      p2(-1) : JSONポインタ値
    </Format>
    <Setting>
      "name"で指定した名前のオブジェクトを取得し、p1で指定した変数にJSONポインタ値を代入します。
      p2で検索対象となるオブジェクト(JSONポインタ値)を指定します。
      p2を省略またはマイナス値にするとjsonopen命令で読み込ませたデータのルート階層が使用されます。
      指定された名前が存在しなかった場合はJSONポインタ値として0が代入されます。
      p2に空(NULL)のJSONポインタ値を指定した場合は、システム変数statが1になり実行は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>jsonnext</Name>
    <Title>次のJSONオブジェクトを得る</Title>
    <Format>
      p1,p2,p3
      p1     : JSONポインタ値が代入される変数名
      p2(-1) : JSONポインタ値
      p3(0)  : 取得オプション
    </Format>
    <Setting>
      p2で指定されたJSONオブジェクト(JSONポインタ値)に関連する値を取得し、p1で指定した変数に代入します。
      取得される値は、p3の取得オプションによって変わります。p3は以下の値を指定することができます。

      取得オプション   内容
      --------------------------------------------
      0              次のオブジェクト(next)
      1              前のオブジェクト(prev)
      2              子階層のオブジェクト(child)
      3              オブジェクトのtype値

      jsonnext命令により、同じ階層にあるオブジェクトや、子階層(配列)内のオブジェクトを得ることができます。
      p2を省略またはマイナス値にするとjsonopen命令で読み込ませたデータのルート階層が使用されます。
      指定されたJSONオブジェクトが存在しなかった場合はJSONポインタ値として0が代入されます。
      p2に空(NULL)のJSONポインタ値を指定した場合は、システム変数statが1になり実行は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>jsongets</Name>
    <Title>JSONオブジェクトから文字列を得る</Title>
    <Format>
      p1,"name",p2
      p1     : 取得された文字列が代入される変数名
      "name" : オブジェクト識別名
      p2(-1) : JSONポインタ値
    </Format>
    <Setting>
      オブジェクトに記録された文字列を取得し、p1で指定した変数に代入します。
      p2で対象となるオブジェクト(JSONポインタ値)を指定します。
      "name"を省略または中身のない文字列("")に指定した場合は、p2で指定されたオブジェクトそのものに記録されている文字列を取得します。
      "name"で名前を指定した場合、p2で指定されたオブジェクトと同階層にあるオブジェクトから同じ名前を持つオブジェクトを検索し、値を取得します。
      指定された名前が存在しない場合は、p1に代入は行なわれずにシステム変数statに1を代入して終了します。
      p2を省略またはマイナス値にするとjsonopen命令で読み込ませたデータのルート階層が使用されます。
      p2に空(NULL)のJSONポインタ値を指定した場合は、システム変数statが1になり実行は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>jsongeti</Name>
    <Title>JSONオブジェクトから整数値を得る</Title>
    <Format>
      p1,"name",p2
      p1     : 取得された整数値が代入される変数名
      "name" : オブジェクト識別名
      p2(-1) : JSONポインタ値
    </Format>
    <Setting>
      オブジェクトに記録された整数値を取得し、p1で指定した変数に代入します。
      p2で対象となるオブジェクト(JSONポインタ値)を指定します。
      "name"を省略または中身のない文字列("")に指定した場合は、p2で指定されたオブジェクトそのものに記録されている整数値を取得します。
      "name"で名前を指定した場合、p2で指定されたオブジェクトと同階層にあるオブジェクトから同じ名前を持つオブジェクトを検索し、値を取得します。
      指定された名前が存在しない場合は、p1に代入は行なわれずにシステム変数statに1を代入して終了します。
      p2を省略またはマイナス値にするとjsonopen命令で読み込ませたデータのルート階層が使用されます。
      p2に空(NULL)のJSONポインタ値を指定した場合は、システム変数statが1になり実行は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>jsonnewobj</Name>
    <Title>JSONオブジェクトを新規作成</Title>
    <Format>
      p1,p2,"name"
      p1     : JSONポインタ値が代入される変数名
      p2(-1) : 親のJSONポインタ値
      "name" : オブジェクト識別名
    </Format>
    <Setting>
      JSONオブジェクトを新規作成して、p1で指定した変数にJSONポインタ値を代入します。
      p2で親になるオブジェクト(JSONポインタ値)を指定します。
      p2を省略またはマイナス値にするとjsonopen命令で読み込ませたデータのルート階層が使用されます。
      ユーザーが独自にJSONオブジェクトを作成する際に使用します。
      JSONオブジェクトを新規作成した後は、最後に最も親の階層をjsondelobj命令で削除する必要があるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>jsondelobj</Name>
    <Title>JSONオブジェクトを削除</Title>
    <Format>
      p1
      p1(0) : JSONポインタ値
    </Format>
    <Setting>
      JSONオブジェクトを削除します。
      jsonnewobj命令によりJSONオブジェクトを新規作成した後は、最後に最も親の階層をjsondelobj命令で削除する必要があるので注意してください。
      jsonopen命令で読み込ませたデータは、jsonclose命令により解放してください。(jsondelobj命令で解放する必要はありません。)
    </Setting>
  </command>
  <command>
    <Name>jsonsetprm</Name>
    <Title>JSONオブジェクトに値を設定する</Title>
    <Format>
      p1,p2,p3
      p1(0)  : JSONポインタ値
      p2(0)  : 設定値
      p3(0)  : 設定オプション
    </Format>
    <Setting>
      p1で指定されたJSONオブジェクト(JSONポインタ値)に関連するパラメーターを設定します。
      設定するパラメーターは、p3のオプションによって変わります。p3は以下の値を指定することができます。

      設定オプション   内容
      --------------------------------------------
      0              次のオブジェクト(next)
      1              前のオブジェクト(prev)
      2              子階層のオブジェクト(child)
      3              オブジェクトのtype値
      4              オブジェクトに設定された整数値

      jsonsetprm命令により、子階層(配列)内のオブジェクトやオブジェクトの連結を直接設定することができます。
      既に設定されている値を上書きすることで、階層構造が壊れる可能性がありますので、設定する場合には注意するようにしてください。
      p1に空(NULL)のJSONポインタ値を指定した場合は、システム変数statが1になり実行は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>jsonputs</Name>
    <Title>JSONオブジェクトに文字列を追加</Title>
    <Format>
      p1,"name","strings"
      p1(0)     : JSONポインタ値
      "name"    : オブジェクト識別名
      "strings" : 設定する文字列
    </Format>
    <Setting>
      p1で指定されたJSONオブジェクト(JSONポインタ値)に文字列のデータを持つオブジェクトを追加します。
      "name"で、追加されるオブジェクトの識別名を、"strings"で文字列を指定します。
    </Setting>
  </command>
  <command>
    <Name>jsonputi</Name>
    <Title>JSONオブジェクトに数値を追加</Title>
    <Format>
      p1,"name",p2,p3
      p1(0)  : JSONポインタ値
      "name" : オブジェクト識別名
      p2(0)  : 設定する値
      p3(0)  : 設定オプション
    </Format>
    <Setting>
      p1で指定されたJSONオブジェクト(JSONポインタ値)に数値のデータを持つオブジェクトを追加します。
      "name"で、追加されるオブジェクトの識別名を、p2で数値を指定します。
      p
      設定する数値の種類は、p3のオプションによって変わります。p3は以下の値を指定することができます。

      設定オプション   内容
      --------------------------------------------
      0              整数値
      1              BOOL値(False,True)

      設定オプションがBOOL値の場合は、p2の値が0以外ならばTrueを、0ならばFalseが設定されます。
    </Setting>
  </command>
  <command>
    <Name>jsonnkf</Name>
    <Title>JSON文字列変換の設定</Title>
    <Format>
      "option1","option2"
      "option1" : 取得時変換オプション
      "option2" : 設定時変換オプション
    </Format>
    <Setting>
      JSONで扱う文字列のコード変換を設定します。
      jsongets、jsonputs命令で使用する文字列を変換することで、JSONデータを任意の文字コードで保持することができます。
      "option1"及び、"option2"パラメーターにより、NKFによるコード変換パラメーターを指定します。
      "option1"は、jsongets命令による文字列取得時に、"option2"は、jsonputs命令による文字列設定時に使用されます。
      オプションの文字列は、nkfcnv命令で使用されるものと同じです。
      NKFの変換でSJISの入出力を指定することにより、HSPで扱う文字コードをそのまま指定することができるようになります。
    </Setting>
  </command>
  <command>
    <Name>nkfcnv</Name>
    <Title>NKFによる文字コード変換を行なう</Title>
    <Format>
      p1,p2,"option",p3,p4
      p1 : 変換後の文字列が代入される変数
      p2 : 変換元の文字列が代入されている変数
      "option" : NKF変換オプション
      p3(-1) : 変換元の文字列サイズ
      p4(-1) : 出力先の最大バッファサイズ
    </Format>
    <Setting>
      p2で指定された変数に格納されている文字列に対して、NKFによる文字コード変換を行ない、結果をp1で指定された変数に代入します。
      "option"でNKFの変換オプションを指定することができます。これにより、入力される文字コードと出力される文字コードを任意に指定することができます。
      "option"パラメーターを省略した場合は、入力コードを自動判別してSJISに変換されます。
      主なオプションの一覧は以下の通りです。(オプション文字列は複数を続けて指定することも可能です)これ以外にも、多くの指定が可能です。詳しくは、doclibフォルダ内のnkf_doc.txtを参照してください。

      設定オプション   内容
      --------------------------------------------
      j  	      JISに変換する
      e  	      EUCに変換する
      s  	      SJISに変換する
      w  	      UTF8に変換する
      J  	      変換元はJIS(ISO-2022-JP)を仮定する。
      E  	      変換元はEUC(AT&amp;T)を仮定する。
      S  	      変換元はSJISを仮定する
      W  	      変換元はUTF-8を仮定する
      W16       変換元はUTF-16 (Little Endian)を仮定する
      W16B      変換元はUTF-16 (Big Endian)を仮定する

      p3で、変換元の文字列サイズ(byte数)を指定します。p3を省略するかマイナス値の場合は、入力がC言語形式のansi文字列として自動計算されます。
      p4で、出力先のバッファサイズを指定します。このサイズを超えた変換は行なわれません。p4を省略するかマイナス値の場合は、デフォルトサイズ(32KB)が使用されます。
      p1で指定された変数は、自動的に文字列サイズのバッファを確保した上で初期化されます。あらかじめsdimで初期化しておく必要はありません。
    </Setting>
  </command>
  <command>
    <Name>nkfguess</Name>
    <Title>NKFによる文字コード認識結果を取得する</Title>
    <Format>
      p1
      p1 : 結果の文字列が代入される変数
    </Format>
    <Setting>
      nkfcnv命令により変換された際に、認識された変換元の文字コードを取得します。
      結果は、p1で指定された変数に文字列として代入されます。必ず、先にnkfcnv命令で変換を行なっておく必要があります。
    </Setting>
  </command>
  <command>
    <Name>getenv</Name>
    <Title>環境変数の取得</Title>
    <Format>
      p1,"name"
      p1 : 結果の文字列が代入される変数
      "name" : 環境変数名
    </Format>
    <Setting>
      環境変数の値を取得し、変数に代入します。
      結果は文字列型で代入されます。
      変数のバッファは文字列に合わせて自動的に調整されます。
    </Setting>
  </command>
  <command>
    <Name>getctime</Name>
    <Title>文字列による日付と時刻の取得</Title>
    <Format>
      p1,p2
      p1 : 結果の文字列が代入される変数
      mode(0) : 取得される形式の指定
    </Format>
    <Setting>
      日付と時刻を文字列で取得します。
      modeの値により、取得するフォーマットを指定します。

      mode   内容
      ---------------------------------------------
      0    C言語のasctime関数による現在時刻(ローカル)
      例: Sun Nov  6 08:49:37 1994
      1    C言語のasctime関数による現在時刻(GMT/UTC)
      例: Sun Nov  6 08:49:37 1994
      2    RFC 1123で定義される日付フォーマット
      例: Sun, 06 Nov 1994 08:49:37 GMT
    </Setting>
  </command>
  <command>
    <Name>getenvprm</Name>
    <Title>指定文字列要素の取得</Title>
    <Format>
      p1, p2, "name", code
      p1 : 結果の文字列が代入される変数
      p2 : 検索内容が代入されている文字列型変数
      "name" : 要素名
      code : 区切り文字コード(省略時は'&amp;')
    </Format>
    <Setting>
      getenvprm命令は、「A=123&amp;B=456&amp;C=789」のように特定の区切り
      文字コード(この場合は「&amp;」)で区切られた文字列の中から、
      先頭部分が"name"と一致したものを取り出します。
      CGIのパラメーター受け渡しなどで複数の情報が文字列として
      渡されている中から、特定の項目を取り出す場合に使用します。
      たとえば、変数aに「A=123&amp;B=456&amp;C=789」が代入されている場合、
      「getenvprm res,a,"B="」を実行すると、変数resには「789」という
      文字列が代入されます。
      p2で指定された変数は、文字列型であらかじめ初期化されている
      必要があります。
      該当する要素名がなかった場合は、""(長さ0の文字列)が
      代入されます。
      codeに区切り文字のコードを指定することが可能です。
      codeの指定を省略した場合は、'&amp;'が使用されます。
    </Setting>
  </command>
  <command>
    <Name>M_LOG2E</Name>
    <Title>2を底とするネイピア数の対数</Title>
    <Format></Format>
    <Setting>
      2を底とするネイピア数の対数を表す定数です。
      2を底とするネイピア数の対数とは、log2(m_e)のことを指します。
    </Setting>
  </command>
  <command>
    <Name>M_LOG10E</Name>
    <Title>10を底とするネイピア数の対数</Title>
    <Format></Format>
    <Setting>
      10を底とするネイピア数の対数を表す定数です。
      10を底とするネイピア数の対数とは、log10(m_e)のことを指します。
    </Setting>
  </command>
  <command>
    <Name>M_LN2</Name>
    <Title>ネイピア数を底とした2の対数</Title>
    <Format></Format>
    <Setting>
      ネイピア数を底とした2の対数を表す定数です。
      ネイピア数を底とした2の対数とは、logf(2)のことを指します。
    </Setting>
  </command>
  <command>
    <Name>M_LN10</Name>
    <Title>ネイピア数を底とした10の対数</Title>
    <Format></Format>
    <Setting>
      ネイピア数を底とした10の対数を表す定数です。
      ネイピア数を底とした10の対数とは、logf(10)のことを指します。
    </Setting>
  </command>
  <command>
    <Name>M_E</Name>
    <Title>ネイピア数</Title>
    <Format></Format>
    <Setting>ネイピア数（自然対数の底）eを表す定数です。</Setting>
  </command>
  <command>
    <Name>M_SQRTPI</Name>
    <Title>円周率の平方根</Title>
    <Format></Format>
    <Setting>円周率の平方根を表す定数です。</Setting>
  </command>
  <command>
    <Name>M_SQRT2</Name>
    <Title>2の平方根</Title>
    <Format></Format>
    <Setting>2の平方根を表す定数です。</Setting>
  </command>
  <command>
    <Name>M_SQRT3</Name>
    <Title>3の累乗根</Title>
    <Format></Format>
    <Setting>3の累乗根を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_DIG</Name>
    <Title>10進数で有効な桁数</Title>
    <Format></Format>
    <Setting>10進数で有効な桁数を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_EPSILON</Name>
    <Title>1.0とその次に大きい値との差</Title>
    <Format></Format>
    <Setting>1.0とその次に大きい値との差を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MANT_DIG</Name>
    <Title>仮数部のbit数</Title>
    <Format></Format>
    <Setting>実数型の数値を表す際に用いる仮数部のbit数を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MAX</Name>
    <Title>実数の最大値</Title>
    <Format></Format>
    <Setting>実数で表現できる最大値を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MAX_10_EXP</Name>
    <Title>10進数での指数部の最大値</Title>
    <Format></Format>
    <Setting>指数部の最大値を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MAX_EXP</Name>
    <Title>2進数での指数部の最大値</Title>
    <Format></Format>
    <Setting>指数部の最大値を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MIN</Name>
    <Title>0を超える最小の値</Title>
    <Format></Format>
    <Setting>0を超える最小の値を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MIN_10_EXP</Name>
    <Title>10進数での指数部の最小値</Title>
    <Format></Format>
    <Setting>指数部の最小値を表す定数です。</Setting>
  </command>
  <command>
    <Name>DBL_MIN_EXP</Name>
    <Title>2進数での指数部の最小値</Title>
    <Format></Format>
    <Setting>指数部の最小値を表す定数です。</Setting>
  </command>
  <command>
    <Name>INT_DIGIT</Name>
    <Title>2進数で有効な桁数</Title>
    <Format></Format>
    <Setting>2進数で有効な桁数を表す定数です。</Setting>
  </command>
  <command>
    <Name>INT_DIGIT10</Name>
    <Title>10進数で有効な桁数</Title>
    <Format></Format>
    <Setting>10進数で有効な桁数を表す定数です。</Setting>
  </command>
  <command>
    <Name>INT_MAX</Name>
    <Title>最大値</Title>
    <Format></Format>
    <Setting>整数で表現できる最大値を表す定数です。</Setting>
  </command>
  <command>
    <Name>INT_MIN</Name>
    <Title>最小値</Title>
    <Format></Format>
    <Setting>整数で表現できる最小の値を表す定数です。</Setting>
  </command>
  <command>
    <Name>pow</Name>
    <Title>累乗（べき乗）を求める</Title>
    <Format>
      (p1, p2)
      p1 : 底（0以上）
      p2 : 指数
    </Format>
    <Setting>
      p1をp2乗した値を求めます。結果は実数で与えられます。

      p1は必ず正でなければなりません。負の場合はエラーにはなりませんが、非数（-1.#IND00）が返ります。

      p2は正負どちらでも構いません。また、実数を指定することも可能です。
    </Setting>
  </command>
  <command>
    <Name>log10</Name>
    <Title>10を底とした対数（常用対数）</Title>
    <Format>
      (p1)
      p1 : 真数
    </Format>
    <Setting>10を底とするp1の対数を求めます。結果は実数で与えられます。</Setting>
  </command>
  <command>
    <Name>log2</Name>
    <Title>2を底とした対数</Title>
    <Format>
      (p1)
      p1 : 真数
    </Format>
    <Setting>2を底とするp1の対数を求めます。結果は実数で与えられます。</Setting>
  </command>
  <command>
    <Name>asin</Name>
    <Title>サインの逆関数（アークサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のアークサイン（逆正弦）値を返します。
      結果は実数型かつラジアン、-M_PI/2〜M_PI/2（度数法で-90°〜90°）の範囲で与えられます。
    </Setting>
  </command>
  <command>
    <Name>acos</Name>
    <Title>コサインの逆関数（アークコサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のアークコサイン（逆余弦）値を返します。
      結果は実数型かつラジアン、0〜M_PI（度数法で0°〜180°）の範囲で与えられます。
    </Setting>
  </command>
  <command>
    <Name>sinh</Name>
    <Title>双曲線正弦関数（ハイパボリックサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のハイパボリックサイン（双曲線正弦）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>cosh</Name>
    <Title>双曲線余弦関数（ハイパボリックコサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のハイパボリックコサイン（双曲線余弦）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>tanh</Name>
    <Title>双曲線正接関数（ハイパボリックタンジェント）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のハイパボリックタンジェント（双曲線正接）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>asinh</Name>
    <Title>双曲線正弦関数の逆関数（アークハイパボリックサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のアークハイパボリックサイン（逆双曲線正弦）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>acosh</Name>
    <Title>双曲線余弦関数の逆関数（アークハイパボリックコサイン）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のアークハイパボリックコサイン（逆双曲線余弦）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>atanh</Name>
    <Title>双曲線正接関数の逆関数（アークハイパボリックタンジェント）</Title>
    <Format>
      (p1)
      p1 : 角度値（ラジアン）
    </Format>
    <Setting>
      p1のアークハイパボリックタンジェント（逆双曲線正接）値を返します。
      結果は実数で与えられます。
    </Setting>
  </command>
  <command>
    <Name>isfinite</Name>
    <Title>有限／無限･非数の判定</Title>
    <Format>
      (p1)
      p1 : 判定する値
    </Format>
    <Setting>
      p1が有限の値ならば1を、p1が無限または非数の時は0を返します。

      非数とは数値以外の型（文字列やラベル、モジュール型など）を指すものではありません。変数の型を調べる時はvartype関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>isnan</Name>
    <Title>非数の判定</Title>
    <Format>
      (p1)
      p1 : 判定する値
    </Format>
    <Setting>
      p1が非数の時は1を、それ以外の時は0を返します。

      非数とは数値以外の型（文字列やラベル、モジュール型など）を指すものではありません。変数の型を調べる時はvartype関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>round</Name>
    <Title>四捨五入</Title>
    <Format>
      (p1)
      p1 : 四捨五入する値（実数）
    </Format>
    <Setting>p1の小数点以下を四捨五入し、その結果を実数で返します。</Setting>
  </command>
  <command>
    <Name>sgn</Name>
    <Title>符号</Title>
    <Format>
      (p1)
      p1 : 符号を判定する値（数値）
    </Format>
    <Setting>数値の符号を判定し、正ならば1を・負ならば-1を・ゼロならば0を返します。</Setting>
  </command>
  <command>
    <Name>intf</Name>
    <Title>0の方向へ丸め</Title>
    <Format>
      (p1)
      p1 : 丸める数値
    </Format>
    <Setting>
      p1を0の方向に丸めた数値を返します。結果は実数で返されます。

      ここで「p1を0の方向に丸める」とは、「p1の小数点以下を切り捨てる」ことを意味します。
    </Setting>
  </command>
  <command>
    <Name>floor</Name>
    <Title>負の方向へ丸め</Title>
    <Format>
      (p1)
      p1 : 丸める数値
    </Format>
    <Setting>
      p1を負の方向に丸めた数値を返します。結果は実数で返されます。</Setting>
  </command>
  <command>
    <Name>ceil</Name>
    <Title>正の方向へ丸め</Title>
    <Format>
      (p1)
      p1 : 丸める数値
    </Format>
    <Setting>
      p1を正の方向に丸めた数値を返します。結果は実数で返されます。</Setting>
  </command>
  <command>
    <Name>fmod</Name>
    <Title>モジュロ</Title>
    <Format>
      (p1, p2)
      p1 : 割られる数
      p2 : 割る数
    </Format>
    <Setting>
      p1をp2で割ったときの余りを実数で返します。
      ¥記号による演算とは異なり、実数に対しても有効です。
    </Setting>
  </command>
  <command>
    <Name>distance2</Name>
    <Title>2点の距離を求める</Title>
    <Format>
      (p1, p2)
      p1, p2 : 点の座標を代入した数値型配列変数
    </Format>
    <Setting>
      2点A，B間の距離を求めます。

      p1とp2には点の座標を直交座標系で代入しておきます。
      結果は実数で返されます。
    </Setting>
  </command>
  <command>
    <Name>prnflags</Name>
    <Title>リンタ列挙フラグを設定する</Title>
    <Format>
      flag
      flag(0) : プリンタ列挙フラグ
    </Format>
    <Setting>
      hspprintプラグインが列挙するプリンタ一覧の取得フラグを設定します。
      flagに指定された値が取得フラグとなります。以下のフラグを指定可能です。(複数を組み合わせることが可能です)

      定義名                       内容
      ----------------------------------------------
      PRINTER_ENUM_LOCAL           ローカルプリンタ
      PRINTER_ENUM_CONNECTIONS     接続を確立しているプリンタ
      PRINTER_ENUM_SHARED          共有属性が有効なプリンタ

      flagの値が0かまたは省略された場合は、デフォルトの設定(PRINTER_ENUM_LOCAL+PRINTER_ENUM_CONNECTIONS)が使用されます。
    </Setting>
  </command>
  <command>
    <Name>enumprn</Name>
    <Title>プリンタを列挙する</Title>
    <Format>変数 : 結果の文字列が代入される変数名</Format>
    <Setting>
      接続されているプリンタ名の一覧を文字列として取得します。
      複数のプリンタが認識されている場合は、複数行文字列が代入されます。命令実行後に代入されたプリンタの数が、システム変数statに代入されます。
      enumprn命令で取得された一覧の１行目から順番にプリンタID0、プリンタID1…とID番号が対応することになります。
    </Setting>
  </command>
  <command>
    <Name>propprn</Name>
    <Title>プリンタ情報の取得</Title>
    <Format>
      変数1,変数2,id,type
      変数1 : 結果Xの値が代入される変数名
      変数2 : 結果Yの値が代入される変数名
      id(0) : プリンタID(0〜)
      type(0) : 取得される情報タイプ
    </Format>
    <Setting>
      プリンタに関する情報を取得し、変数1,変数2に代入します。
      idでプリンタIDを指定します。プリンタIDは、enumprn命令で取得された一覧の中から順番に0,1,2…の数値で示したものになります。
      代入される情報は、type(情報タイプ)で指定された内容になります。情報タイプは以下の中から選択します。

      情報タイプ    内容
      ----------------------------------------------
      0          ビクセル単位のページ解像度X,Y
      1          ページの物理サイズX,Y(デバイス単位)
      2          印刷可能領域までの距離X,Y(デバイス単位)
      3          物理的なページのサイズX,Y(mm単位)

      X,Yの値が代入される場合は、変数は整数型に設定されます。
    </Setting>
  </command>
  <command>
    <Name>execprn</Name>
    <Title>プリンタ印刷の開始</Title>
    <Format>
      id,x,y,sx,sy,bx,by,bsx,bsy,"name"
      id(0) : プリンタID(0〜)
      x,y : 印刷ページ内の画像位置X,Y座標
      sx,sy : 印刷ページ内の画像サイズX,Y
      bx,by : 印刷される画像の左上X,Y座標
      bsx,bsy : 印刷される画像サイズX,Y
      "name" : ドキュメント名
    </Format>
    <Setting>
      現在の操作先ウインドウの画像をプリンタで印刷します。
      idでプリンタIDを指定します。プリンタIDは、enumprn命令で取得された一覧の中から順番に0,1,2…の数値で示したものになります。

      HSPの画像バッファ内の座標(bx,by)から(bsx,bsy)で指定されたサイズが印刷の対象となります。bx,byが省略された場合は、それぞれ0が使用されます。bsx,bsyが省略された場合は、最大の画面サイズが使用されます。
      印刷されるページ内での位置を(x,y)で指定することができます。これは、ピクセル単位でページ解像度の範囲内に指定可能です。またその場合のサイズを(sx,sy)で指定することができます。
      "name"は印刷キューなどに表示されるドキュメント名になります。"name"を省略した場合は、"hspdoc"が使用されます。
    </Setting>
  </command>
  <command>
    <Name>getdefprn</Name>
    <Title>規定のプリンタを取得する</Title>
    <Format>
      変数
      変数 : 結果の文字列が代入される変数名
    </Format>
    <Setting>規定(デフォルト)のプリンタ名を取得して変数に代入します。</Setting>
  </command>
  <command>
    <Name>prndialog</Name>
    <Title>プリンタの設定ダイアログを開く</Title>
    <Format>
      id
      id(0) : プリンタID(0〜)
    </Format>
    <Setting>
      プリンタの設定ダイアログを開きます。
      idでプリンタIDを指定します。プリンタIDは、enumprn命令で取得された一覧の中から順番に0,1,2…の数値で示したものになります。
    </Setting>
  </command>
  <command>
    <Name>sockopen</Name>
    <Title>ソケットを初期化して接続</Title>
    <Format>
      p1,"url",p2
      p1=0〜31(0) : ソケットID番号
      "url"       : URL指定文字列
      p2=0〜(0)   : ポート番号
    </Format>
    <Setting>
      ソケットを初期化して使用できるようにします。
      TCP/IP通信を行なう際には、必ず最初に初期化して相手のサーバーに接続しなければなりません。

      p1でソケットID番号を指定します。

      "url"で接続先のURLを文字列で指定します。 これは、「www.yahoo.co.jp」のようなドメイン名か、「202.132.50.7」のようなIPアドレスを直接指定したもののどちらでもかまいません。「http://」や「ftp://」 のようなスキーム名は入れないでください。

      p2で、接続するポート番号を指定します。これは、どのようなサーバーに接続するかによって違います。オリジナルのポートを作成する場合は、1024以降を使用するようにしてください。

      sockopen命令が実行された結果が、システム変数statに代入されます。
      結果がエラーの場合は、0以外の値になります。 初期化でエラーが起こった場合は、通信を行なうことはできません。

      システム変数statの値の詳細は以下の通りです。

      stat : エラー内容
      ----------------------------------------------------
      1   : TCP/IPがWindowsにインストールされていない
      2   : ソケットの初期化に失敗した
      3   : URLのサーバー名取得に失敗した
      4   : サーバーに接続できなかった
    </Setting>
  </command>
  <command>
    <Name>sockclose</Name>
    <Title>ソケットを切断</Title>
    <Format>
      p1
      p1=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      接続されているソケットを切断します。
      初期化したソケットは必ず sockclose命令で切断するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>sockput</Name>
    <Title>データを送信</Title>
    <Format>
      "message",p1
      "message"   : 送信するメッセージ
      p1=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      ソケットにデータを送信します。 "message"で指定した文字列か、または文字列型変数の内容をそのまま送信します。

      送信中にエラーが発生した場合は、システム変数 statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sockputc</Name>
    <Title>データを1byte送信</Title>
    <Format>
      p1,p2
      p1=0〜255(0) : 送信するメッセージ(1byte)
      p2=0〜31(0)  : ソケットID番号
    </Format>
    <Setting>
      ソケットにデータを送信します。p1で指定した数値を1byte送信します。

      送信中にエラーが発生した場合は、システム変数 statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sockputb</Name>
    <Title>バッファのデータを送信</Title>
    <Format>
      p1,p2,p3,p4
      p1=変数     : 送信内容が格納されている変数名
      p2=0〜(0)   : バッファオフセット(byte単位)
      p3=0〜(64)  : 送信サイズ(byte単位)
      p4=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      p1で指定した変数バッファの内容をバイナリデータとしてソケットに送信します。
      p1で指定される変数は、文字列型、数値型のどちらでも構いません。変数が確保しているメモリの内容が直接送信されます。

      p2で、変数バッファのオフセットを指定できます。たとえば、p2が100の場合は、先頭から100byte目からの内容を送信することになります。p2が省略された場合は0になります。

      p3で送信サイズを指定します。送信サイズは、変数バッファにあらかじめ確保されているサイズ以内でなければなりません。p3が省略されるか、0の場合は、64(byte)が指定されます。

      sockputb命令の実行後は、システム変数statに実際に送信されたサイズ(byte)が代入されます。システム変数 statの内容が0だった場合は、通信エラー、もしくはタイムアウトでまったく送信されていないことを示しています。
      (変数バッファの内容は、peek命令、poke命令などで操作することが可能です)
    </Setting>
  </command>
  <command>
    <Name>sockcheck</Name>
    <Title>データの到着を調べる</Title>
    <Format>
      p1
      p1=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      指定したソケットに sockget系の命令で取得できるデータが到着しているかどうか調べます。
      受信可能なデータがある場合は、システム変数 statに0が代入されます。データが到着していない場合は、システム変数statは1になります。

      通信エラーなどが起こった場合は、システム変数 statは2以上の値になります。エラーが起こった場合は、通信を行なうことはできません。

      システム変数statの値の詳細は以下の通りです。

      stat : 内容
      ---------------------------------------------------
      0   : 受信データが到着している
      1   : 受信データは到着していない(タイムアウト)
      2   : 通信中にエラーが発生した

      sockcheckはデータの到着を調べるだけです。 実際のデータを取得するには、sockget, sockgetc, sockgetbなどの命令で受信する必要があります。
    </Setting>
  </command>
  <command>
    <Name>sockget</Name>
    <Title>データを受信</Title>
    <Format>
      p1,p2,p3
      p1=変数     : 受信内容が格納される変数名
      p2=0〜(64)  : 受信サイズ(byte単位)
      p3=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      ソケットからデータを受信し、p1で指定した文字列型の変数に内容を代入します。p2で最大受信サイズを指定します。

      受信中にエラーが発生した場合は、システム変数 statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sockgetc</Name>
    <Title>データを1byte受信</Title>
    <Format>
      p1,p2
      p1=変数     : 受信内容が格納される変数名
      p2=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      ソケットからデータを 1byte受信し、p1で指定した数値型の変数に内容を代入します。

      受信中にエラーが発生した場合は、システム変数 statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sockgetb</Name>
    <Title>バッファにデータを受信</Title>
    <Format>
      p1,p2,p3,p4
      p1=変数 : 受信内容が格納される変数名
      p2=0〜(0)   : バッファオフセット (byte単位)
      p3=0〜(64)  : 受信サイズ (byte単位)
      p4=0〜31(0) : ソケットID番号
    </Format>
    <Setting>
      ソケットからデータを受信し、p1で指定した変数バッファに内容をバイナリデータとして格納します。
      p1で指定される変数は、文字列型、数値型のどちらでも構いません。変数が確保しているメモリに直接受信内容を読み込みます。

      p2で、格納されるバッファのオフセットを指定できます。
      たとえば、p2が100の場合は、先頭から100byte目から受信データを格納することになります。p2が省略された場合は0になります。

      p3で最大受信サイズを指定します。
      受信サイズを指定する場合は、変数バッファに指定したサイズを格納できるだけのメモリが、あらかじめ確保されていなければなりません。
      p3が省略されるか、0の場合は、64(byte)が指定されます。

      sockgetb命令の実行後は、システム変数statに実際に受信されたサイズ(byte)が代入されます。システム変数 statの内容が0だった場合は、通信エラー、もしくはタイムアウトでまったく受信されていないことを示しています。
      (変数バッファの内容は、peek命令、poke命令などで操作することが可能です)
    </Setting>
  </command>
  <command>
    <Name>sockmake</Name>
    <Title>ソケットをサーバーとして初期化</Title>
    <Format>
      p1,p2
      p1=0〜31(0) : ソケットID番号
      p2=0〜(0)   : ポート番号
    </Format>
    <Setting>
      ソケットを初期化してサーバーとして使用できるようにします。
      p1でソケットID番号を指定します。
      p2で、ポート番号を指定します。既にシステムで予約されているソケット番号は使用できません。独自のプロトコルを定義する場合は、1024以降の番号を使うようにするといいでしょう。

      sockmake命令が実行されると、サーバーとしての準備が整います。
      この後、実際にクライアントと接続するためには、sockwait命令でクライアントの接続が完了するまで待つ必要があります。

      結果がエラーの場合は、 0以外の値になります。初期化でエラーが起こった場合は、通信を行なうことはできません。

      システム変数 statの値の詳細は以下の通りです。

      stat : エラー内容
      ----------------------------------------------------
      1   : TCP/IPがWindowsにインストールされていない
      2   : ソケットの初期化に失敗した
      3   : Socketのバインドに失敗した
    </Setting>
  </command>
  <command>
    <Name>sockwait</Name>
    <Title>クライアントの着信を待つ</Title>
    <Format>
      p1,p2
      p1=0〜31(0) : ソケットID番号
      p2=0〜31(0) : 代替ソケットID番号
    </Format>
    <Setting>
      sockmake命令でサーバーとして準備されたソケットで、クライアントの着信を待ちます。
      sockwait命令は、必ずsockmake命令が正常に終了した後に実行される必要があります。

      sockwait命令は、クライアントの着信がない場合や、エラーが発生した場合には、システム変数 statに0以外の値を返します。
      システム変数 statに0が代入された場合にはじめてクライアントとの接続に成功し、sockget命令、sockput命令などの通信を行なうことができるようになります。

      サーバーとして着信を待つ場合には、sockmake命令でソケットをサーバーとして初期化した後、sockwait命令でシステム変数 statが0になるまでループして待機して下さい。その際には、必ずループ内に waitやawait命令を入れて間をあける必要があります。
      そうしないと、 Windowsの他のアプリケーションにタスクが回らなくなってしまいます。

      p2が0か省略された場合は、p1で指定されたソケットID番号を通して、クライアントとの通信を行なうことが可能になります。
      p2に0以外の値を指定した場合は、着信したクライアントとの通信をp2で指定した代替ソケットIDを通して行なうことができます。
      この場合、p1で指定したソケットID番号では、引き続きsockmake命令でサーバー動作を行なうことが可能です。同一のポートで、複数のクライアント着信を受け付ける場合は、代替ソケットID番号を使用するようにしてください。

      結果がエラーの場合は、 0以外の値になります。エラーが起こった場合は、通信を行なうことはできません。

      システム変数 statの値の詳細は以下の通りです。

      stat : エラー内容
      -----------------------------------------------------
      1   : クライアントから接続要求が来ていない
      2   : sockmake命令でサーバーの準備ができていない
      3   : Socketが受信状態になっていない
      4   : Socketを受信状態にするのに失敗した
      5   : クライアントとの接続に失敗した
    </Setting>
  </command>
  <command>
    <Name>ipget</Name>
    <Title>ホストのIPアドレスを取得</Title>
    <Format></Format>
    <Setting>
      ホストのIPアドレスを取得して、システム変数refstrに代入します。

      IPアドレスを取得する際にエラーが発生すると、システム変数 statに1が代入されます。正常にIPアドレスが取得できた場合には、システム変数statの値は0になります。
    </Setting>
  </command>
  <command>
    <Name>hsptv_up</Name>
    <Title>HSPTVデータ更新</Title>
    <Format>
      p1, "コメント", p2
      p1 : スコア値（32bit整数値）
      "コメント" : コメント文字列(256byteまで)
      p2 : オプション機能値
    </Format>
    <Setting>
      HSPTVデータを更新します。スコア・コメント情報を反映させます。
      スコアがマイナス値の場合は最新データのみ取得します。
      (HSPTV配信プログラムの場合は、この命令によってサーバーとの通信が発生します。この命令の終了までには、ある程度の時間がかかることを想定してプログラムを作成してください。)

      コメントは、設定する文字列の情報を256byte(半角255文字)までの内容で指定することができます。

      p2（オプション機能値）を省略するか、または0を指定した場合は、通常のランキング(スコアが高い順)としてデータを更新します。
      オプション値に0x1000(4096)を指定した場合は、p1で指定したインデックスのスコアをクリア(スコアを0にする)します。
      オプション値に0x2000(8192)を指定した場合は、ユーザー名の反映を行なわず、常に空の文字列が設定されます。
      オプション値は複数の値を加算して指定することが可能です。
      (データの内容をクリアする場合には、オプション値0x1000及び0x2000を組み合わせて使用してください。)
    </Setting>
  </command>
  <command>
    <Name>hsptv_getrank</Name>
    <Title>HSPTVデータ取得</Title>
    <Format>
      p1, p2, p3, rank
      p1 : スコア情報が代入される変数名
      p2 : ユーザー名情報が代入される変数名
      p3 : コメント情報が代入される変数名
      rank : 順位のインデックス(0〜29)
    </Format>
    <Setting>
      HSPTVデータの内容を変数に読み出します。

      rankの値は0が1位、29が30位となります。p1は数値型、p2＆p3は文字列型として初期化されます。

      この命令は、hsptv_up命令によって更新されたデータを変数に読みだすものです。読み出される内容は、最後にhsptv_up命令を実行した時点の情報になります。
      また、この命令では通信は発生しないので、情報の読み出しは即時に行なわれます。
    </Setting>
  </command>
  <command>
    <Name>newcom</Name>
    <Title>COMオブジェクト型変数の新規作成</Title>
    <Format>
      p1,p2,p3,p4
      p1    : 変数名
      p2    : インターフェース名、またはクラスID
      p3(0) : 作成モード(オプション)
      p4    : 参照元ポインタ(オプション)
    </Format>
    <Setting>
      p1で指定した変数をCOMオブジェクト型として初期化を行ないます。
      p1の変数がCOMオブジェクト型でない場合は、COMオブジェクト型として初期化されます。

      すでにCOMオブジェクト型の場合、以前のオブジェクトは破棄されます。
      p2でクラスIDかまたは、プログラムID(ProgID)を指定することができます。

      例:
      newcom ie, "InternetExplorer.Application"	; ProgID

      上の例では、プログラムIDを使用して初期化を行なっています。
      これにより変数ieは、COMオブジェクト型変数として初期化されます。
      また、#usecom命令によりすでに定義されているインターフェース名を指定して初期化することが可能です。

      例:
      #define IID_IDirectMusicPerformance8 "{679c4137-c62e-4147-b2b4-9d569acb254c}"
      #define IID_IDirectMusicLoader8      "{19e7c08c-0a44-4e6a-a116-595a7cd5de8c}"
      #usecom IDirectMusicLoader8 IID_IDirectMusicLoader8　CLSID_DirectMusicLoader
      newcom loader, IDirectMusicLoader8

      p3で作成モードを指定することができます。p3を省略した場合にはモード0となります。

      モード    内容
      ------------------------------------------------------------------
      0       指定されたクラスのCOMをサーバーとして呼び出す
      -1       p4で指定されたポインタとするCOMオブジェクト型変数を作成

      p3が-1の場合は、COMオブジェクトを新規に作成せずに、p4で指定された値を
      ポインタとするCOMオブジェクト型変数を作成します。

      COMオブジェクト型変数は、Windowsが持つCOMの仕組みをHSPから呼び出すための仕組みに使用されます。詳しくは、プログラミングマニュアル(hspprog.htm)を参照してください。
    </Setting>
  </command>
  <command>
    <Name>delcom</Name>
    <Title>COMオブジェクト型変数の破棄</Title>
    <Format>
      p1
      p1 : 変数名
    </Format>
    <Setting>
      p1で指定したCOMオブジェクト型の変数のインスタンスを削除します。
      p1は、newcom命令によってすでにCOMオブジェクト型が設定されている変数である必要があります。

      例:
      delcom v

      delcom命令は、初期化されたCOMオブジェクトの参照カウントを減らし、変数に設定されているインスタンスを無効にします。
      通常、生成されたCOMオブジェクトのインスタンスはHSP内部で自動的に破棄されるため、特にdelcom命令で明示的に破棄する必要はありません。

      一度破棄されたCOMオブジェクト型の変数は、再度newcom命令により初期化されるまでは使用することができません。
    </Setting>
  </command>
  <command>
    <Name>comres</Name>
    <Title>メソッド返値代入変数を設定する</Title>
    <Format>
      p1
      p1 : 変数名
    </Format>
    <Setting>
      p1で指定した変数を、メソッド返値代入変数として設定します。
      メソッド返値代入変数は、COMオブジェクト型変数を使用してCOMオートメーション(IDispatch)のメソッド呼び出しが行なわれた際に、結果が代入される対象となります。
      mcall命令によってメソッド呼び出しが行なわれた結果を取得するためには、comres命令によって変数が設定されている必要があります。
    </Setting>
  </command>
  <command>
    <Name>querycom</Name>
    <Title>COMオブジェクト型変数の作成</Title>
    <Format>
      p1,p2,p3
      p1 : 変数名
      p2 : 参照される変数名
      p3 : インターフェース名
    </Format>
    <Setting>
      p2で指定されたCOMオブジェクト型変数のインターフェースに対して、別なインターフェースを問い合わせ、p1で指定した変数をCOMオブジェクト型として初期化を行ないます。
      p1の変数がCOMオブジェクト型でない場合は、COMオブジェクト型として初期化されます。
      すでにCOMオブジェクト型の場合、以前のオブジェクトは破棄されます。
      p3ですでに定義されているインターフェース名を指定します。
      インターフェース名は、#usecom命令により定義されたものである必要があります。
    </Setting>
  </command>
  <command>
    <Name>comevent</Name>
    <Title>COMイベントの取得開始</Title>
    <Format>
      p1,p2,p3,*label
      p1      : 変数名
      p2      : イベント取得元の変数名
      p3      : コネクションポイントGUID
      *label  : イベントサブルーチンのラベル
    </Format>
    <Setting>
      p1で指定された変数をイベント処理を行なうためのCOMオブジェクト型として初期化します。
      p2で指定された変数(COMオブジェクト型)から任意のイベントを取得して準備を行ないます。
      p2で指定されたCOMオブジェクトは、すでにnewcom命令により初期化されている必要があります。
      p3でコネクションポイントGUIDを文字列形式で指定します。
      p3の指定を省略した場合は、IProvideClassInfo2によって得られたデフォルトのコネクションポイントを検索します。
      *labelでイベント処理サブルーチンのラベルを指定します。
      イベント取得の準備に失敗した場合は、エラーが発生します。
      成功した場合は、これ以降イベントが発生するたびに*labelで指定された場所にサブルーチンジャンプの割り込みが発生します。
      *labelで指定されたイベントサブルーチンでは、comevdisp関数、comevarg命令により
      イベントの内容を細かく取得することが可能になります。

      すでにイベントの取得が開始されている変数に対して、再度comevent命令を実行した場合は、以前のイベントキューの設定は無効になります。
      イベントの取得は、delcom命令によりCOMオブジェクトが破棄されるまで継続されます。
    </Setting>
  </command>
  <command>
    <Name>comevarg</Name>
    <Title>COMイベントのパラメーターを取得</Title>
    <Format>
      p1,p2,p3,p4
      p1     : 結果が代入される変数名
      p2     : 参照されるCOMオブジェクト型変数名
      p3 (0) : パラメーターのインデックス
      p4 (0) : 取得モード(0=通常の変換、1=文字列に変換 2=Variant変換)
    </Format>
    <Setting>
      p2で指定された変数(COMオブジェクト型)のイベントサブルーチン内で、イベントのパラメーター(引数)を取得します。
      p2で指定された変数は、comevent命令により初期化されている必要があります。
      取得は必ず、イベントサブルーチン内で行なう必要があります。

      p3でパラメーターのインデックスを指定することができます。インデックスは、0から始まる数でイベントによって有効なインデックス範囲が異なります。
      p4でパラメーター取得の方法を指定することができます。
      0かまたは省略した場合には、デフォルトの変換方法(文字列型、数値型などの変換をシステムが自動的に行ないます)が使用されます。
      p4に1を指定した場合は、COMのシステムが文字列に変換した状態で取得されます。
      p4に2を指定した場合は、Variant型として値が取得されます。
    </Setting>
  </command>
  <command>
    <Name>sarrayconv</Name>
    <Title>Variant型との一括変換を行なう</Title>
    <Format>
      p1,p2,p3,p4
      p1    : 結果を格納する変数
      p2    : 変換元の変数
      p3(0) : 変換のモード
      p4(0) : バイナリーデータのサイズ
    </Format>
    <Setting>
      Variant型との一括変換を行ないます。
      p3のモードにより、変換のモードを指定することができます。
      指定できるモード値は以下の通りです。

      p3　　内容
      ---------------------------------------------
      0 ：配列変数 p2 全体から SafeArray を作成し、
      p1 の Variant 型変数に格納します。
      1 ：p2 で指定された Variant 型変数に格納されている
      SafeArray を配列変数 p1 に格納します。
      p1 の領域は再確保されます。
      2 ：p2 で指定された Variant 型変数に格納されている
      1次元 SafeArray のバイナリデータを変数 p1 に格納します。
    </Setting>
  </command>
  <command>
    <Name>bcopy</Name>
    <Title>ファイルのコピー</Title>
    <Format>
      "filename1","filename2"
      "filename1" : コピー元ファイル名
      "filename2" : コピー先ファイル名
    </Format>
    <Setting>"filename1"のファイルを"filename2"というファイル名にコピーします。</Setting>
  </command>
  <command>
    <Name>chdir</Name>
    <Title>ディレクトリ移動</Title>
    <Format>
      "dirname"
      "dirname" : 移動先ディレクトリ名
    </Format>
    <Setting>
      "dirname"で指定した名前のディレクトリに移動します。
      指定したディレクトリが存在しないか、 書式が間違っている場合はエラー12(「ファイルが見つからないか無効な名前です」)となります。
      カレントディレクトリは、システム変数dir_curで参照することができます。
    </Setting>
  </command>
  <command>
    <Name>delete</Name>
    <Title>ファイル削除</Title>
    <Format>
      "filename"
      "filename" : 削除するファイル名
    </Format>
    <Setting>
      "filename"で指定したファイルを削除します。
      指定したファイルが存在しないか、書式が間違っている場合はエラー12(「ファイルが見つからないか無効な名前です」)となります。
      delete命令を実行する前に exist命令でファイルの有無を確認するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>dirlist</Name>
    <Title>ディレクトリ一覧を取得</Title>
    <Format>
      p1,"filemask",p2
      p1=変数    : ディレクトリ一覧を格納する文字列型変数
      "filemask" : 一覧のためのファイルマスク
      p2=0〜(0)  : ディレクトリ取得モード
    </Format>
    <Setting>
      カレントディレクトリのファイル一覧を作成して、変数に代入します。
      "filemask"で、一覧を作成するためのファイルマスクを指定します。
      ファイルマスクは、「*.*」 のようなワイルドカードの形で指定するパラメータです。
      たとえば、「*.as」というファイルマスクではasという拡張子を持つファイルすべての一覧を作成します。カレントディレクトリにあるすべてのファイル一覧を作成する場合は、「*.*」になります。
      ディレクトリ一覧は、p1で指定された文字列型の変数に、１ファイルごとに改行(¥n)で区切られた文字列として代入されます。このデータは、メモリノートパッド命令で扱うことができる形式です。

      dirlist命令が実行されると、 システム変数statに一覧が作成されたファイルの数が代入されます。
      ファイルが１つもない場合は、システム変数statに0が代入されます。
      p2のモードを指定することによって、取得するファイルの種類を選ぶことができます。モード値の詳細は以下の通りです。
      モードが省略されている場合は0になります。

      モード :  取得される内容
      ---------------------------------------------------------------------
      0   :  すべてのファイル
      1   :  ディレクトリを除くすべてのファイル
      2   :  隠し属性・システム属性を除くすべてのファイル
      3   :  ディレクトリ・隠し属性・システム属性以外のすべてのファイル
      5   :  ディレクトリのみ
      6   :  隠し属性・システム属性ファイルのみ
      7   :  ディレクトリと隠し属性・システム属性ファイルのみ
    </Setting>
  </command>
  <command>
    <Name>exist</Name>
    <Title>ファイルのサイズ取得</Title>
    <Format>
      "filename"
      "filename" : サイズを調べるファイルの名前
    </Format>
    <Setting>
      "filename"で指定したファイルが存在するかをチェックして、そのファイルサイズを取得します。exist命令が実行されると、システム変数strsizeに結果が反映されます。

      ファイルが存在する場合は、そのファイルサイズがstrsizeに代入されます。
      もしファイルが存在しなかった場合は、-1がstrsizeに代入されます。
    </Setting>
  </command>
  <command>
    <Name>mkdir</Name>
    <Title>ディレクトリ作成</Title>
    <Format>
      "dirname"
      "dirname" : 作成するディレクトリ名
    </Format>
    <Setting>
      "dirname"で指定した名前でディレクトリを作成します。
      ディレクトリは１階層先までしか作成することができません。
      作成中にエラーが発生した場合はエラー12(「ファイルが見つからないか無効な名前です」)となります。
      mkdir命令を実行する前に 必ずdirlist命令でフォルダの有無を確認するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>bload</Name>
    <Title>バッファにファイルをロード</Title>
    <Format>
      "filename",p1,p2,p3
      "filename" : ロードするファイル名
      p1=変数    : 変数名
      p2=64〜(-1): ロードされるサイズ(Byte単位)
      p3=0〜(-1) : ファイルのオフセット
    </Format>
    <Setting>
      ファイルの内容をメモリバッファに読み込みます。
      通常は、sdim命令で確保したメモリバッファに対して使用しますが、それ以外の型を持つ変数や、配列変数に対して使うこともできます。
      p2のバッファサイズを省略するかマイナス値を指定すると、自動的に変数バッファのサイズが設定されます。

      また、bload命令実行後は、システム変数strsizeに読み込んだデータのサイズが反映されます。

      ファイルのオフセット値を指定すると、その値だけファイルの先頭からずらした場所からが操作の対象になります。 たとえば、bload命令でオフセット値を100に指定すると、 通常はファイルの先頭からデータをメモリに読み込むところを、先頭から100バイト過ぎた場所 (100バイトスキップして) からメモリに読み込まれます。

      これにより、大きなファイルの一部だけを読み込むことや、分割して処理することなどが可能になります。

      テキストファイルを読み込む場合には、専用のnoteload命令を使用することを推奨します。

      #epack命令により暗号化されたファイルをbload命令で読み込む場合は、ファイルのオフセット値を指定することができませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>bsave</Name>
    <Title>バッファをファイルにセーブ</Title>
    <Format>
      "filename",p1,p2,p3
      "filename" : セーブするファイル名
      p1=変数    : 変数名
      p2=0〜(-1) : セーブするサイズ(Byte単位)
      p3=0〜(-1) : ファイルのオフセット
    </Format>
    <Setting>
      メモリバッファの内容をファイルに書き出します。
      通常は、sdim命令で確保したメモリバッファに対して使用しますが、それ以外の型を持つ変数や、配列変数に対して使うこともできます。
      p2のバッファサイズを省略するかマイナス値を指定すると、自動的に変数バッファのサイズが設定されます。

      ファイルのオフセット値を指定すると、その値だけファイルの先頭からずらした場所からが操作の対象になります。
      bsave命令でオフセットを指定すると、 ファイルの先頭から任意のサイズを過ぎた場所からセーブを行なうことが可能です。
      (この場合は、それオフセットより前のファイル内容は変化しません。
      また、オフセット指定時はファイルが存在しない場合エラーとなります。)

      これにより、大きなファイルの一部だけを更新することや、分割して処理することなどが可能になります。

      テキストファイルを保存する場合には、専用のnotesave命令を使用することを推奨します。
    </Setting>
  </command>
  <command>
    <Name>memfile</Name>
    <Title>メモリストリーム設定</Title>
    <Format>
      p1,p2,p3
      p1=変数     : ストリーム対象となる変数名
      p2=0〜(0)   : バッファのオフセット
      p3=0〜(MAX) : バッファのサイズ
    </Format>
    <Setting>
      ファイルの替わりとして扱うメモリ空間を持った変数を設定します。(メモリストリーム機能)
      p1で指定された変数は、これ以降に「MEM:ファイル名」で指定されたファイルの読み出し元となります。
      p2で、オフセット(読み出す際の先頭位置)を指定します。 0が指定されるか省略された場合は、バッファの先頭から読み出されます。
      p3で、読み出す対象となるサイズを指定します。 0が指定されるか、省略された場合は、変数のバッファ全体が対象となります。
      メモリ上にロードされたファイルイメージを、「picload "MEM:a.jpg"」のように指定して画像ファイルを読み込むことが可能です。
      mmload命令など拡張子をファイル種別として判断している場合には、ダミーのファイル名 (「MEM:a.wav」など)を指定する必要があるので注意してください。

      メモリストリーム機能は、独自形式のアーカイブや暗号形式を用意してその内容を読み出して画像として展開する場合など、
      特殊な場面でのみ使われることを想定したものです。
      外部DLLや、拡張プラグインに渡すファイル名に関しては、メモリストリーム機能は原則として適用されませんので注意してください。
      (HSP3のメモリストリーム機能に対応した拡張プラグインは除きます)
    </Setting>
  </command>
  <command>
    <Name>chdpm</Name>
    <Title>DPMファイル設定</Title>
    <Format>
      "dpmname",p1
      "dpmname" : DPMファイル名
      p1(-1)    : 暗号化キー指定
    </Format>
    <Setting>
      読み込み対象となるDPMファイルを設定します。
      chdpm命令が実行されると、以降は"dpmname"で指定したファイルを、DPM形式でパックされたデータとして扱います。
      DPMファイルの初期化中にエラーが発生した場合は、エラー12(「ファイルが見つからないか無効な名前です」)となります。

      chdpm命令は、複数のDPM形式ファイルを切り替えて使用する場合に有効です。
      また、DPMファイルごとに異なる暗号化を行なうことで、より強力なファイル保護を行なうことも可能です。
      この命令以外でも、「picload "DPM:data.dpm:test.jpg"」のようにファイル名の一部として呼び出すことが可能です。(この場合、暗号化キーは指定できません。)

      暗号化キーを指定したDPMファイルは、スクリプトから直接生成する必要があります。詳しくは、サンプルスクリプト「mkpack.hsp」を参照してください。
    </Setting>
  </command>
  <command>
    <Name>cls</Name>
    <Title>画面クリア</Title>
    <Format>
      p1
      p1=0〜4(0) : クリアする時の色
    </Format>
    <Setting>
      ウィンドウ内の情報をすべてクリアします。

      p1でクリアする５種類の色を指定することができます。

      色の指定値 :
      ( 0=白 / 1=明るい灰色 / 2=灰色 / 3=暗い灰色 / 4=黒 )

      cls命令で画面をクリアすると、 画面にあるボタンや入力ボックスなどのオブジェクト類、フォントやカラー設定が初期状態に戻ります。
    </Setting>
  </command>
  <command>
    <Name>mes</Name>
    <Title>メッセージ表示</Title>
    <Format>
      "strings"
      "strings" : 表示するメッセージ、または変数
    </Format>
    <Setting>
      ウィンドウ内に、指定されたメッセージを表示します。
      メッセージは、カレントポジションと呼ばれるウィンドウ上の仮想的なカーソル位置から表示され、カレントポジションが次の行に自動的に移動します。

      表示されるメッセージのフォントは、font命令で指定することができます。
      表示するメッセージに改行コードが含まれていた場合には、改行され次の行から表示を続けます。
    </Setting>
  </command>
  <command>
    <Name>print</Name>
    <Title>メッセージ表示</Title>
    <Format>
      "strings"
      "strings" : 表示するメッセージまたは変数
    </Format>
    <Setting>
      ウィンドウ内に、指定されたメッセージを表示します。
      メッセージは、カレントポジションと呼ばれるウィンドウ上の仮想的なカーソル位置から表示され、カレントポジションが次の行に自動的に移動します。

      表示されるメッセージのフォントは、font命令で指定することができます。
      表示するメッセージに改行コードが含まれていた場合には、改行され次の行から表示を続けます。

      print命令はmes命令の別名であり、どちらも同じ意味になります。
      HSPでは、mes命令を使用することを推奨しています。
    </Setting>
  </command>
  <command>
    <Name>title</Name>
    <Title>タイトルバー設定</Title>
    <Format>
      "strings"
      "strings" : 指定する文字列
    </Format>
    <Setting>
      p1の指定が省略されている場合には、ウィンドウのタイトルバーキャプションを、"strings"の内容に設定します。
      (タイトルバーキャプションは、通常「Hot Soup Processor ver3.x」と表示されている部分のことです)
    </Setting>
  </command>
  <command>
    <Name>dialog</Name>
    <Title>ダイアログを開く</Title>
    <Format>
      "message",p1,"option"
      p1=0〜(0) : ダイアログのタイプ設定
    </Format>
    <Setting>
      Windowsの標準的な各種ダイアログボックスを画面に表示します。
      dialog命令で出したダイアログは、 HSPのウィンドウとは別にポップアップして現われます。

      ユーザーの操作によりダイアログを閉じるまでは、 HSPスクリプトの続きは実行されません。

      ダイアログのタイプは、p1の設定によって変わります。

      タイプ : 内容
      -----------------------------------------------------
      0    : 標準メッセージボックス + [OK]ボタン
      1    : 警告メッセージボックス + [OK]ボタン
      2    : 標準メッセージボックス + [はい][いいえ]ボタン
      3    : 警告メッセージボックス + [はい][いいえ]ボタン
      16    : ファイルOPEN(開く)ダイアログ
      17    : ファイルSAVE(保存)ダイアログ
      32    : カラー選択ダイアログ(固定色)
      33    : カラー選択ダイアログ(RGBを自由に選択)
      64〜  : 拡張ダイアログ

      タイプ0〜3の場合は、"message" で指定した内容を表示するメッセージボックスが現われます。また、"option"でメッセージボックスのタイトルバー文字列を指定することができます。(省略した場合はタイトルに何も表示されません)
      メッセージボックスが閉じられると、押したボタンの情報がシステム変数statに代入されます。この時、変数statの内容は、

      1 :「OK」ボタンが押された
      6 :「はい」ボタンが押された
      7 :「いいえ」ボタンが押された

      のようになります。

      タイプ16〜17の場合は、ファイル一覧から選択をするためのファイル選択ダイアログが現われます。この時、 "message"にロード(またはセーブ)するファイルの拡張子(3文字まで)を指定して、 その拡張子だけが表示されるようにすることができます。("*"を指定するとすべてのファイルが表示されます)
      また、"option"で拡張子の詳細、たとえば "txt"ならば、"テキストファイル"などの補助的な説明がダイアログの「ファイルの種類」に表示されます。
      "option"は省略することも可能です。

      例 :
      dialog "txt",16,"テキストファイル"
      dialog "STAT="+stat+"¥nNAME="+refstr,0,"結果"
      stop

      ファイル選択が完了すると、その結果がシステム変数statに代入されます。
      変数statが1ならば、正常に選択されたことを意味します。変数statが0ならば、キャンセルされたかエラーが発生したことを意味しています。
      「|」記号により区切ることで複数のファイル種別を指定することが可能です。

      例 :
      dialog "txt|log",16,"テキストファイル|ログファイル"
      dialog "STAT="+stat+"¥nNAME="+refstr,0,"結果"
      stop

      タイプ32〜33の場合は、カラー選択をするダイアログが表示されます。色選択が終了すると、選択した色のRGBデータがシステム変数、 ginfo_r,ginfo_g,ginfo_bに代入されます。また、変数 statが0ならば、キャンセルされたかエラーが発生したことを意味しています。1ならば、正常に選択されたことを意味します。

      例 :
      dialog "",33
      dialog "R="+ginfo_r+"/G="+ginfo_g+"/B="+ginfo_b,0,"結果"
      stop

      タイプ64以降の値は、ランタイムごとに用意される拡張ダイアログのために予約されています。サポート外のタイプが指定された場合には、何も実行されません。
    </Setting>
  </command>
  <command>
    <Name>bgscr</Name>
    <Title>枠のないウィンドウを初期化</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8
      p1=0〜(0)  : ウィンドウID
      p2=0〜(640): 初期化する画面サイズX（1ドット単位）
      p3=0〜(480): 初期化する画面サイズY（1ドット単位）
      p4=0〜1(0) : 初期化する画面モード
      p5=0〜(-1) : ウィンドウの配置X（1ドット単位）
      p6=0〜(-1) : ウィンドウの配置Y（1ドット単位）
      p7=0〜     : ウィンドウのサイズX（1ドット単位）
      p8=0〜     : ウィンドウのサイズY（1ドット単位）
    </Format>
    <Setting>
      ウィンドウIDを初期化して枠のないウィンドウを作成します。
      このウィンドウは、スクリーンセーバー作成などの特殊な用途で使用されます。
      p2,p3パラメーターにより、初期化される画面サイズを指定します。
      p4の初期化する画面モードは、以下から選ぶことができます。

      1 : パレットモード(1670万色中256色)で作成する
      2 : 非表示のウィンドウを作成する

      p4パラメータに「+1」(パレットモードで作成する)を指定した場合は、パレットあり256色のモードで画面が作成されます。 このモードを指定しなかった場合は、フルカラー(24bitカラー)の画面が作成されます。

      p4パラメータに「+2」(非表示のウィンドウを作成する)を指定した場合は、実行時にはウィンドウが表示されませんが、「gsel ID,1」 で表示させることが可能です。

      p5,p6パラメーターにより、デスクトップ画面上に表示されるウィンドウの位置を指定することができます。
      p5,p6を省略またはマイナス値にした場合は、システム規定の座標が使用されます。
      p2,p3パラメーターで指定された画面サイズの一部だけをウィンドウに表示したい場合には、
      p7,p8のパラメータで、ウィンドウのクライアントサイズ(実際に表示される大きさ)を指定することができます。
      その場合は、groll命令によりウィンドウ内に表示される位置を設定することができるようになります。
      通常は、p7,p8パラメーターの指定は省略して構いません。その場合は、p2,p3で指定された画面サイズと同じクライアントサイズで表示します。

      bgscr命令で画面を初期化した後はそのウィンドウIDが画面制御命令の描画先になります。
    </Setting>
  </command>
  <command>
    <Name>bmpsave</Name>
    <Title>画面イメージセーブ</Title>
    <Format>
      "filename"
      "filename" : セーブするファイル名
    </Format>
    <Setting>
      現在の画面イメージをそのままBMP形式の画像ファイルとしてセーブします。
      "filename"で指定された名前でファイルが作成されます。拡張子も含めてファイル名を指定する必要があります。

      セーブされる画像サイズは、対象となるウィンドウが初期化されたサイズになります。サイズを変更する場合には、一旦別なサイズのウィンドウに内容をコピーしてから、bmpsaveをするようにしてください。
    </Setting>
  </command>
  <command>
    <Name>boxf</Name>
    <Title>矩形を塗りつぶす</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜(0)  : 矩形の左上X座標
      p2=0〜(0)  : 矩形の左上Y座標
      p3=0〜     : 矩形の右下X座標
      p4=0〜     : 矩形の右下Y座標
    </Format>
    <Setting>
      画面上に、 (p1,p2)と(p3,p4) を左上、右下の点として、現在の描画色で矩形
      (四角形)を塗りつぶします。
      (p1,p2)を省略した場合は、画面の左上(0,0)が設定されます。
      (p3,p4)を省略した場合は、画面の右下(描画サイズいっぱいまで)が設定されます。
    </Setting>
  </command>
  <command>
    <Name>buffer</Name>
    <Title>仮想画面を初期化</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜 (0) : ウィンドウID
      p2=0〜(640): 初期化する画面サイズX（1ドット単位）
      p3=0〜(480): 初期化する画面サイズY（1ドット単位）
      p4=0〜1(0) : 初期化する画面モード
    </Format>
    <Setting>
      screen命令と同じく、指定したウィンドウIDを初期化して使用できるようにします。初期化する画面サイズと、画面モードはscreen命令と変わりませんが、buffer命令では、メモリ上に仮想画面が作られるだけで、実際の画面には表示されません。
      これで作成した仮想画面は、通常の画面と同じようにprint命令やpicload命令を使用することができます。 gcopy命令などで別の画面にコピーするためのストック場所に使ったり、現在の画面を一時的に残しておくための保管場所に使うことができます。

      なお、screenで初期化されたウィンドウIDをbuffer命令で再初期化することはできません。

      buffer命令で画面を初期化した後はそのウィンドウIDが画面制御命令の描画先になります。
    </Setting>
  </command>
  <command>
    <Name>chgdisp</Name>
    <Title>画像解像度を変更する</Title>
    <Format>
      p1,p2,p3
      p1=0〜2(0)  : モードの設定
      p2=0〜(640) : X方向の画像解像度の設定
      p3=0〜(480) : Y方向の画像解像度の設定
    </Format>
    <Setting>
      現在の表示解像度を強制的に変更します。
      (p2,p3)でX,Y解像度を設定し、p1で変更モードを設定します。
      モードは、1がフルカラーモード(32bit)、 2がパレットモード(8bit)となります。変更モードが0の場合は、最初の状態(変更前)に復帰します。

      例 :
      chgdisp 1,640,480	; 640x480フルカラーに設定する

      (p2,p3)のパラメーターの指定を省略した場合は、(640,480)となります。

      chgdisp命令が実行されると、 その結果がシステム変数statに反映されます。
      システム変数statの内容は以下の通りになります。

      stat=0 : 正常に解像度が設定された。
      stat=1 : カラーモードの変更はできなかったが、
      解像度の変更は正常に行なわれた。
      stat=2 : 解像度の変更ができなかった。
    </Setting>
  </command>
  <command>
    <Name>color</Name>
    <Title>カラー設定</Title>
    <Format>
      p1,p2,p3
      p1,p2,p3=0〜255(0) : 色コード（R,G,Bの輝度）
    </Format>
    <Setting>
      メッセージ表示、描画などの色を指定した値に設定します。
      p1,p2,p3がそれぞれ、R,G,Bの輝度になります。

      0が最も暗く、255が最も明るくなります。
      color 0,0,0 は黒に、color 255,255,255 は白になります。
      パレットモードの画面では、指定した色に一番近いパレットが選択されます。
    </Setting>
  </command>
  <command>
    <Name>font</Name>
    <Title>フォント設定</Title>
    <Format>
      "fontname",p1,p2
      "fontname"   : フォント名
      p1=1〜99(12) : フォントの大きさ
      p2=0〜(0)    : フォントのスタイル
    </Format>
    <Setting>
      mesおよびprint命令などで表示するテキスト書体の設定をします。
      "fontname"でフォントの名前を指定します。

      フォント名は、"ＭＳ 明朝"、"ＭＳ ゴシック"などのフォント名を直接指定してください。
      フォントの大きさはドット数に比例した論理サイズで指定します。
      数が大きいほど、文字も大きくなります。フォントのスタイルは、

      スタイル 1  : 太文字
      スタイル 2  : イタリック体
      スタイル 4  : 下線
      スタイル 8  : 打ち消し線
      スタイル16  : アンチエイリアス

      となります。数値を合計することで複数のスタイルを同時に指定することも可能です。p2を省略すると、0(通常のスタイル)になります。

      スタイル16を指定すると、文字の縁にあるギザギザが消えて滑らかな表示になります。ただし、画面モードがフルカラーで初期化されている必要があるほか、Windows9X環境はサポートされないのでご注意下さい。(WindowsXPでは、常にアンチエイリアスが有効になります。)

      初期設定やシステム指定のフォントに戻すには、 sysfont命令を使用してください。また、オブジェクトのフォントを変更する場合には、 objmode命令でモードの指定を行なう必要があります。

      指定されたフォントが発見できなかった場合には、代用のフォントが自動的に検索されます。代用フォントの検索にも失敗した場合には、システム変数statに-1が代入されます。フォントが正常に設定された場合には、システム変数statに0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>gcopy</Name>
    <Title>画面コピー</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜(0) : ウィンドウID
      p2=0〜(0) : コピー元の左上X座標
      p3=0〜(0) : コピー元の左上Y座標
      p4=0〜    : コピーする大きさX（ドット単位）
      p5=0〜    : コピーする大きさY（ドット単位）
    </Format>
    <Setting>
      gcopy命令は、 指定したウィンドウIDの画面の一部を、現在の描画先カレントポジションにコピーします。
      コピー元のウィンドウIDは、自分のウィンドウIDと同じかまたは、screen命令やbuffer命令で初期化されたウィンドウIDでなければなりません。

      gcopy命令でコピーする場合は、gmode命令によってコピーするモードをいくつか選ぶことができます。

      gcopy命令でパレットモード画面の画像をコピーする際には注意が必要です。
      コピーする２つのウィンドウのパレットが同じものでも問題のない画像を準備する必要があります。
      また、パレットモード時のパレットは、ユーザー側で正しいものを設定するようにしてください。(画像ファイル使用時に、picload命令だけではパレット設定は行なわれません。)
    </Setting>
  </command>
  <command>
    <Name>gmode</Name>
    <Title>画面コピーモード設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜6(0)   : 画面コピーモード
      p2=0〜(32)   : コピーする大きさX（ドット単位）
      p3=0〜(32)   : コピーする大きさY（ドット単位）
      p4=0〜256(0) : 半透明合成時のブレンド率
    </Format>
    <Setting>
      gcopyで使用されるモードおよび、サイズ、ブレンド率などを設定します。
      それぞれのコピーモード動作は以下の通りです。

      ・モード0 = 通常のコピー

      WindowsのシステムAPI(BitBlt関数)を使った画像コピーを行ないます。
      最も標準的なモードです。
      多くの場合、他のモードよりも高速に処理されます。

      ・モード1 = メモリ間コピー

      画像バッファ間のメモリコピーを行ないます。
      コピー元とコピー先は、同じ画像モード(パレットモード・フルカラーモード)でなければなりません。
      動作は モード0と同じですが、非常に小さいサイズ(16*16ドット以下等)のコピーを行った際 モード0よりも 若干 高速になる場合があります。

      ・モード2 = 透明色付きコピー

      モード1と同様の方法でコピーを行ないますが、 RGBがすべて0(完全な黒)のドットは透明色とみなされコピーされません。

      ・モード3 = 半透明合成コピー

      フルカラーモード時のみ使用することができます。
      gmodeの4番目のパラメーターで指定したブレンド率による半透明合成コピーを行ないます。ブレンド率は0〜256の値となり、256で完全なコピーになります。
      ブレンド率が0の場合はコピーは実行されません。
      また、ブレンド率が256以上はメモリ間コピーが実行されます。

      ・モード4 = 透明色付き半透明合成コピー

      モード3と同様の方法でコピーを行ないますが、RGB値が color命令で設定された色と同じドットは透明色とみなされコピーされません。
      ブレンド率が0の場合はコピーは実行されません。

      ・モード5 = 色加算合成コピー

      フルカラーモード時のみ使用することができます。
      gmodeの4番目のパラメーターで指定したブレンド率による色加算合成コピーを行ないます。色加算では、コピー先のRGB値に、コピー元のRGB値を加算します。
      加算時に輝度が255を越える場合は、255にクランプされます。

      ・モード6 = 色減算合成コピー

      フルカラーモード時のみ使用することができます。
      gmodeの4番目のパラメーターで指定したブレンド率による色減算合成コピーを行ないます。色減算では、コピー先のRGB値から、コピー元のRGB値を減算します。減算時に輝度が0を下回る場合は、0にクランプされます。

      ・モード7 = ピクセルアルファブレンドコピー

      フルカラーモード時のみ使用することができます。
      gmodeで指定されたサイズの画像を、元画像の右側に用意しておき、 右側の画像をアルファブレンド成分として背景合成コピーを行ないます。
      アルファブレンド成分が255の場合は、 そのまま元画像のピクセルがコピーされ、255より小さい場合には、そのブレンド率で背景と合成されます。
      ピクセルはRGB単位で参照されるため、RGBに異なるブレンド率を設定可能です。
      アルファブレンド画像は、通常 (0,0,0)〜(255,255,255) のグレースケールで表現するといいでしょう。

      これらのモードは、gzoom命令では使用されません。
      あくまでもgcopy命令使用時なので注意してください。
      また、gmodeは現在 gsel命令で選択されているウィンドウIDのモードが変更されます。gmodeの設定後に、別なウィンドウIDでgcopy命令を実行しても設定が反映されないので注意してください。

      (p2,p3)はコピーサイズのデフォルトを設定します。この値は、gcopy,gzoom命令でコピーする大きさの値を省略した場合にデフォルトで使われるサイズです。
    </Setting>
  </command>
  <command>
    <Name>gsel</Name>
    <Title>描画先指定、ウィンドウ最前面、非表示設定</Title>
    <Format>
      p1,p2
      p1=0〜(0)  : ウィンドウID
      p2=0〜2(0) : ウィンドウアクティブスイッチ
    </Format>
    <Setting>
      画面制御命令の描画先を指定したウィンドウIDの画面に変更します。
      これ以降は、p1で指定したウィンドウIDの画面に対して、mes命令やpicload命令などの画面描画に関する命令が実行されるようになります。

      p2でオプションのスイッチが指定できます。p2の値が、

      -1 : 指定したウィンドウを非表示にする
      0 : 指定したウィンドウに特に影響はない
      1 : 指定したウィンドウがアクティブになる
      2 : 指定したウィンドウがアクティブになり、さらに常に最前面になる

      のようにウィンドウの状態を変更することができます。
      p2の指定を省略した場合は、特に何も影響はありません。

      p2=-1で非表示にした場合は、 指定したウィンドウが消えますが完全に消去されるわけではありません。再びp2=1か2でアクティブにすると復帰します。
    </Setting>
  </command>
  <command>
    <Name>gzoom</Name>
    <Title>変倍して画面コピー</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8
      p1=0〜     : 画面にコピーする時の大きさX（ドット単位）
      p2=0〜     : 画面にコピーする時の大きさY（ドット単位）
      p3=0〜(0)  : ウィンドウID
      p4=0〜(0)  : コピー元の左上X座標
      p5=0〜(0)  : コピー元の左上Y座標
      p6=0〜     : コピーする大きさX（ドット単位）
      p7=0〜     : コピーする大きさY（ドット単位）
      p8=0〜1(0) : ズームのモード
    </Format>
    <Setting>
      gzoom命令は、 指定したウィンドウIDの画面の一部を現在の描画先カレントポジションに、任意の大きさに変倍してコピーします。
      コピー元のウィンドウIDは、自分のウィンドウIDと同じかまたは、screen命令やbuffer命令で初期化されたウィンドウIDでなければなりません。

      p8でズームのモードを指定することができます。
      p8に1を指定した場合には、 拡大縮小時にハーフトーンを使用した高品質な画像を生成します。(Windows9Xでは動作しません。)

      p8が0か、または省略されている場合は、ハーフトーンを使用しませんが、 そのぶん高速に画像処理を行なうことができます。
    </Setting>
  </command>
  <command>
    <Name>palcolor</Name>
    <Title>描画パレット設定</Title>
    <Format>
      p1
      p1=0〜255(0) : パレットコード
    </Format>
    <Setting>
      メッセージ表示、描画などの色を指定した値に設定します。
      p1はパレットコードになります。パレットコードは、 パレットモード画面のために用意された256色(palette命令により設定された色)の中で何番目かを示すものです。
      通常フルカラーモードを利用している限りでは使用する必要はありません。
    </Setting>
  </command>
  <command>
    <Name>palette</Name>
    <Title>パレット設定</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜255(0)       : パレットコード
      p2,p3,p4=0〜255(0) : 色コード（R,G,Bの輝度）
      p5=0〜1(0)         : 更新スイッチ
    </Format>
    <Setting>
      現在の画面に設定されているパレットの色データを変更します。
      p1のパレットコードにp2,p3,p4で指定した輝度のRGBカラーを設定します。
      p1の値がマイナスの場合は、設定は無視されます。
      p5の値によって、画面上の更新を指定することができます。
      p5が0か省略されている時は、パレットに値を設定しますが、 すぐには画面上に反映されません。
      p5が1の時は、設定したパレット全体が画面上にも反映されます。
      画面上に反映されるまでには時間がかかるため、パレットをまとめて更新する場合には、一番最後に更新スイッチを1にするようにしてください。
    </Setting>
  </command>
  <command>
    <Name>pget</Name>
    <Title>1dotの点を取得</Title>
    <Format>
      p1,p2
      p1=0〜 : 画面上のX座標
      p2=0〜 : 画面上のY座標
    </Format>
    <Setting>
      画面上の1ドットの色データを読みだします。

      p1,p2で指定した座標にあるドットの色データが選択色として設定されます。(color命令で指定したのと同じ状態になります)
      p1,p2の指定を省略した場合には、pos命令で設定されたカレントポジションの座標が使用されます。
      取得した色の情報は、ginfo関数またはginfo_r,ginfo_g,ginfo_bマクロにより参照することができます。
    </Setting>
  </command>
  <command>
    <Name>picload</Name>
    <Title>画像ファイルをロード</Title>
    <Format>
      "filename",p1
      "filename" : ロードするファイル名
      p1=0〜1(0) : 画像ロードモード
    </Format>
    <Setting>
      画像ファイルをロードします。通常は、

      picload "test.bmp"

      とするだけで、"test.bmp"で指定された画像ファイルが現在の画面にロードされ、ウィンドウサイズが自動的に絵のサイズに合わせられます。

      p1の画像ロードモードは、

      モード０：ウィンドウを初期化してロード
      モード１：現在の画面の上にロード
      モード２：黒色でウィンドウを初期化してロード

      p1のロードモードを省略もしくは０にすることで、画像のサイズで初期化したウィンドウにロードされます。

      p1にロードモード１を指定することで、現在のウィンドウのサイズなどを一切変更せず指定した座標からロードすることができます。 この場合は、pos命令で指定した座標が左上となります。

      現在ロードできる、ファイル形式は以下の通りです。

      BMP形式  : 拡張子 BMP : Windows標準の4,8,24bitのデータ。
      RLE圧縮のデータも扱うことができます。
      GIF形式  : 拡張子 GIF : GIF形式のデータ。
      アニメーション形式は扱えません。
      JPEG形式 : 拡張子 JPG : JFIF標準のJPEGデータ。
      グレイスケールデータでもOKです。
      ICO形式  : 拡張子 ICO : Windows標準のICO形式のアイコンデータ。
      PNG形式  : 拡張子 PNG : Portable Network Graphicsデータ。(*)
      PSD形式  : 拡張子 PSD : Photoshop形式のデータ。(合成レイヤーのみ)(*)
      TGA形式  : 拡張子 TGA : TARGA 形式のデータ。(*)

      picload命令は、screen、buffer、 bgscr命令で初期化された画面に対して実行することができます。
      ※マルチアイコン形式のICOファイルには標準では対応していません。
      ※インターレース形式のPNGファイルには標準では対応していません。PNGがサポートするすべての形式を読み込む場合は、imgloadまたはhspcvプラグインをご使用下さい。
      ※(*)の付いた形式は、コンパクト版ランタイム(hsp3c)、及びHSPLetでは使用することができませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>pos</Name>
    <Title>カレントポジション設定</Title>
    <Format>
      p1,p2
      p1=0〜     : カレントポジションのX座標
      p2=0〜     : カレントポジションのY座標
    </Format>
    <Setting>
      メッセージ表示、オブジェクトの表示などの基本座標となるカレントポジションの座標を指定します。

      Xは一番左が0に、Yは上が0になり、1ドット単位の指定になります。
      パラメータの省略をすると、現在の値が使われます。
    </Setting>
  </command>
  <command>
    <Name>pset</Name>
    <Title>1dotの点を表示</Title>
    <Format>
      p1,p2
      p1=0〜 : 画面上のX座標
      p2=0〜 : 画面上のY座標
    </Format>
    <Setting>
      画面上に、現在設定されている描画色で1ドットの点を描画します。
      p1,p2の指定を省略した場合には、pos命令で設定されたカレントポジションの座標が使用されます。
    </Setting>
  </command>
  <command>
    <Name>redraw</Name>
    <Title>再描画の設定</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜3(1) : 描画モードの設定
      p2=0〜(0)  : 再描画する左上X座標
      p3=0〜(0)  : 再描画する左上Y座標
      p4=0〜(0)  : 再描画する大きさX（ドット単位）
      p5=0〜(0)  : 再描画する大きさY（ドット単位）
    </Format>
    <Setting>
      画面の描画モードを指定します。描画モードとは、

      描画モード0:

      mes,print,gcopy,gzoom などの画面制御命令が実行されても仮想画面を書き換えるだけで、実際の画面には反映されません。

      描画モード1:

      画面制御命令が実行されると、実際の画面にも反映されます。

      となっています。通常は描画モード１です。
      描画モード0で画面内に画像をコピーしたり、メッセージを表示しておいて、最後にモード1にすることで画面の書き換えのちらつきをなくしスムーズに見せることができます。

      モード1を指定した場合は即座に画面の更新を行います。

      モード値に2を足した値を指定すると、描画モードのみを変更し画面の更新はされません。

      また、p2〜p5までのパラメータにより、画面の一部だけを再描画させることが可能です。通常は省略すれば、全画面の更新を行ないます。
    </Setting>
  </command>
  <command>
    <Name>screen</Name>
    <Title>ウィンドウを初期化</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7,p8
      p1=0〜(0)  : ウィンドウID
      p2=0〜(640): 初期化する画面サイズX（1ドット単位）
      p3=0〜(480): 初期化する画面サイズY（1ドット単位）
      p4=0〜1(0) : 初期化する画面モード
      p5=0〜(-1) : ウィンドウの配置X（1ドット単位）
      p6=0〜(-1) : ウィンドウの配置Y（1ドット単位）
      p7=0〜     : ウィンドウのサイズX（1ドット単位）
      p8=0〜     : ウィンドウのサイズY（1ドット単位）
    </Format>
    <Setting>
      指定したウィンドウIDを初期化して使用できるようにします。
      HSPの初期状態では、ウィンドウID0の画面しか使用されていませんが、ウィンドウID1以上を指定することで、新しいウィンドウを作成することができます。
      ID1以上のウィンドウは、標準でサイズを自由に変えることが可能なスタイルを持つことになります。

      p4の初期化する画面モードは、以下から選ぶことができます。

      0(screen_normal)    : フルカラーモードで作成する
      +1(screen_palette)   : パレットモード(1670万色中256色)で作成する
      +2(screen_hide)      : 非表示のウィンドウを作成する
      +4(screen_fixedsize) : サイズ固定ウィンドウ
      +8(screen_tool)      : ツールウィンドウ
      +16(screen_frame)     : 深い縁のあるウィンドウ

      p4パラメータに「+1」(パレットモードで作成する)を指定した場合は、パレットあり256色のモードで画面が作成されます。 0を指定した場合は、フルカラー(24bitカラー)の画面が作成されます。

      p4パラメータに「+2」(非表示のウィンドウを作成する)を指定した場合は、実行時にはウィンドウが表示されませんが、「gsel ID,1」 で表示させることが可能です。

      p4パラメータのうち「+4」「+8」「+16」 はそれぞれウィンドウのスタイルを設定するためのものです。
      「サイズ固定ウィンドウ」は、ID1以降のウィンドウでも、ID0のウィンドウと同様のサイズ変更が不可能なスタイルで作成されます。
      「ツールウィンドウ」は、タイトルバーのサイズが小さくなりタスクバーにウインドゥ名が表示されないウィンドウが作成されます。

      p4パラメータが省略された場合は、 現在のWindows画面モードがパレットあり(256色) の場合はパレットモードで作成され、そうでない場合はフルカラーの画面として作成されます。

      画面モードの値は、値を合計することで複数の設定を行なうことができます。
      たとえば、

      screen 2,320,240,4+8

      は、サイズ固定+ツールウィンドウのスタイルを持ったものが作成されます。

      screen命令は、すでに初期化されているウィンドウIDをふたたび別の設定で再初期化することも可能です。

      例 ：
      screen 0,640,480,1

      上の例では、ウィンドウID0、つまりメインウィンドウを640x480ドット、パレットモードで再初期化します。

      p5,p6パラメーターにより、デスクトップ画面上に表示されるウィンドウの位置を指定することができます。
      p5,p6を省略またはマイナス値にした場合は、システム規定の座標が使用されます。
      p2,p3パラメーターで指定された画面サイズの一部だけをウィンドウに表示したい場合には、
      p7,p8のパラメータで、ウィンドウのクライアントサイズ(実際に表示される大きさ)を指定することができます。
      その場合は、groll命令によりウィンドウ内に表示される位置を設定することができるようになります。
      通常は、p7,p8パラメーターの指定は省略して構いません。その場合は、p2,p3で指定された画面サイズと同じクライアントサイズで表示します。

      screen命令で画面を初期化した後はそのウィンドウIDが画面制御命令の描画先になります。
    </Setting>
  </command>
  <command>
    <Name>width</Name>
    <Title>ウィンドウサイズ設定</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜(-1) : クライアントエリアのサイズX（1ドット単位）
      p2=0〜(-1) : クライアントエリアのサイズY（1ドット単位）
      p3=0〜(-1) : ディスプレイ上でのウィンドウX座標（1ドット単位）
      p4=0〜(-1) : ディスプレイ上でのウィンドウY座標（1ドット単位）
    </Format>
    <Setting>
      ウィンドウのクライアントサイズ(実際に表示される大きさ)とウィンドウ表示位置を変更します。
      クライアントサイズは、screen命令やbuffer,bgscr命令で初期化された画面サイズより大きくすることはできません。

      p1,p2およびp3,p4パラメータが省略されるか、またはマイナス値の場合は、現在の設定が使われます。
    </Setting>
  </command>
  <command>
    <Name>sysfont</Name>
    <Title>システムフォント選択</Title>
    <Format>
      p1
      p1=0〜 : フォント種類指定
    </Format>
    <Setting>
      システム標準のフォントを選択します。
      p1で、フォントの種類を指定します。これは以下の中から選びます。

      p1 : font set
      --------------------------------------------------------------------
      0 : HSP標準システムフォント
      10 : OEM 文字セットの固定幅フォント
      11 : Windows 文字セットの固定幅システムフォント
      12 : Windows 文字セットの可変幅システムフォント
      13 : 標準システムフォント
      17 : デフォルトGUIフォント
      (標準の環境でメニューやダイアログボックスに使われています)

      p1が省略された場合は、標準システムフォントが選択されます。
    </Setting>
  </command>
  <command>
    <Name>line</Name>
    <Title>直線を描画</Title>
    <Format>
      p1,p2,p3,p4
      p1=0〜(0)  : ラインの終点X座標
      p2=0〜(0)  : ラインの終点Y座標
      p3=0〜     : ラインの始点X座標
      p4=0〜     : ラインの始点Y座標
    </Format>
    <Setting>
      画面上に、(p1,p2)と(p3,p4)を結ぶ直線を描画します。
      (p3,p4)を省略した場合は、カレントポジションから(p1,p2)まで、現在設定されている色で直線が描画されます。

      line命令実行後は、(p1,p2)の座標がカレントポジションになります。
      これにより、連続した直線を描画していくことが可能です。
    </Setting>
  </command>
  <command>
    <Name>circle</Name>
    <Title>円を描画する</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜(0)  : 矩形の左上X座標
      p2=0〜(0)  : 矩形の左上Y座標
      p3=0〜     : 矩形の右下X座標
      p4=0〜     : 矩形の右下Y座標
      p5=0〜1(1) : 描画モード(0=線,1=塗りつぶし)
    </Format>
    <Setting>
      画面上に、(p1,p2)と(p3,p4)を左上、右下の点として、矩形(四角形)に収まる大きさの円を描画します。
      描画色は、color命令等で設定されたものになります。

      p5に0が指定されている場合は、輪郭だけを線で描画します。
      p5が1または省略されている場合は、円の内部も塗りつぶします。
    </Setting>
  </command>
  <command>
    <Name>syscolor</Name>
    <Title>システムカラーを設定する</Title>
    <Format>
      p1
      p1 : 設定するシステムカラーインデックス
    </Format>
    <Setting>
      p1で指定したシステムカラーインデックスを選択色として設定します。
      (color命令で指定したのと同じ状態になります)
      p1で指定できるシステムカラーインデックスは、以下の値となります。

      0 : スクロールバーの軸の色
      1 : デスクトップの色
      2 : アクティブウィンドウのタイトルバーの色 (グラデーションの場合はアクティブウィンドウのタイトルバーの左側の色)
      3 : 非アクティブウィンドウのタイトルバーのテキストの色 (グラデーションの場合は非アクティブウィンドウのタイトルバーの左側の色)
      4 : メニューの背景色
      5 : ウィンドウの背景色
      6 : ウィンドウの枠の色
      7 : メニュー内のテキストの色
      8 : ウィンドウ内のテキストの色
      9 : アクティブウィンドウのタイトルバーのテキストの色
      10 : アクティブウィンドウの境界の色
      11 : 非アクティブウィンドウの境界色
      12 : MDIアプリケーションの背景色
      13 : コントロール内における選択された項目の色
      14 : コントロール内における選択された項目のテキストの色
      15 : 3D オブジェクトの表面色
      16 : 3D オブジェクトの影の色 (光源の反対方向の縁用)
      17 : 淡色状態 (無効状態) のテキストの色
      18 : プッシュボタンのテキストの色
      19 : 非アクティブウィンドウのタイトルバーのテキストの色
      20 : 3D オブジェクトの最も明るい色 (光源方向の縁用)
      21 : 3D オブジェクトの暗い影の色
      22 : 3D オブジェクトの明るい色 (光源方向の縁用)
      23 : ツールチップコントロールのテキストの色
      24 : ツールチップコントロールの背景色
      26 : ホットトラックアイテムの色
      27 : グラデーションの場合はアクティブウィンドウのタイトルバーの右側の色
      28 : グラデーションの場合は非アクティブウィンドウのタイトルバーの右側の色
      29 : (Windows XP以上) メニューがフラットメニューとして表示されるときにメニューアイテムをハイライト表示するのに使用される色
      30 : (Windows XP以上) メニューがフラットメニューとして表示されるときのメニューバーの背景色
    </Setting>
  </command>
  <command>
    <Name>hsvcolor</Name>
    <Title>HSV形式でカラーを設定する</Title>
    <Format>
      p1,p2,p3
      p1=0〜191(0) : HSV形式 H値
      p2=0〜255(0) : HSV形式 S値
      p3=0〜255(0) : HSV形式 V値
    </Format>
    <Setting>
      色の指定をHSV形式で行ないます。
      color命令と同様に、以降の描画命令で設定された色が使用されます。
    </Setting>
  </command>
  <command>
    <Name>ginfo</Name>
    <Title>ウィンドウ情報の取得</Title>
    <Format>
      (p1)
      p1=0〜 : 取得するタイプ
    </Format>
    <Setting>
      p1で指定したタイプのウィンドウ関連情報値を返します。
      取得できるタイプは以下の通りです。

      0 : スクリーン上のマウスカーソルX座標
      1 : スクリーン上のマウスカーソルY座標
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      2 : アクティブなウィンドウID

      現在アクティブになっているウィンドウIDを返します。
      もし、 アクティブになっているウィンドウがHSP以外の場合は-1になります。

      3 : 操作先ウィンドウID

      gsel命令で指定した画面の操作先ウィンドウIDが代入されます。

      4 : ウィンドウの左上X座標
      5 : ウィンドウの左上Y座標

      スクリーン座標系で現在のウィンドウの左上座標を返します。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      6 : ウィンドウの右下X座標
      7 : ウィンドウの右下Y座標

      スクリーン座標系で現在のウィンドウの右下座標を返します。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      8 : ウィンドウの描画基点X座標
      9 : ウィンドウの描画基点Y座標

      現在の操作先ウィンドウの描画基点座標を返します。
      これは、描画内容をスクロール可能な(初期化サイズよりも表示サイズが小さい)ウィンドウにおいて、どれだけスクロールされているかを示す値です。
      スクロールさせていない通常の状態では、(0,0)になります。
      描画基点を設定する場合は、groll命令を使用します。

      10 : ウィンドウ全体のXサイズ
      11 : ウィンドウ全体のYサイズ

      現在の操作先ウィンドウの横幅、縦幅が返されます。
      これは、ウィンドウの枠やタイトルバーなども含めたサイズになります。

      12 : クライアント領域Xサイズ
      13 : クライアント領域Yサイズ

      現在の操作先ウィンドウのクライアント領域サイズが返されます。
      クライアント領域はウィンドウ内に表示されている描画可能な部分を指します。

      14 : メッセージの出力Xサイズ
      15 : メッセージの出力Yサイズ

      最後にmes, print命令により出力されたメッセージのサイズが返されます。
      サイズは、 X,Y座標にどれだけのドット数で描画されたかを示します。
      画面上の絶対座標ではないので注意してください。
      また、複数行ある文字列を出力した場合は、最後の行にあたるサイズが取得されます。

      16 : 現在設定されているカラーコード(R)
      17 : 現在設定されているカラーコード(G)
      18 : 現在設定されているカラーコード(B)

      color命令などにより指定された色コードが返されます。

      19 : デスクトップのカラーモード

      現在のデスクトップカラーモード(色モード)が返されます。
      フルカラーモードの場合は0が、パレットモードの場合は1が返されます。

      20 : デスクトップ全体のXサイズ
      21 : デスクトップ全体のYサイズ

      デスクトップ全体のサイズ(画面解像度)が返されます。

      22 : カレントポジションのX座標
      23 : カレントポジションのY座標

      pos命令により設定されたカレントポジションのX,Y座標が返されます。

      24 : メッセージ割り込み時のウィンドウID

      oncmd命令により設定されたメッセージ割り込み時のウィンドウIDが返されます。

      25 : 未使用ウィンドウID

      screen命令やbuffer命令などで初期化されていない未使用のウィンドウIDが返されます。

      26 : 画面の初期化Xサイズ
      27 : 画面の初期化Yサイズ

      現在の操作先ウィンドウの初期化サイズが返されます。
      最初にscreen,bgscr,buffer命令で初期化された画面サイズになります。

      256 : 加速度センサー値(X)
      257 : 加速度センサー値(Y)
      258 : 加速度センサー値(Z)

      加速度センサーが使用可能な環境で、センサーの値を取得します。
      それぞれの座標軸の加速度を-1.0〜+1.0の範囲で取得したものになります。
      加速度センサーが使用できない環境では、0.0が取得されます。
    </Setting>
  </command>
  <command>
    <Name>grect</Name>
    <Title>回転する矩形で塗りつぶす</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=0〜(0)   : 矩形の中心X座標
      p2=0〜(0)   : 矩形の中心Y座標
      p3=0〜(0.0) : 回転角度(単位はラジアン)
      p4=0〜(?)   : Xサイズ
      p5=0〜(?)   : Yサイズ
    </Format>
    <Setting>
      (p1,p2)で指定した座標を中心として、 (p4,p5)で指定したサイズの矩形(長方形)を現在設定されている色で描画します。
      p3で回転角度を実数で指定することができます。
      角度の単位は、ラジアン(0から始まって、2πで一周)となります。
      grect命令は、gmodeで設定されたコピーモードの指定が反映されます。

      gmodeが 0,1の場合は、通常の塗りつぶし。
      gmodeが 3の場合は、指定されたレートで半透明になります。
      gmodeが 5, 6の場合は、それぞれ色加算、色減算処理となります。
      また、(p4,p5)のサイズ指定を省略した場合には、gmode命令で設定されているコピーサイズが使用されます。

      パレットモード時には 指定した描画色で塗りつぶしが行なわれますが、半透明処理は行われません。
    </Setting>
  </command>
  <command>
    <Name>grotate</Name>
    <Title>矩形画像を回転してコピー</Title>
    <Format>
      p1,p2,p3,p4,p5,p6
      p1=0〜(0)   : コピー元のウィンドウID
      p2=0〜(0)   : コピー元の左上X座標
      p3=0〜(0)   : コピー元の左上Y座標
      p4=0〜(0.0) : 回転角度(単位はラジアン)
      p5=0〜(?)   : Xサイズ
      p6=0〜(?)   : Yサイズ
    </Format>
    <Setting>
      grotate命令は、gcopy命令に回転を含めた処理を行ないます。
      p1で、コピー元のウィンドウIDを指定、(p2,p3) でコピーされる元の画像にあたる座標を指定します。(gcopy命令と同様です)
      コピー先は、現在の描画先に指定されているウィンドウIDで、 pos命令で設定された場所を中心とした座標にコピーを行ないます。その際に、p4で回転角度を実数で指定することができます。
      角度の単位は、ラジアン(0から始まって、2πで一周)となります。
      (p5,p6)で、コピーされた後のX,Yサイズを指定します。
      また、コピー元のX,Yサイズはgmode命令で設定されたデフォルトのコピーサイズが使用されます。
      つまり、gmode命令で指定されたサイズよりも大きなサイズを(p5,p6)で指定した場合には、拡大されることになります。
      (p5,p6) を省略した場合には、コピー元と同じサイズ、つまり等倍でコピーが行なわれます。

      grotate命令は、gmodeで設定されたコピーモードの指定が反映されます。(モード7のピクセルアルファブレンドコピーは適用されません。)
      透明色の設定や、半透明の設定はすべて gcopy命令でコピーした場合と同等に機能します。(詳しくはgmode命令のリファレンスを参照)

      パレットモード時には半透明処理は実行されません。
      また、異なる画面モード(パレットモードとフルカラーモード)間でのコピーはエラーになります。
    </Setting>
  </command>
  <command>
    <Name>gsquare</Name>
    <Title>任意の四角形を描画</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜(0) : コピー元のウィンドウID (マイナス値ならば塗りつぶし)
      p2=変数名 : コピー先X座標が格納される数値型配列変数名
      p3=変数名 : コピー先Y座標が格納される数値型配列変数名
      p4=変数名 : コピー元X座標が格納される数値型配列変数名
      p5=変数名 : コピー元Y座標が格納される数値型配列変数名
    </Format>
    <Setting>
      任意の４点を持つ四角形をコピーまたは塗りつぶします。
      p1で、画像コピー元のウィンドウIDを指定します。

      p2,p3にはコピー先の座標４つを配列に格納した変数を指定します。
      p4,p5にはコピー元の座標４つを配列に格納した変数を指定します。
      配列変数には、左上(0),右上(1),右下(2),左下(3) の順番に座標を入れておく必要があります。

      gsquare命令は、gmodeで設定されたコピーモードの指定が反映されます。(モード7のピクセルアルファブレンドコピーは適用されません。)
      透明色の設定や、半透明の設定はすべて gcopy命令でコピーした場合と同等に機能します。(詳しくはgmode命令のリファレンスを参照)

      パレットモード時には半透明処理は実行されません。
      また、異なる画面モード(パレットモードとフルカラーモード)間でのコピーはエラーになります。

      p1に-1などマイナス値を指定した場合は、画像コピーではなく塗りつぶしが行なわれます。
      塗りつぶしは、単色による塗りつぶしと、グラデーションによる塗りつぶしを選択することができます。
      p1に、-1から-256の値を指定した場合は、単色による塗りつぶしとなります。
      単色塗りつぶしを行なう場合には、p4,p5パラメーターを指定する必要はありません。
      その際、フルカラーモード時には 描画色による塗りつぶしとなります。
      パレットモード時は、p1で指定した値-1をパレットコードとして塗りつぶしを行ないます。(-1〜-256がパレットコード0〜255に対応します)

      p1に、-257またはgsquare_grad(-257のマクロ定義)を指定した場合は、グラデーションによる塗りつぶしが実行されます。
      グラデーション塗りつぶしを行なう場合には、p4パラメーターに頂点の色を示すRGBコードを格納した配列変数を指定してください。
      (RGBコードは、gradf命令で指定される色コードと同一のものになります。)
      グラデーション塗りつぶしでは、gmodeで設定されたコピーモードの指定は反映されず、常に不透明の描画になるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objinfo</Name>
    <Title>ウィンドウオブジェクト情報の取得</Title>
    <Format>
      (p1,p2)
      p1=0〜 : ウィンドウオブジェクトID
      p2=0〜 : 取得するタイプ
    </Format>
    <Setting>
      現在アクティブなウィンドウに配置されている、特定のウィンドウオブジェクトに関連する情報値を返します。
      p1にウィンドウオブジェクトID、p2に取得タイプを指定することで、該当する情報データが返されます。
      取得できるタイプは以下の通りです。

      0  : モード(下位16bit)及びオプションデータ(上位16bit)
      1  : objectが配置されているBMSCR構造体のポインタ
      2  : ウィンドウオブジェクトのハンドル(HWND)
      3  : owid (内部汎用データ)
      4  : owsize (内部汎用データ)
      5〜8  : 代入変数の情報
      9〜11 : ウィンドウオブジェクトコールバックの情報

      ウィンドウオブジェクト情報は、通常の使用では利用する必要はありません。
      外部API(DLL)等にウィンドウオブジェクトのハンドル(HWND)を渡す場合など、特殊な用途に利用することができます。
    </Setting>
  </command>
  <command>
    <Name>axobj</Name>
    <Title>ActiveXコントロールの配置</Title>
    <Format>
      p1,"IID",p2,p3
      p1    : COMオブジェクトが代入される変数名
      "IID" : COMオブジェクトのクラスIDまたはプログラムID
      p2=0〜: オブジェクトのXサイズ
      p3=0〜: オブジェクトのYサイズ
    </Format>
    <Setting>
      "IID"で指定されたクラスIDまたは、プログラムID(ProgID)を持つActiveXコントロール(OLEコントロール)をウィンドウオブジェクトとして配置します。
      p2,p3で配置されるオブジェクトのX,Yサイズを指定します。
      サイズの指定が省略されるか0以下の場合は、ウインドゥ全体のサイズが使用されます。
      配置に成功した場合は、システム変数statにオブジェクトIDが代入され、p1の変数をコントロールのためのCOMオブジェクト型変数として初期化します。
      ActiveXコントロールの配置に失敗した場合は、システム変数statに-1が代入されて終了します。

      例 :
      axobj ie, "Shell.Explorer.2",640,480
      ie->"Navigate" "www.onionsoft.net"
    </Setting>
  </command>
  <command>
    <Name>winobj</Name>
    <Title>ウィンドウオブジェクトの配置</Title>
    <Format>
      "Class","Title",p1,p2,p3,p4,p5,p6
      "Class" : ウィンドウクラス名
      "Title" : ウィンドウ名
      p1(0)   : 拡張ウィンドウスタイル
      p2(0)   : ウィンドウスタイル
      p3(0)   : Xサイズ
      p4(0)   : Yサイズ
      p5(0)   : メニューハンドルまたは子ウィンドウID
      p6(0)   : ウィンドウ作成データ
    </Format>
    <Setting>
      winobjは、 Windowsのシステムがサポートするウィンドウをオブジェクトとして配置します。
      p3,p4で配置するX,Yサイズを指定します。 サイズの指定が省略されるか0以下の場合は、objsizeで設定されている値が使用されます。

      指定したウィンドウオブジェクトが生成されるとシステム変数statにオブジェクトIDが代入されます。
      このオブジェクトIDは、clrobj命令を始めとするオブジェクト操作命令で使用することができます。
      (生成されたウィンドウは、 現在アクティブなウィンドウが管理するオブジェクトとして登録されます。)
      内部エラーなどでウィンドウオブジェクトが正常に生成されなかった場合には、システム変数statに-1が代入されます。

      winobjによって配置したオブジェクトに対してobjprm命令を使用することはできません。

      この命令は、HSPの命令がサポートしていないウィンドウオブジェクトをWindows APIを通して配置するためのもので、WIN32API のCreateWindowExと同様のパラメーターを受け取ります。 外部DLLとのやり取りや、モジュール作成に使用するもので通常覚えておく必要はありません。
    </Setting>
  </command>
  <command>
    <Name>sendmsg</Name>
    <Title>ウィンドウメッセージの送信</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1(0) : ウィンドウハンドル
      p2(0) : メッセージID
      p3(0) : wParam値
      p4(0) : lParam値
    </Format>
    <Setting>
      p1で指定したウィンドウハンドルに対して、 p2のメッセージとp3,p4のパラメーターを送信します。

      p1で指定するウィンドウハンドルの値は、 HSPのウィンドウであればシステム変数hwndを、HSPのウィンドウオブジェクトの場合はobjinfo関数により取得することができます。

      p3をwParam、p4をlParamの情報としてウィンドウメッセージが送信されます。
      p3パラメーターは、整数値を指定することが可能です。
      p4パラメーターには、整数値、文字列のいずれかを指定することができます。
      整数値の場合は、値そのものをlParamとして扱います。
      文字列の場合は、文字列ポインタ値をlParamとして扱います。

      この命令は、 HSPの命令がサポートしていないウィンドウオブジェクトに対してWindowsのメッセージを送信するためのものです。
      外部DLLとのやり取りや、 モジュール作成に使用するもので通常覚えておく必要はありません。
    </Setting>
  </command>
  <command>
    <Name>groll</Name>
    <Title>ウィンドウの描画基点を設定</Title>
    <Format>
      p1,p2
      p1=0〜(0)  : ウィンドウに描画する基点となるX座標
      p2=0〜(0)  : ウィンドウに描画する基点となるY座標
    </Format>
    <Setting>
      ウィンドウに描画する基点座標を設定します。
      基点座標は、描画内容をスクロール可能な(初期化サイズよりも表示サイズが小さい)ウィンドウにおいて、X,Y方向にどれだけスクロールされているかを示すものです。
      (0,0)を設定すると、スクロールさせていない通常の状態になります。
      現在設定されている基点座標は、ginfo関数によって取得することができます。
    </Setting>
  </command>
  <command>
    <Name>gradf</Name>
    <Title>矩形をグラデーションで塗りつぶす</Title>
    <Format>
      p1,p2,p3,p4,p5,p6,p7
      p1=0〜(0)  : 矩形の左上X座標
      p2=0〜(0)  : 矩形の左上Y座標
      p3=0〜     : 矩形のXサイズ
      p4=0〜     : 矩形のYサイズ
      p5=0〜(0)  : グラデーションのモード
      p6=0〜     : 塗りつぶし色1(RGBカラーコード)
      p7=0〜     : 塗りつぶし色2(RGBカラーコード)
    </Format>
    <Setting>
      (p1,p2)を左上の点として、(p3,p4)のサイズをグラデーションで矩形(四角形)を塗りつぶします。
      塗りつぶす色は、p6,p7で指定されたRGBカラーコードとなります。
      RGBカラーコードは、color命令で指定するR,G,Bそれぞれの輝度をまとめて24ビット数値で表現したものです。
      スクリプトで記述する場合は、最初に「$」を付けた16進表現を行なうと便利です。
      「$112233」のように記述した場合は、R輝度が$11、G輝度が$22、B輝度が$33という値になります。この場合、輝度は$00〜$ffまでとなります。(10進数の0〜255にあたります)
      p5でグラデーションのモードを指定することができます。

      p5 : グラデーションのモード
      --------------------------------------------------------------------
      0 : 横方向のグラデーション
      1 : 縦方向のグラデーション

      グラデーションの塗りつぶしは、左上をp6、右下をp7で指定された色として行なわれます。
      p6及びp7の指定を省略した場合は、現在の描画色を使用します。
      (p1,p2)を省略した場合は、画面の左上(0,0)が設定されます。
      (p3,p4)を省略した場合は、画面の描画サイズが設定されます。

      例 :
      ; グラデーションで矩形を塗りつぶし
      gradf 120,180,400,100, 1, $ff00ff, $ffffff

      単色で矩形を塗りつぶす場合は、boxf命令を使用してください。
      また、四角形の頂点それぞれの色を指定したグラデーション描画を行なう場合は、gsquare命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>celload</Name>
    <Title>画像ファイルをバッファにロード</Title>
    <Format>
      "filename",p1,p2
      "filename" : ロードするファイル名
      p1=1〜(-1) : 読み込み先ウインドゥID
      p2=0〜1(0) : 初期化する画面モード
    </Format>
    <Setting>
      画像ファイルを指定した仮想画面に読み込みます。
      celload命令は、主にcelput命令やgcopy命令でコピーを行なうための画像素材を
      仮想画面(非表示のウィンドウ)に読み込むためのものです。
      buffer命令によって仮想画面を初期化して、picload命令で画像ファイルを読み込む
      という動作と、基本的に同一です。

      "filename"パラメーターで、読み込む画像ファイル名を指定します。
      使用できる画像ファイルの形式は、picload命令と同じです。
      p1で、読み込み先のウインドゥIDを指定することができます。
      p1が省略されるか、マイナス値の場合は未使用のウインドゥIDが自動的に使用されます。
      (命令実行後、システム変数statに読み込まれたウィンドウIDが代入されます。)
      p2で、仮想画面の初期化モードを指定することができます。
      p2が省略されるか、0の場合はフルカラーモード。1の場合は、パレットモードが選択されます。

      celload命令により、画像素材を効率的に読み込み管理することができます。
      詳しくは、プログラミングマニュアル(hspprog.htm)のCEL関連命令についてを参照してください。
    </Setting>
  </command>
  <command>
    <Name>celdiv</Name>
    <Title>画像素材の分割サイズを設定</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=0〜(1)  : ウインドゥID
      p2=1〜(0)  : 横方向の分割サイズ
      p3=1〜(0)  : 縦方向の分割サイズ
      p4=0〜(0)  : 横方向の中心座標
      p5=0〜(0)  : 縦方向の中心座標
    </Format>
    <Setting>
      指定したウィンドウIDが持つ画像素材の分割サイズを設定します。
      分割された画像素材は、celput命令により画像を描画する際に参照されます。
      たとえば、256×256ドットの画像を128×64ドットで分割する設定にした場合、
      celput命令により128×64ドットの画像8枚分として扱うことができるようになります。

      p1で、画像素材を持つウインドゥIDを指定します。
      (p2,p3)で、横(X)・縦(Y)方向の分割サイズ(分割された領域１つあたりのドット数)を指定します。
      分割サイズを省略、または0以下の値にした場合は、素材のサイズがそのまま使用されます。

      (p4,p5)で、描画の中心座標を設定することができます。
      これは、celput命令で描画を行なった際に、描画の基点位置になります。
      たとえば、(0,0)を中心座標として指定した場合は、celput命令で描画される位置(pos命令で指定した座標)に、画像素材の(0,0)が参照されることになります。
      また、回転した画像の描画を行なう際にも、回転の中心となります。
      通常は、(0,0)の位置、つまり左上が基点位置となっています。これは、gcopy命令での基点位置と同様です。


      画像素材の分割設定は、ウィンドウIDごとに保存されており、cls命令などで初期化された
      時点では、分割なし(画面全体をサイズとして指定)の設定になっています。
      分割の設定は、必ず指定されたウィンドウIDに画像素材が読み込まれた状態で行なってください。
      分割の設定を行なった後に、画像素材の読み込みを行なった場合は、分割設定はリセットされます。
      詳しくは、プログラミングマニュアル(hspprog.htm)のCEL関連命令についてを参照してください。
    </Setting>
  </command>
  <command>
    <Name>celput</Name>
    <Title>画像素材を描画</Title>
    <Format>
      id,no,zoomx,zoomy,angle
      id=0〜(1) : 画像素材を持つウインドゥID
      no=0〜(0) : 分割画像No.
      zoomx=0.0〜(1.0) : 横方向の表示倍率(実数)
      zoomy=0.0〜(1.0) : 縦方向の表示倍率(実数)
      angle=0.0〜(0.0) : 回転角度(単位はラジアン)
    </Format>
    <Setting>
      仮想画面に読み込まれた画像素材を、現在の操作先ウィンドウに描画します。
      idで、画像素材を持つウインドゥIDを指定します。
      noで、分割画像No.を指定します。分割画像No.は、画像素材を持つウインドゥIDの中で
      分割された画像を特定する番号となります。
      zoomx,zoomyにより、描画される画像の横(X)・縦(Y)方向倍率を指定できます。
      zoomx,zoomyの指定は、実数で指定することが可能です。
      また、angleにより画像の回転角度を指定することも可能です。
      angleに指定される値は、実数で単位はラジアン(0から始まって、2πで一周)となります。(grotate、grect命令と同様の値になります)

      celput命令は、gcopy命令と同様に指定されたウインドゥIDの画像をコピーして描画します。
      gcopy命令と同様に、gmode命令により指定されたコピーモード、ブレンド率が反映されます。
      描画位置は、現在のカレントポジション(pos命令で指定された値)が基点となります。
      描画される画像のサイズは、通常は(指定されたウィンドウIDにある)元画像と同じものになります。
      描画される画像のサイズ及び、描画や回転の中心位置は、celdiv命令によって変更することが可能です。

      zoomx,zoomy,angleの指定を省略するか、等倍の設定(1,1,0)になっている場合は、
      自動的に高速なコピーが内部で実行されます。逆に、等倍でない描画を行なう場合は、
      grotate命令と同様の描画処理が実行されます。
      描画終了後は、描画したサイズに応じてカレントポジションを右に移動します。
      (ただし、角度は考慮されません。あくまでも描画の横サイズ分を右に移動させます)

      celput命令とその関連命令により、画像素材を効率的に管理することができます。
      詳しくは、プログラミングマニュアル(hspprog.htm)のCEL関連命令についてを参照してください。
    </Setting>
  </command>
  <command>
    <Name>bmppalette</Name>
    <Title>bmp画像パレット情報を読み込む</Title>
    <Format>
      "ファイル名"
      "ファイル名" : パレットを取り出すBMP画像ファイル名
    </Format>
    <Setting>
      8bit形式のbmp画像ファイルに含まれるパレット情報を読み込み、HSPのパレットとして取り出します。
      通常、picload命令によるパレットモードでの画像読み込みは、ファイルに付属しているパレット情報を読み込むことができません。
      hspdx拡張プラグインなど、ファイル内のパレット情報が必要となる場合に、使用することができます。
      ファイルとして指定することができるのは、8BIT形式のBMPファイルのみです。
      それ以外のファイルや、正しくない形式が指定された場合には、何も行なわれません。
    </Setting>
  </command>
  <command>
    <Name>gettimestr</Name>
    <Title>現在の時刻を文字列で取得する</Title>
    <Format>
      p1
      p1 : 文字列を取得する変数名
    </Format>
    <Setting>現在の時刻を取得して、"hh:mm:ss"の文字列型形式として変数に代入します。</Setting>
  </command>
  <command>
    <Name>getdatestr</Name>
    <Title>現在の日付を文字列で取得する</Title>
    <Format>
      p1
      p1 : 文字列を取得する変数名
    </Format>
    <Setting>現在の日付を取得して、"yyyy/mm/dd"の文字列型形式として変数に代入します。</Setting>
  </command>
  <command>
    <Name>text</Name>
    <Title>修飾文字表示の待ち時間を設定する</Title>
    <Format>
      p1
      p1(0) : 表示待ち時間(ms)
    </Format>
    <Setting>
      emes命令で表示される文字の待ち時間を設定します。
      p1で１文字ごとの待ち時間(ミリ秒単位)を指定します。
      p1に0以下の値を指定した場合は、１文字ごとの待ちは行なわず一度に表示されます。
      text命令は、HSP3から標準でなくモジュールを使用した拡張命令として扱われています。
      HSP2.xと異なり、text命令で指定した待ち時間はemes命令に反映されますので注意してください。
    </Setting>
  </command>
  <command>
    <Name>textmode</Name>
    <Title>修飾文字表示の設定を行なう</Title>
    <Format>
      p1,p2
      p1(0) : 修飾文字のモード
      p2(0) : 調整パラメーター
    </Format>
    <Setting>
      emes命令で表示される修飾文字の設定を行ないます。
      p1でモードを指定します。モードの値は以下の通りです。

      モード0 : 通常の表示
      モード1 : 影付き表示
      モード2 : 輪郭付き表示

      モード1,2を指定した場合は、textmode命令を実行した時点で設定されている色が影や輪郭で使用されます。
      また、p2に調整パラメーターを設定することで影や輪郭の距離を修正することができます。
      調整パラメーターが0の場合は、最低距離(1ドット)となり値が大きくなるごとに距離も大きくなります。
    </Setting>
  </command>
  <command>
    <Name>emes</Name>
    <Title>修飾文字を表示</Title>
    <Format>
      "strings"
      "strings" : 表示するメッセージまたは変数
    </Format>
    <Setting>
      修飾文字を表示します。
      emes命令は、mes命令と同様に文字列を画面上に表示しますが、その時に文字に修飾を行なったり、１文字づつゆっくりと表示させることができます。
      修飾文字の設定は、textmode命令で行なうことができます。
      また、修飾文字の表示速度はtext命令で指定することができます。
    </Setting>
  </command>
  <command>
    <Name>gfade</Name>
    <Title>画面のフェードを行なう</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1(0) : フェードレベル(0〜256)
      (p2,p3) : フェードを行なう左上X,Y座標
      (p4,p5) : フェードを行なうX,Yサイズ
    </Format>
    <Setting>
      フルカラー画面に対して、指定された領域を固定色フェードを行ないます。
      この命令は、時間ごとにフェードレベルを変えていくことになって、フェードイン、フェードアウトなどを行なうためのものです。
      p1でフェードレベルを指定します。0の場合は画面に影響はありません。
      p1が256の時、完全に指定した色で塗りつぶされた状態になります。
      (p2,p3)でフェードを行なう左上X,Y座標を指定します。省略した場合は、(0,0)となります。
      (p4,p5)でフェードを行なうX,Yサイズを指定します。省略した場合は、画面全体のサイズが使用されます。
    </Setting>
  </command>
  <command>
    <Name>statictext</Name>
    <Title>スタティックテキストを配置</Title>
    <Format>
      "strings",p1,p2
      "strings" : スタティックテキストの文字列
      p1(0) : Xサイズ
      p2(0) : Yサイズ
    </Format>
    <Setting>
      現在のカレントポジションから、スタティックテキストを配置オブジェクトとして生成します。
      配置されたオブジェクトIDは、システム変数statに代入されます。
      配置されるオブジェクトのサイズを(p1,p2)で指定することができます。
      配置されたスタティックテキストの内容を変更する場合は、statictext_set命令を使用してください。
      objprm命令は使用できないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>statictext_set</Name>
    <Title>スタティックテキストを変更</Title>
    <Format>
      p1,"strings"
      p1(0) : オブジェクトID
      "strings" : スタティックテキストの文字列
    </Format>
    <Setting>
      statictext命令で配置した、スタティックテキストの内容を変更します。
      p1にオブジェクトIDを指定して、"strings"で新しく設定するスタティックテキストの文字列を指定することができます。
    </Setting>
  </command>
  <command>
    <Name>scrollbar</Name>
    <Title>スクロールバーを配置</Title>
    <Format>
      p1,p2
      p1(0) : Xサイズ
      p2(0) : Yサイズ
    </Format>
    <Setting>
      現在のカレントポジションから、スクロールバーを配置オブジェクトとして生成します。
      配置されたオブジェクトIDは、システム変数statに代入されます。
      配置されるオブジェクトのサイズを(p1,p2)で指定することができます。
      この命令は、配置オブジェクトとしてスクロールバーを生成することをサポートするものです。
      配置されたスクロールバーに対するメッセージの送受信は、別途sendmsg命令で行なう必要があります。
      その際には、WIN32APIのスクロールバーメッセージに関する資料が別途必要になります。
      また、配置したオブジェクトに対しては、objprm命令は使用できないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>progbar</Name>
    <Title>プログレスバーを配置</Title>
    <Format>
      p1,p2
      p1(0) : Xサイズ
      p2(0) : Yサイズ
    </Format>
    <Setting>
      現在のカレントポジションから、プログレスバーを配置オブジェクトとして生成します。
      配置されたオブジェクトIDは、システム変数statに代入されます。
      配置されるオブジェクトのサイズを(p1,p2)で指定することができます。
      配置されたプログレスバーを進める場合は、progbar_setおよびprogbar_step命令を使用してください。
      また、配置したオブジェクトに対しては、objprm命令は使用できないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>progbar_set</Name>
    <Title>プログレスバーのステップ増分を設定する</Title>
    <Format>
      p1,p2
      p1(0) : オブジェクトID
      p2(0) : 増分値
    </Format>
    <Setting>
      p1にオブジェクトIDを指定することで、progbar命令で配置したプログレスバーの1ステップごとの増分を設定することができます。
      プログレスバーは、デフォルトで0から100までの値をカウンタとして持っています。
      これに対して、１ステップごとに増分を加算していきます。
      増分を指定しなかった場合のデフォルト値は10になります。
    </Setting>
  </command>
  <command>
    <Name>progbar_step</Name>
    <Title>プログレスバーを1ステップ進める</Title>
    <Format>
      p1
      p1(0) : オブジェクトID
    </Format>
    <Setting>
      p1にオブジェクトIDを指定することで、progbar命令で配置したプログレスバーを1ステップ進めます。
      1ステップごとの増分は、progbar_set命令によって指定することができます。
    </Setting>
  </command>
  <command>
    <Name>note2array</Name>
    <Title>複数行文字列を配列に変換</Title>
    <Format>
      p1,p2
      p1 : 変換した配列を代入する変数
      p2 : 複数行文字列が代入されている変数
    </Format>
    <Setting>
      複数行の文字列を行ごとに分割して配列変数の各要素に代入します。
      p2で指定された複数行文字列を、p1で指定した変数に変換して代入します。
      p1の変数は、必ず文字列型の１次元配列変数になります。
    </Setting>
  </command>
  <command>
    <Name>array2note</Name>
    <Title>配列を複数行文字列に変換</Title>
    <Format>
      p1,p2
      p1 : 変換したを文字列を代入する変数
      p2 : 文字列が配列に代入されている変数
    </Format>
    <Setting>
      文字列型の１次元配列変数を複数行文字列に変換します。
      p2で指定された文字列型の１次元配列変数の内容を変換し、p1で指定した変数に代入します。
    </Setting>
  </command>
  <command>
    <Name>arraysave</Name>
    <Title>文字列型の配列変数をファイルに書き出し</Title>
    <Format>
      "ファイル名",p1
      "ファイル名" : 書き出しを行なうファイル名
      p1 : 書き出しを行なう元の変数
    </Format>
    <Setting>
      p1で指定した文字列型の１次元配列変数を複数行文字列に変換した上で、指定したファイル名で書き出します。
      扱える配列は１次元配列のみになります。
      書き出したファイルは、arrayload命令によって読み込むことが可能です。
    </Setting>
  </command>
  <command>
    <Name>arrayload</Name>
    <Title>文字列型の配列変数をファイルから読み込み</Title>
    <Format>
      "ファイル名",p1
      "ファイル名" : 読み込みを行なうファイル名
      p1 : 読み込みを行なう先の変数
    </Format>
    <Setting>
      arraysave命令によって書き出されたファイルを、p1で指定した変数に読み込みます。
      この命令は、ファイルに含まれる複数行文字列の行を配列要素に変換して代入するもので、作成される配列配列は１次元配列になります。
    </Setting>
  </command>
  <command>
    <Name>alloc</Name>
    <Title>バッファを確保</Title>
    <Format>
      p1,p2
      p1=変数    : バッファを割り当てる変数名
      p2=1〜(64) : バッファのサイズ(Byte単位)
    </Format>
    <Setting>
      メモリ上にバッファを作成して変数に割り当てます。
      割り当てられた変数は、文字列型となります。

      この命令は過去のHSP命令との互換を取るために用意されています。
      通常は、sdim命令を使用することを推奨します。

      ※この命令は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dim</Name>
    <Title>配列変数を作成</Title>
    <Format>
      p1,p2...
      p1=変数 : 配列を割り当てる変数名
      p2=0〜  : 要素の最大
    </Format>
    <Setting>
      任意の要素を持つ配列変数を作成します。

      例：
      dim a,20

      上の例では、変数aの要素を２０個、つまり「a(0)」〜「a(19)」までをあらかじめ確保します。

      パラメータを増やすことで多次元配列を作成することも可能です。

      例：
      dim a,10,5	: 変数aは２次元配列
      a(0,0)=1	: 要素(0,0)に1を代入
      a(1,0)=2	: 要素(1,0)に2を代入
      a(0,1)=3	: 要素(0,1)に3を代入

      上の例では、a(0,0)から、a(9,4)までを使用できるようになります。
      多次元配列は、４次元まで確保することが可能です。

      dim命令はスクリプト内のどこででも定義・再定義することが可能です。
      また、配列変数を作成すると内容はすべて0にクリアされます。
    </Setting>
  </command>
  <command>
    <Name>dimtype</Name>
    <Title>指定タイプの配列変数を作成</Title>
    <Format>
      p1,p2,p3...
      p1=変数     : 配列を割り当てる変数名
      p2=型タイプ : 変数の型タイプ
      p3=0〜      : 要素の最大
    </Format>
    <Setting>
      任意の要素を持つ配列変数を作成します。
      dim命令と同様の動作ですが、dimtypeは変数の型を指定することができます。
      p2には、変数型を示す型タイプ値を指定する必要があります。
      型タイプ値は、vartype関数で型名文字列から取得することが可能です。

      例 ：
      dimtype a,vartype("double"),20

      上の例では、実数型変数aの要素を２０個、つまり「a(0)」〜「a(19)」までをあらかじめ確保します。
      dim命令と同様に多次元配列を確保することが可能です。
      多次元配列は、４次元まで確保することが可能です。
    </Setting>
  </command>
  <command>
    <Name>poke</Name>
    <Title>バッファに1byte書き込み</Title>
    <Format>
      p1,p2,p3
      p1=変数 : バッファを割り当てた変数名
      p2=0〜  : バッファのインデックス(Byte単位)
      p3(0)   : バッファに書き込む値 または 文字列(Byte単位)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある 1バイトの内容を書き換えます。

      p1で指定した変数のバッファ上で、p2で指定したインデックスの場所にp3の値を書き込みます。値は0〜255までの1バイト(8bit)値になります。

      p3に文字列を指定した場合には、文字列データをメモリに展開し、strsizeに、書き込まれた文字列の長さを返します。
    </Setting>
  </command>
  <command>
    <Name>wpoke</Name>
    <Title>バッファに2byte書き込み</Title>
    <Format>
      p1,p2,p3
      p1=変数   : バッファを割り当てた変数名
      p2=0〜    : バッファのインデックス(Byte単位)
      p3=0〜(0) : バッファに書き込む値(16bit整数値)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある 2バイトの内容を書き換えます。

      p1で指定した変数のバッファ上で、p2で指定したインデックスの場所にp3の値を書き込みます。値は0〜65535までの2バイト(16bit)値になります。
    </Setting>
  </command>
  <command>
    <Name>lpoke</Name>
    <Title>バッファに4byte書き込み</Title>
    <Format>
      p1,p2,p3
      p1=変数   : バッファを割り当てた変数名
      p2=0〜    : バッファのインデックス(Byte単位)
      p3=0〜(0) : バッファに書き込む値(32bit整数値)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある 4バイトの内容を書き換えます。

      p1で指定した変数のバッファ上で、p2で指定したインデックスの場所にp3の値を書き込みます。値は0〜$ffffffffまでの4バイト(32bit)値になります。
    </Setting>
  </command>
  <command>
    <Name>sdim</Name>
    <Title>文字列型配列変数を作成</Title>
    <Format>
      p1,p2,p3...
      p1=変数 : 配列を割り当てる変数名
      p2=1〜  : デフォルト文字数
      p3=0〜  : 要素の最大
    </Format>
    <Setting>
      文字列型の配列変数を作成します。
      dim命令との違いは、  p2のパラメータは「文字列のデフォルト文字数」、p3のパラメータ以降に実際の配列要素の最大数を入れるところです。

      例 ：
      sdim a,5000 ; 変数aは5000文字ぶんのメモリをあらかじめ確保します

      上の例では、変数aは5000文字ぶんのメモリを確保し配列変数にはなりません。
      デフォルト文字数は、あらかじめ確保しておくメモリを指定することで、自動拡張時に余計な処理がかからなくなるというものです。
      デフォルト文字数が少ない場合には、長い文字列が代入されるたびに何度も文字列バッファの再確保が発生するため効率が落ちることがあります。

      多次元配列の場合は、文字数とは別に４次元まで確保することが可能です。
      sdim命令はスクリプト内のどこででも定義・再定義することが可能です。
      また、配列変数を作成すると内容はすべて0にクリアされます。
    </Setting>
  </command>
  <command>
    <Name>ddim</Name>
    <Title>実数型配列変数を作成</Title>
    <Format>
      p1,p2...
      p1=変数 : 配列を割り当てる変数名
      p2=0〜  : 要素の最大
    </Format>
    <Setting>
      実数型の配列変数を作成します。
      パラメーターは、dim命令と同様に要素の最大数を指定します。

      例 ：
      ddim a,100 ; 変数aはa(0)〜a(99)までの実数型配列を確保します

      dim命令と同様に多次元配列を確保することが可能です。
      多次元配列は、４次元まで確保することが可能です。
      ddim命令はスクリプト内のどこででも定義・再定義することが可能です。
      また、配列変数を作成すると内容はすべて0にクリアされます。

      ※この命令は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>memcpy</Name>
    <Title>メモリブロックのコピー</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1 : コピー先の変数
      p2 : コピー元の変数
      p3 : コピーするサイズ(1byte単位)
      p4 : コピー先の変数メモリオフセット(省略時=0)
      p5 : コピー元の変数メモリオフセット(省略時=0)
    </Format>
    <Setting>
      p1で指定された変数に割り当てられているメモリ領域に、
      p2で指定された変数に割り当てられているメモリの内容をコピーします。
      コピーするサイズ(1byte単位)は、p3で指定します。
      大きな領域を変数に割り当てている場合などに高速なメモリコピーを行なうことができます。
      p4,p5で、コピー先、コピー元の開始位置を1byte単位で調整することができます。
      変数が確保している領域を越える指定がされている場合は、バッファオーバーフローのエラーになります。
    </Setting>
  </command>
  <command>
    <Name>memset</Name>
    <Title>メモリブロックのクリア</Title>
    <Format>
      p1,p2,p3,p4
      p1=変数      : 書き込み先の変数
      p2=0〜255(0) : クリアする値(1byte)
      p3=0〜(0)    : クリアするサイズ(1byte単位)
      p4=0〜(0)    : 書き込み先の変数メモリオフセット
    </Format>
    <Setting>
      1byteの固定値でメモリブロックを埋めます。
      p1で指定された変数に割り当てられているメモリ領域に、p2で指定された値を、p3のサイズだけ書き込みます。大きな領域に同じ値を書き込みたい時に有効です。p4で、メモリ開始位置を1byte単位で調整することができます。
      変数が確保している領域を越える指定がされている場合は、バッファオーバーフローのエラーになります。
    </Setting>
  </command>
  <command>
    <Name>dup</Name>
    <Title>クローン変数を作成</Title>
    <Format>
      変数名1 , 変数名2
      変数名1 : クローンを作成する変数名
      変数名2 : クローン元の変数名
    </Format>
    <Setting>
      クローン元の変数が持つメモリを指している変数を作成します。
      クローン変数は、クローン元のメモリ情報を参照するための変数として機能するようになります。

      クローン元の型が変更されたり、配列の拡張、または文字列バッファの拡張が行なわれた場合には、クローンとしての動作は行なわれなくなります。
      クローンが有効なのはクローン元の変数に代入が行なわれるまでの間だという点に注意してください。
      dup命令は、以前のバージョンとの互換性維持と、 低レベルでの変数バッファ操作を行なうための機能として残されています。
      また、メモリアドレスから直接クローン変数を作成するdupptr命令も用意されています。
      初心者向けに、dup命令を推奨することはありません。
    </Setting>
  </command>
  <command>
    <Name>dupptr</Name>
    <Title>ポインタからクローン変数を作成</Title>
    <Format>
      変数名,p1,p2,p3
      変数名    : クローンを作成する変数名
      p1=0〜    : クローン元のメモリアドレス
      p2=0〜    : クローン元のメモリサイズ
      p3=1〜(4) : クローン変数の型指定
    </Format>
    <Setting>
      指定したアドレスポインタを指している変数を作成します。
      クローン変数は、メモリ上の情報を参照するための数値型配列変数として機能するようになります。

      p3で作成されるクローン変数の型を指定することができます。
      p3の値は、vartype関数で取得される型を示す値と同じです。 p3を省略した場合は、4(整数型)となります。

      クローン変数は、指し示しているメモリの位置が変更されてもそれを検知することはできません。
      たとえば、変数に格納されているデータのメモリアドレスを指し示していたとしても、変数の型や内容が更新されてメモリ位置が変更された場合に正しく参照することはできません。
      あくまでも、一時的なメモリ参照にのみ使用し、取り扱いには十分に注意してください。dupptr命令は、 DLL等の外部関数で取り交わすメモリ参照や低レベルでの変数バッファ操作を行なうための機能として用意されています。
      初心者向けに、dupptr命令を推奨することはありません。
    </Setting>
  </command>
  <command>
    <Name>mref</Name>
    <Title>特殊なメモリを変数に割り当てる</Title>
    <Format>
      p1,p2
      p1=変数名 : 割り当てられる変数名
      p2=0〜(0) : リソースID (割り当てるメモリ内容)
    </Format>
    <Setting>
      p1で指定された変数に、p2で指定したメモリ内容を割り当てます。

      値  : 対応するリソース
      --------------------------------------------------
      0〜 7 : ローカルパラメータ#1〜8(数値)
      64   : システム変数stat
      65   : システム変数refstr
      66   : ウィンドウ内画像データ(VRAM)
      67   : 現在のウィンドウ情報(BMSCR構造体)
      68   : HSPのシステム情報(HSPCTX構造体)
      69   : パレット情報
      96〜 : ウィンドウID0〜の情報(BMSCR構造体)

      リソースID64,65のシステム変数は、たとえば「mref i,64」とした場合、変数aがシステム変数 statと同等になり、値を代入することができるようになります。これにより、ユーザー定義命令内の計算結果などをシステム変数に反映して、呼び出し元に返すことができます。

      リソース66のウインドウ内画像データ(VRAMデータ)は、表示されている画像を内容とする配列変数になります。
      これにより、 poke,peek命令などで画像データに直接アクセスが可能になります。

      リソース67以降も同様に HSPの内部データに直接アクセスできるようにするものですが、通常は使う必要はありません。 DLLへ渡すためのパラメータ準備のためなど、ごく限られた用途のために用意されているもので、ほとんどの人は使うことはないはずです。

      ローカルパラメータは、ユーザー定義命令(#deffunc)で新規に追加された命令のパラメータ内容を取得するためのものです。
      パラメータのタイプ(数値、変数、文字列)に従って取得することが可能です。
      ローカルパラメータ取得は、HSP2.xまでのパラメーター取得方法との互換のために用意されています。(一部のリソースタイプには互換性がありません。)
      HSP3.0以降では、ユーザー定義命令(#deffunc)のエイリアス機能を使用することを推奨しています。
    </Setting>
  </command>
  <command>
    <Name>newmod</Name>
    <Title>モジュール型変数の作成</Title>
    <Format>
      p1,p2,p3...
      p1    : 変数名
      p2    : モジュール名
      p3... : 初期化パラメーター
    </Format>
    <Setting>
      p1で指定した変数をモジュール型として要素の追加を行ないます。
      p1の変数がモジュール型でない場合は、モジュール型として初期化されます。
      すでにモジュール型の場合は、配列変数として新しい要素を追加していきます。
      p2ですでに登録されているモジュール名を指定し、p3以降に初期化パラメーターを指定することができます。
      モジュール変数は、複数の変数やデータをまとめて管理することができる新しいデータ格納方法を提供します。

      例 :
      #module a x,y,z

      上の例では、aというモジュールにx,y,zという３つの変数を持たせています。
      aというモジュールの型を持つ変数は、x,y,zという変数すべてを内包したものになり、モジュール処理命令(#modfunc)で扱うことが可能になります。

      例 :
      newmod v,a

      上の例では、モジュール「a」のための変数vを初期化します。
      これで変数vには、モジュール「a」 が持つモジュール変数x,y,zという内容が丸ごと格納されることになります。
      モジュールごとに初期化のための命令(#modinit)を用意している場合は、p3以降のパラメーターが初期化命令に渡されます。

      例 :
      #module a x,y,z
      #modinit int p1,int p2,int p3
      x=p1:y=p2:z=p3
      return
      #global
      newmod v,a,1,2,3

      モジュール型の変数は、newmod、delmod命令で要素の操作を行なうことができるほか、 foreach命令などとともに複雑なデータを簡潔に処理することができるようになります。
    </Setting>
  </command>
  <command>
    <Name>delmod</Name>
    <Title>モジュール型変数の要素削除</Title>
    <Format>
      p1
      p1 : 変数名
    </Format>
    <Setting>
      p1で指定したモジュール型の変数の要素を削除します。
      p1は、すでにモジュール型として設定されている変数である必要があります。

      例 :
      delmod v.1

      delmod命令は、#modterm命令により解放ルーチン(デストラクタ)が定義されている場合は、自動的に呼び出しを行ないます。
      モジュール型の変数についての詳細は、newmod命令のヘルプやプログラミングマニュアル(hspprog.htm)を参照してください。
    </Setting>
  </command>
  <command>
    <Name>memexpand</Name>
    <Title>メモリブロックの再確保</Title>
    <Format>
      p1,p2
      p1 = 変数    : 対象となる変数
      p2 = 0〜(64) : 再確保サイズ(1byte単位)
    </Format>
    <Setting>
      p1で指定された変数が持つメモリ領域の再確保を行ないます。
      代入時などのメモリ領域確保はシステムが自動的に行なっていますが、明示的にサイズを変更する場合に使用します。
      再確保を行なった場合でも、以前までの内容は保持されます。
      p2で、再確保サイズを指定します。p2の値が64より小さい場合は自動的に64に合わせられます。すでに確保されているサイズよりも小さな値を指定した場合は何も行われません。
      p1で指定される変数は、 文字列型(str)のように動的にメモリ確保量を変更することが可能な型である必要があります。
      再確保ができない型の場合には、エラーになります。
    </Setting>
  </command>
  <command>
    <Name>ldim</Name>
    <Title>ラベル型配列変数を作成</Title>
    <Format>
      p1,p2...
      p1=変数 : 配列を割り当てる変数名
      p2=0〜  : 要素の最大
    </Format>
    <Setting>
      ラベル型の配列変数を作成します。
      パラメーターは、dim命令と同様に要素の最大数を指定します。

      例 ：
      ldim a,100 ; 変数aはa(0)〜a(99)までのラベル型配列を確保します

      dim命令と同様に多次元配列を確保することが可能です。
      多次元配列は、４次元まで確保することが可能です。
      ldim命令はスクリプト内のどこででも定義・再定義することが可能です。
      また、配列変数を作成すると内容はすべて「未定義」の状態にクリアされます。

      ※この命令は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>newlab</Name>
    <Title>ラベル型変数を初期化</Title>
    <Format>
      p1,p2
      p1=変数    : 初期化する変数名
      p2=参照元  : 参照されるラベルまたはオプション
    </Format>
    <Setting>
      指定されたラベルが代入されたラベル型の変数を初期化します。
      p1で、初期化される変数名を指定します。
      p2で、変数に保存されるラベルの参照元を指定します。
      p2にラベルを指定した場合は、ラベルが示す場所を参照元とします。
      この場合は、「変数=*ラベル名」と記述した場合と変わらない動作となります。
      p2に数値を指定した場合は、以下の動作を行ないます。

      値  : 参照されるラベル
      --------------------------------------------------
      0    次に実行されるプログラム位置を参照する
      1    次の1ステートをスキップした後に実行されるプログラム位置を参照する

      p2が1の場合は、newlab命令の後にreturn命令が存在することを前提としています。
      「newlab命令、return命令の次にあたる位置」が参照されることになります。
      newlab命令は、ラベル型変数を特殊な値により初期化するためのものです。
      単純なラベルの保存であれば、通常の代入文を使用する形で構いません。
    </Setting>
  </command>
  <command>
    <Name>mci</Name>
    <Title>MCIにコマンドを送る</Title>
    <Format>
      "strings"
      "strings" : MCIコマンド文字列
    </Format>
    <Setting>
      MCI（Multimedia Control Interface）にコマンド文字列を送ります。MCIに対応したMIDI再生、ムービー再生などを行なうことができます。

      MCIコマンドの詳細については、Windows MCIの解説書をお読みください。ここでは簡単な使用法だけを紹介しておきます。

      mci "play filename"

      で、"filename"のファイルを再生します。たとえば、"play aaaa.mid"ならば、"aaaa.mid" というMIDIファイルを演奏します。拡張子がaviなら動画の再生、wavならPCMの再生、その他MCIに登録されているデバイスを再生することができます。

      mci "open filename alias abc"

      で、"filename"のファイルをオープンして、これ以降 "abc"という名前をエイリアスにすることができます。この後で、

      mci "play abc"    ; デバイスの再生
      mci "stop abc"    ; デバイスの再生ストップ
      mci "close abc"   ; デバイスのクローズ

      などの指定をすることができるようになります。
      mciに命令を送った場合の結果はシステム変数 statに反映されます。
      stat が-1の場合は、mci命令を解釈する時点でエラーが出ていることを示しています。また、mciでステータスを読み出すコマンドを送った場合も、stat に結果が反映されます。
    </Setting>
  </command>
  <command>
    <Name>mmplay</Name>
    <Title>サウンド再生</Title>
    <Format>
      p1
      p1=0〜(0) : 再生するバッファの番号
    </Format>
    <Setting>
      mmload命令によって読み込まれたメディアを再生します。
      p1でバッファの番号を指定することで、mmload命令によって読み込まれた複数のメディアから、どれを再生するかを選びます。

      mmplay命令は、 通常サウンドの再生がスタートするとともにHSPは次の命令へと進みます。
      ただし、mmload命令で読み込みモード２を指定している場合は、サウンドの再生が終了するまで次の命令へは進まなくなります。

      すでにサウンドが再生されている状態で、さらにmmplay命令を実行すると、前のサウンド再生を終了してから、新しく指定したサウンドの再生を始めます。
      ただし、MIDIの再生中にPCMを再生するなど異なるデバイスの場合は、 再生が中止されることはありません。

      AVI(動画)の再生は、 mmplay命令が実行された時点で操作先となっているウインドゥのカレントポジションを左上として表示されます。
      ただし、 mmload命令のモードに+16(ウィンドウ全体で再生)が指定されている場合は、ウィンドウの表示面いっぱいに再生されます。
      この場合、画面サイズや縦横の比率には関係なくウィンドウのサイズに変倍されるので、あらかじめ動画の画面サイズや縦横比を考えた上で利用して下さい。
    </Setting>
  </command>
  <command>
    <Name>mmload</Name>
    <Title>サウンドファイル読み込み</Title>
    <Format>
      "filename",p1,p2
      p1=0〜(0)  : 割り当てるバッファの番号
      p2=0〜2(0) : 割り当てるモード
    </Format>
    <Setting>
      メディアデータのファイルを登録します。
      読み込むことができる形式は以下の通りです。

      WAV形式  : 拡張子 WAV         : Windows標準のPCM音声データ。
      AVI形式  : 拡張子 AVI         : Windows標準の動画データ
      MID形式  : 拡張子 MID         : 標準MIDIファイルデータ。
      MP3形式  : 拡張子 MP3         : MP3形式音声データ
      ASF形式  : 拡張子 ASF,WMV,WMA : Windows Media形式音声データ
      MPEG形式 : 拡張子 MPG         : MPEG形式動画データ
      オーディオCD : ファイル名 "CD : トラック番号" :
      (CDの音声トラック部分が対象になります)

      たとえば、オーディオCDのトラック3を指定する場合は、

      mmload "CD:3",1

      のようにします。
      p1は、割り当てるバッファの番号となります。これは、再生する時に必要となる0以上の整数値です。
      複数のメディアファイルを取り扱うには、別々のバッファ番号に割り当てをしておく必要があります。
      mmload命令は、指定されたファイルが2MB以下の音声(WAV)ファイルの場合は、メモリに内容を読み込んでおきリアルタイムに再生可能な状態にします。それ以外の場合は、ファイル名だけが登録され、実際のファイルの読み出しはメディア再生時(mmplay実行時)に行なわれることになります。

      p2はモードを設定します。以下の値を指定することができます。

      モード0   : 指定したファイルは通常の再生を行う
      モード1   : 指定したファイルは無限ループで再生を行う
      モード2   : 指定したファイルは再生終了まで待つ
      モード3   : (CDのみ)指定されたトラック以降を再生する
      モード+16 : (AVIのみ)対象ウィンドウ全体で再生

      モード２を指定すると、指定したファイルが再生された場合、 HSPはその再生が終了するまで次の命令を実行しなくなります。
      mmload命令はデータの情報をメモリ上にストックしておくだけで、すぐに演奏が始まるわけではありません。

      モード+16は、AVI(動画)ファイルでのみ使用できるモードです。
      モード0〜2に16を足した値を指定することで、表示対象になっているウインドゥのサイズいっぱいに動画が再生されます。
      動画ファイルの判断は拡張子によって行なっています。

      MP3形式、およびASF形式はOSがサポートしている場合にのみ再生が可能です。
      (初期のWindows95、Windows98ではWindows Media Player  5.2以降がインストールされている必要があります。)

      実際の再生は、mmplay命令によって行ないます。
    </Setting>
  </command>
  <command>
    <Name>mmstop</Name>
    <Title>サウンド停止</Title>
    <Format></Format>
    <Setting>mmplay命令によるメディア再生を停止します。</Setting>
  </command>
  <command>
    <Name>button</Name>
    <Title>ボタン表示</Title>
    <Format>
      goto/gosub "name",*label
      "name" : ボタンの名前
      *label : 押した時にジャンプするラベル名
    </Format>
    <Setting>
      カレントポジションにオブジェクトとして押しボタンを配置します。
      ボタンには、"name"で指定された文字列が書かれ、マウスでボタンをクリックすると、*labelで指定した場所にプログラムの制御が移ります。

      button gotoと記述した場合は、ラベルにジャンプ。button  gosubと記述した場合は、 ラベルにサブルーチンジャンプを行ないます。goto、gosubキーワードを省略した場合には、gotoと同じ動作になります。

      例 :
      button gosub "ボタン",*aaa  ; *aaaを呼び出すボタンを作成


      オブジェクトの大きさはobjsize命令で指定することができます。 ボタンを配置すると、カレントポジションは次の行に自動的に移動します。

      ボタンが押された時にジャンプして実行されるプログラムでは、システム変数statの初期値としてオブジェクトIDが代入されます。

      通常は、ボタンの形状としてWindowsシステムで用意されたものが使用されます。
      ただし、objimage命令によって画像を使用したカスタムボタンの設定が行なわれている場合は、自由な外観にすることができます。
      カスタムボタンの設定については、objimage命令の項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>chkbox</Name>
    <Title>チェックボックス表示</Title>
    <Format>
      "strings",p1
      "strings" : チェックボックスの内容表示文字列
      p1=変数   : チェックボックスの状態を保持する変数
    </Format>
    <Setting>
      カレントポジションにオブジェクトとしてチェックボックスを配置します。
      チェックボックスには、"strings"で指定した文字列の左側に、カーソルでON/OFFを切り替えることのできるスイッチがついたオブジェクトです。

      チェックボックスの大きさは、 objsizeで指定されたサイズになり背景はグレーです。

      p1で指定された数値型変数の内容が0ならばチェックはOFFになり、 1ならばONになります。チェックのON/OFFが変更されると、変数の内容も同時に変化します。
    </Setting>
  </command>
  <command>
    <Name>clrobj</Name>
    <Title>オブジェクトをクリア</Title>
    <Format>
      p1,p2
      p1=0〜(0)  : 消去するオブジェクトID(開始)
      p2=0〜(-1) : 消去するオブジェクトID(終了)( -1の場合は、 最終のIDが指定
      されます )
    </Format>
    <Setting>
      button命令やmesbox命令などで出したオブジェクトを消去します。

      p1,p2を省略して、 clrobjだけを実行させると画面上のオブジェクトがすべて消去されます。一部のオブジェクトだけを消去したい場合は、p1に最初のID、p2に最後のIDを指定すればp1〜p2までのオブジェクトだけが消去されます。指定するオブジェクトIDは、 objprm命令などで指定するIDと同じものです。

      削除されたオブジェクトのIDは、新しくオブジェクトを配置する際には再利用されます。
    </Setting>
  </command>
  <command>
    <Name>combox</Name>
    <Title>コンボボックス表示</Title>
    <Format>
      p1,p2,p3
      p1=変数      : コンボボックスの状態を保持する数値型変数
      p2=0〜(100)  : 拡張Yサイズ
      p3="strings" : コンボボックスの内容を示す文字列
    </Format>
    <Setting>
      カレントポジションにオブジェクトとして、コンボボックスを配置します。
      コンボボックスは、複数の文字列要素の中から１つを選択させることのできる入力オブジェクトです。
      オブジェクトの大きさは、objsize命令で設定した大きさになります。ただし、p2パラメータで選択時のリスト表示のためのYサイズを指定しなければなりません。 (通常は100〜150程度が適当です)

      「¥n」で区切った文字列をp3で指定することで、選択する要素を設定することができます。
      たとえば、「APPLE¥nORANGE¥nGRAPE」という文字列を指定すると、 「APPLE」「ORANGE」「GRAPE」の中から１つを選択するコンボボックスになります。
      それぞれの要素には、0から順番にインデックス番号がついています。 前の例では、「APPLE」はインデックス0、「ORANGE」はインデックス1、「GRAPE」はインデックス2というふうに番号がついていきます。

      この「¥n」で区切るというデータ形式は、メモリノートパッド命令で扱う複数行テキストデータと同じです。メモリノートパッド命令で作成したデータをそのままcombox命令にも使用できます。

      ユーザーが選択をすると、p1で指定した数値型変数にインデックス番号が代入されます。
      最初にコンボボックスが配置される際には、p1で設定した変数が示すインデックスが選ばれた状態になります。 (インデックス番号が-1の時は非選択の状態になります)
    </Setting>
  </command>
  <command>
    <Name>input</Name>
    <Title>入力ボックス表示</Title>
    <Format>
      p1,p2,p3,p4
      p1=変数 : 入力のための変数
      p2,p3   : メッセージボックスのサイズ（ドット単位）
      p4=0〜  : 入力できる最大文字数
    </Format>
    <Setting>
      カレントポジションにオブジェクトとして入力ボックスを配置します。 p2,p3で大きさを指定して、場所はカレントポジションからになります。 p2,p3が省略された場合は、objsizeで指定されたサイズになります。

      入力ボックスは、キーボードから直接入力することのできる小さな窓です。マウスで入力ボックスをクリックしてカーソルを出した状態で、キーボードからパラメータを入力することができるようになります。
      入力した値は、p1で指定した変数に代入されます。もし、p1の変数が文字列型だった場合には入力した文字列が、数値型だった場合には入力した値がそのまま変数に反映されます。

      入力ボックスは初期状態では、p1で指定した変数に代入されていた値が、ボックス内に表示されます。

      p4で、入力できる最大文字数を指定することができます。p4が省略された場合には、p1で指定された変数に格納できる最大文字数が自動的に割り当てられます。(変数が文字列型以外だった場合はデフォルトで32文字までとなります。)
      p4を0に指定した場合は、そのバージョンのWindowsで扱える最大文字数が入力可能になります。

      入力ボックスを配置すると、カレントポジションは次の行に自動的に移動します。
    </Setting>
  </command>
  <command>
    <Name>listbox</Name>
    <Title>リストボックス表示</Title>
    <Format>
      p1,p2,p3
      p1=変数      : リストボックスの状態を保持する数値型変数
      p2=0〜(100)  : 拡張Yサイズ
      p3="strings" : リストボックスの内容を示す文字列
    </Format>
    <Setting>
      カレントポジションにオブジェクトとして、リストボックスを配置します。
      リストボックスは、複数の文字列要素の中から１つを選択させることのできる入力オブジェクトです。
      オブジェクトの大きさは、objsize命令で設定した大きさになります。ただし、p2パラメータで選択時のリスト表示のためのYサイズを指定しなければなりません。 (通常は100〜150程度が適当です)

      「¥n」で区切った文字列をp3で指定することで、選択する要素を設定することができます。
      たとえば、「APPLE¥nORANGE¥nGRAPE」という文字列を指定すると、 「APPLE」「ORANGE」「GRAPE」の中から１つを選択するリストボックスになります。
      それぞれの要素には、0から順番にインデックス番号がついています。 前の例では、「APPLE」はインデックス0、「ORANGE」はインデックス1、「GRAPE」はインデックス2というふうに番号がついていきます。

      この「¥n」で区切るというデータ形式は、メモリノートパッド命令で扱う複数行テキストデータと同じです。メモリノートパッド命令で作成したデータをそのままlistbox命令にも使用できます。

      ユーザーが選択をすると、p1で指定した数値型変数にインデックス番号が代入されます。
      最初にリストボックスが配置される際には、p1で設定した変数が示すインデックスが選ばれた状態になります。 (インデックス番号が-1の時は非選択の状態になります)
    </Setting>
  </command>
  <command>
    <Name>mesbox</Name>
    <Title>メッセージボックス表示</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=変数    : 表示メッセージが代入された文字列型変数
      p2,p3      : メッセージボックスのサイズ（ドット単位）
      p4=0〜(1)  : メッセージボックスのスタイル
      p5=0〜(-1) : 入力できる最大文字数
    </Format>
    <Setting>
      ウィンドウ上にオブジェクトとして、 メッセージボックス(メッセージ表示用の窓)を配置します。p2,p3で大きさを指定して、場所はカレントポジションからになります。
      メッセージボックスのスタイルに設定する値(p4)は、以下の通りになります。

      値 : 対応するキー
      ---------------------------------------------------------------
      0 : スクロール可能なエディットボックス(書き換え不可)
      1 : スクロール可能なエディットボックス(書き換え可能)
      4 : 横スクロールバー付きエディットボックス(書き換え不可)
      5 : 横スクロールバー付きエディットボックス(書き換え可能)

      書き換え可能なエディットボックスを作成すると、ユーザーが好きに文字を入力できる簡単なテキストエディタになります。

      p5で、入力できる最大文字数を指定することができます。
      p5が0の場合は、そのバージョンのWindowsで扱える最大文字数になります。
      p5が省略されるかマイナス値の場合には、p1で指定された変数に格納できる最大文字数が自動的に割り当てられます。
    </Setting>
  </command>
  <command>
    <Name>objprm</Name>
    <Title>オブジェクトの内容を変更</Title>
    <Format>
      p1,p2
      p1=0〜(0) : オブジェクトID指定
      p2        : 変更するパラメータの内容
    </Format>
    <Setting>
      button命令やinput,mesbox命令などで画面上に配置したオブジェクトの持つ内容やパラメータを変更します。

      p1には、オブジェクトIDを指定します。オブジェクトIDは、 0から順番に画面上に表示したオブジェクト１つ１つに割り当てられていく番号です。
      オブジェクトIDは、オブジェクトを配置する命令実行後にシステム変数statに代入されています(通常置いた順番に0,1,2…の番号が割り当てられます)。

      ここで指定されたオブジェクトをp2で指定したパラメータで変更します。
      p2で指定するパラメータはオブジェクトの種類によって異なります。オブジェクトによって、文字列を指定するものや、数値を指定するものが分かれています。詳細は下の表を参照してください。

      オブジェクト      : p2の指定
      ----------------------------------------------------------
      ボタン               : ボタン文字列の変更(文字列)
      入力ボックス(数値)   : 入力内容の変更(数値)
      入力ボックス(文字列) : 入力内容の変更(文字列)
      チェックボックス     : チェックのON/OFF(数値)
      コンボボックス       : コンボボックスの内容変更(文字列)
      リストボックス       : リストボックスの内容変更(文字列)

      たとえば、チェックボックスを示すIDを指定してから、p2のパラメータに1を指定すると、チェックボックスを強制的にONの状態に変更します。この場合、チェックボックスの内容を保持する変数の値も自動的に書き換えられます。

      入力ボックスの内容を変更した場合には、自動的に入力ボックスに入力フォーカスが設定され、ボックス内にカーソルが表示されます。
    </Setting>
  </command>
  <command>
    <Name>objsize</Name>
    <Title>オブジェクトサイズ設定</Title>
    <Format>
      p1,p2,p3
      p1=0〜(64)  : オブジェクトのX方向のサイズ（ドット単位）
      p2=0〜(24)  : オブジェクトのY方向のサイズ（ドット単位）
      p3=0〜(0)   : Y方向の最低確保行サイズ (ドット単位)
    </Format>
    <Setting>
      ボタンや入力ボックスなどを配置する時のオブジェクトの大きさを設定します。

      p3でボタンやメッセージが置かれた後にカレントポジションが移動する最低量を指定することができます。これにより、ボタンとメッセージを連続して置いた時に同じ大きさでスペースが空くようになります。

      画面がクリアされると、オブジェクトサイズは自動的にデフォルトに戻ります。
    </Setting>
  </command>
  <command>
    <Name>objsel</Name>
    <Title>オブジェクトに入力フォーカスを設定</Title>
    <Format>
      p1
      p1=0〜(0) : オブジェクトID指定
    </Format>
    <Setting>
      p1で指定したオブジェクトIDに入力フォーカスを合わせます。
      入力フォーカスを合わせることにより、 mesbox命令やinput命令で配置した入力ボックスの中に入力カーソル(キャレット)を出すことができます。
      この命令は、複数の入力ボックスで任意の場所に入力フォーカスを合わせたい場合や、次の入力ボックスにキー入力などで移動するような処理を行なうためのものです。
      また、p1に-1を指定した場合は、現在、入力フォーカスが合っているオブジェクトIDをシステム変数statに代入します。
    </Setting>
  </command>
  <command>
    <Name>objmode</Name>
    <Title>オブジェクトモード設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : オブジェクトフォント設定モード指定
      p2=0〜1   : フォーカス移動キー指定(0=OFF/1=ON)
    </Format>
    <Setting>
      button,input,mesbox などのオブジェクト制御命令で使用されるスタイル等を設定するための命令です。
      p1でフォント設定及び、スタイルに関するモードを指定することができます。
      これにより、以降のオブジェクト配置命令実行時のスタイル設定が変わります。
      モードの値と内容は以下の通りです。

      p1 : モード
      ------------------------------------------------------------
      0 : HSP標準フォントを使用
      1 : デフォルトGUIフォントを使用
      2 : font命令で選択されているフォントを使用

      ウィンドウが初期化された直後は、モード1に設定されています。

      モード2に変更した場合は、 font命令で指定したフォントが使われるようになります。これは、オブジェクト制御命令が実行される時点で、設定されているフォントが使用されます。 objmode命令が実行された時点のフォントではないので注意してください。

      p2で、[TAB]キーによるオブジェクトのフォーカス移動モードの ON/OFFを行ないます。 p2を1に指定した場合は、表示されているオブジェクトの入力フォーカスを[TAB]キーで移動することができます。p2のモード指定を省略した場合は、以前のモードを引き継ぎます。

      p2 : モード
      --------------------------------------------------------------
      0  : [TAB]を無効にする
      1  : [TAB]キーによるオブジェクトのフォーカス移動可能(標準)
    </Setting>
  </command>
  <command>
    <Name>objenable</Name>
    <Title>オブジェクトの有効・無効を設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : オブジェクトID指定
      p2=0〜(1) : 0ならば無効、0以外は有効
    </Format>
    <Setting>
      p1で指定したオブジェクトIDの状態を変更します。
      p2で指定した値が0ならば、オブジェクトは無効化されます。
      無効化されたオブジェクトは、画面上に存在しますが色が変更され、操作することはできなくなります。
      p2で指定した値に0以外を指定すると、通常通りの有効なオブジェクトとなります。
      入力ボックスやボタンなど、すべてのオブジェクトを有効・無効化することができます。
    </Setting>
  </command>
  <command>
    <Name>objskip</Name>
    <Title>オブジェクトのフォーカス移動モードを設定</Title>
    <Format>
      p1,p2
      p1=0〜(0) : オブジェクトID指定
      p2=1〜(2) : フォーカス移動モード
    </Format>
    <Setting>
      p1で指定したオブジェクトIDのフォーカス移動モードを設定します。
      フォーカス移動モードは、[TAB]キーにより配置されたオブジェクトを移動させる場合の挙動をオブジェクトごとに指定するものです。
      p2でモード値を指定します。モード値の詳細は、以下の通りです。

      p2 : フォーカス移動モード
      --------------------------------------------------------------
      1 : [TAB]キーにより次のオブジェクトにフォーカスを移動可能(標準)
      2 : [TAB]キーにより次のオブジェクトにフォーカス移動は不可能
      3 : [TAB]キーによるオブジェクトへのフォーカス移動は行なわない(スキップ)
      +4 : フォーカス移動時にテキストを全選択する(入力ボックスのみ)

      通常は、オブジェクトを配置した段階で最適なモードが設定されているので、フォーカス移動モードを再設定する必要はありません。
      特殊な役割を果たすオブジェクトだけ、フォーカス移動モード変えたり、winobj命令によりシステム定義のオブジェクトを新しく追加した場合に使用してください。
      objmode命令により、フォーカス移動モードの機能がOFFにされている場合は、[TAB]キーによるフォーカス移動は行なわれませんので注意してください。
    </Setting>
  </command>
  <command>
    <Name>objimage</Name>
    <Title>カスタムボタンの設定</Title>
    <Format>
      id,x1,y1,x2,y2,x3,y3
      id    : カスタムボタンの参照バッファID
      x1,y1 : カスタムボタンの参照座標1(通常時)
      x2,y2 : カスタムボタンの参照座標2(押し下げ時)
      x3,y3 : カスタムボタンの参照座標3(マウスオーバー時)
    </Format>
    <Setting>
      カスタムボタンを配置するための設定を行ないます。
      カスタムボタンは、button命令で作成される押しボタンのオブジェクト外観を任意の画像に置き換えることができます。
      カスタムボタンを作成するためには、あらかじめボタンとして表示するための画像を用意しなければなりません。

      idパラメーターで、カスタムボタンの画像が格納されている画面バッファIDを指定します。
      idパラメーターを省略するか、または-1を指定するとカスタムボタンの設定は無効となり、通常のWindowsシステムが用意するボタンが使用されます。
      (x1,y1)に、通常のボタンとして表示する画像の左上座標を指定します。(パラメーター省略時は、(0,0)が指定されます)
      (x2,y2)では、ボタンが押された時に、ボタンに表示する画像の左上座標を指定します。(パラメーター省略時は、(0,0)が指定されます)
      (x3,y3)では、マウスがボタン上に乗った(マウスオーバー)時、ボタンに表示する画像の左上座標を指定します。(パラメーター省略時は、x1,y1と同様の値が使用されます)

      objimage命令によってカスタムボタンの設定が行なわれた後は、button命令で配置されるボタンすべてに設定が適用されます。
      カスタムボタンは、指定された画像をボタンが配置されている場所にコピーすることで外観を変更しています。
      コピーされる範囲は、ボタンと同じ(objsize命令で設定された)サイズとなります。
      外観以外の挙動は、通常のボタンと変わりありません。ボタン上の文字表示や、フォーカス移動等も同様にサポートされます。
      カスタムボタンの設定は、画面の初期化時(cls命令やscreen命令実行時)にクリアされます。
    </Setting>
  </command>
  <command>
    <Name>#define</Name>
    <Title>新規マクロを登録する</Title>
    <Format>マクロ名 マクロ定義</Format>
    <Setting>
      マクロ名で指定されたキーワードを指定された定義に置き換えられるようにプリプロセッサに登録をします。
      #defineマクロは、 あくまで個人がスクリプトを書きやすくカスタマイズしたい場合に使うもので、初心者向きではありません。ここで説明した機能も、頻繁に利用するものではありませんので、必要な場合にのみ参照してください。
      #defineマクロは、基本的に置き換え文字列を登録します。

      例 :
      #define hyouji mes
      hyouji "AAAAA..."
      ↓(展開後)
      mes "AAAAA..."

      #define命令の直後に「global」を入れることで、 すべてのモジュールで永続的に利用することのできるマクロを作成することができます。

      例 :
      #module
      #define global test 0x1234
      #global
      a=test   ; aに0x1234が代入される

      通常は、モジュール内で#defineを定義した場合には、それ以外のモジュールおよびグローバルなエリアでは、同じ名前は認識されません。
      global指定を入れることで、それ以降のすべての場所で定義した名前をマクロで置き換えることができるようになります。

      単純な置き換えマクロの他に、引数付きの展開が可能です。
      引数は、マクロ名の後にカッコで囲んだ%1,%2,%3…の引数名で指定を行ないま
      す。
      引数は必ず「%数値」で指定する必要があり、 数値は１から順番に記述してください。CやC++のプリプロセッサのようにシンボル名では指定できないので注意してください。

      例 :
      #define hyouji(%1) mes "prm="+%1
      hyouji "AAAAA..."
      ↓(展開後)
      mes "prm="+"AAAAA..."

      また、引数に初期(デフォルト)値を設定することが可能です。

      例 :
      #define hyouji(%1="PRM=",%2=123) mes %1+%2
      hyouji "AAA",a
      hyouji "BBB"
      hyouji ,b
      ↓(展開後)
      mes "AAA"+a
      mes "BBB"+123
      mes "PRM="+b

      初期(デフォルト)値は、マクロを使用した時に省略された場合に自動的に補完される値です。初期値を省略された場合は、補完されません。
      マクロ引数の指定では#defineで指定する側では、カッコで囲んでいますが、実際に使用する時にはカッコなしで指定してください。

      #define hyouji(%1) mes "prm="+%1
      hyouji("AAAAA...")

      のような記述はエラーになるので注意してください。
      ただし、 ctypeオプションを使用することで以下のようなカッコ付き記述が可能になります。

      #define ctype kansu(%1) %1*5+1
      a=kansu(5)

      このオプションは、計算式など命令部分以外にマクロを使用したい時に有効です。一見、C言語などの関数のように振舞いますが、 実際にはマクロで置き換えているだけなので、応用範囲は狭いので注意してください。
      この記述方法は、 本来のHSP文法とは異なるため自分のスタイルで記述したいというカスタマイズ用途以外での利用は推奨していません。

      マクロの展開時に特殊な動作を行なうキーワードを設定することが可能です。
      この特殊キーワードは、主にことなるマクロ間でパラメータを共有したり、入れ子構造をスタックによって実現するためのものです。

      #define start(%1) %tstart %s1 mes "START"
      #define owari %tstart mes %o

      ここで指定されている「%s1」や「%o」などが特殊展開マクロです。
      これを使ったサンプルは、以下のように展開されます。

      start "OK" → mes "START"
      owari → mes "OK"

      このように、異なるマクロ間でデータを共有させることが可能になります。
      特殊展開マクロは、以下の種類と機能があります。

      マクロ : 機能
      ----------------------------------------------------------------
      %t   : タグ名を設定する
      %n   : ユニークなラベル名を生成する
      %i   : ユニークなラベル名を生成してスタックに積む
      %o   : スタックに積まれた文字列を取り出す
      %p   : スタックに積まれた文字列を取り出す(スタック維持)
      %s   : 引数パラメーターをスタックに積む
      %c   : 改行を行なう

      特殊展開マクロは、「%」に続けて英文字1文字+パラメータで表現します。
      以降のキーワードと識別するために、特殊展開マクロの後には半角スペースを入れて下さい。「%tabc aaa」 のようスペースを含む部分までが特殊展開マクロと判断されます。
      特殊展開マクロでは、一般的なスタック(First In Last Out)を持っています。
      このスタックは、同じタグ名を持つマクロで共有させることができます。
      タグ名は、「%tタグ名」のように「%t」に続けて半角英文字16字以内で指定します。先の例では「%tstart」と指定された「start」がタグ名にあたります。
      「%s」は、引数パラメーターをスタックに積むための特殊展開マクロです。
      「%s1」と指定すると、「%1」のパラメータをスタックに１段積みます。
      スタックに積まれた文字列を取り出す場合は、「%o」を使用します。
      「%o」は、スタックに積まれた文字列を取り出して展開します。スタックなので、最後に積まれたものが最初に取り出されます。
      「%o0」と指定すると、 スタックを取り出しますが文字列の展開は行ないません(スタック取り出しのみ)。
      スタックを戻さずに内容だけを取り出すのが 「%p」です。「%p0」は、次に取り出されるスタックの内容を展開します。「%p1」は、 もう一段深いスタックを取り出します。以降、「%p0」〜「%p9」までを指定することが可能です。
      ラベル生成の例を以下に示します。

      #define start %tstart *%i
      #define owari %tstart await 20:stick a:if a=0  :  goto
      *%o

      これを使ったサンプルは、以下のように展開されます。

      start → *_start_0000
      owari → await 20:stick a:if a=0 : goto *_start_0000

      「%i」は、他と重ならないようなユニークなラベル名を生成してスタックに１段積みます。「%i0」と指定するとラベル名をスタックに１段積みますが、展開は行ないません。
      また、「%n」は、ユニークなラベル名を生成して展開するだけで、スタックには積みません。
      上の例では、ラベル名生成によってラベルを新しく作成して、 ループ構造を実現しています。 この方法を使えば、入れ子になってもラベル名が重なることのないループ構造を構築することができます。
      また、1つのソーススクリプトファイル内ですべてのスタックが取り出されていなかったマクロ(タグ名)は、コンパイル時にエラーが報告されます。
      かならず、すべてのスタックが取り出されて終わるようなマクロ命令の構成にしておいてください。

      HSP ver2.6で追加された標準定義マクロの while〜wend、 do〜until、 for〜nextは特殊展開マクロによって作られています。

      特殊な場面において、「%c」によって改行を挟んで展開することが可能です。
      「%c」の部分で行が分割されて展開されます。主に複数のプリプロセス文に展開されるようなマクロを定義する用途などに使用することができます。
      ただし、現状ですべてのプリプロセッサがマクロ展開に対応しているわけではありません。多用しすぎると、かえって見難くなることもありますので、よくご理解の上お使いください。

      例 :
      #define def(%1,%2) #deffunc %1@ %c mes@hsp %2@
      def test,a
      return
      def test2,a
      return
    </Setting>
  </command>
  <command>
    <Name>#func</Name>
    <Title>外部DLL呼び出し命令登録</Title>
    <Format>新規名称 "関数名" タイプ名1,…</Format>
    <Setting>
      外部DLLを呼び出すための新しい命令を登録します。
      先に#uselib命令により外部DLL名を指定しておく必要があります。
      新規名称、関数名、タイプをスペースで区切って書きます。
      新規名称の直前に「global」を入れることで、 すべてのモジュールで永続的に利用することのできる命令を作成することができます。

      関数名は、"関数名"のようにダブルクォートで囲むことで、 DLLの完全なエクスポート名を記述することができます。
      ダブルクォートで囲んでいない場合は、「_関数名@16」というVC++のエクスポート規約に基づいた名前に変換されます。

      タイプ名には、引数の詳細を記述します。
      #deffunc命令と同様に、引数の型を「,」で区切って指定してください。
      引数の数や、型の順番に制限はありません。
      引数の型として使用できる文字列は以下の通りです。

      型     :  内  容
      ------------------------------------------------------------------
      int     :  整数値(32bit)
      var     :  変数のデータポインタ(32bit)
      str     :  文字列ポインタ(32bit)
      wstr    :  unicode文字列ポインタ(32bit)
      sptr    :  ポインタ整数値または文字列のポインタ(32bit)
      wptr    :  ポインタ整数値またはunicode文字列のポインタ(32bit)
      double  :  実数値(64bit)
      float   :  実数値(32bit)
      pval    :  PVal構造体のポインタ(32bit)
      comobj  :  COMOBJ型変数のデータポインタ(32bit)
      (*) bmscr   :  BMSCR構造体のポインタ(32bit)
      (*) prefstr :  システム変数refstrのポインタ(32bit)
      (*) pexinfo :  EXINFO構造体のポインタ(32bit)
      (*) nullptr :  ヌルポインタ(32bit)

      (*)がついている項目は、 引数として指定する必要なく自動的に渡されるパラメーターを示しています。
      以下は、４つの引数を指定して実行する例です。

      例 :
      #uselib "test.dll"
      #func test "_func@16" var,int,int,int
      test a,1,2,3    ; test.dllのfunc(&amp;a,1,2,3)が呼び出される

      タイプに数値を指定した場合は、ver2.5以降のDLLタイプ指定と互換性のある引数が自動的に設定されます。ただし、いくつか互換性のない指定値があります。その場合は、コンパイル時にエラーとして報告されます。

      ver2.5とは以下の点で互換性の注意が必要です。

      ・BMSCR構造体は、flagからcolorまでのフィールドのみ参照できます。
      ・PVal構造体は、ver2.5のPVAL2構造体と互換があります。
      ・PVal構造体のflagフィールド(型タイプ値)やlenフィールド(配列情報)をDLL側で書き換えることはできません。
      ・PVal構造体から文字列型の配列変数にアクセスすることはできません。

      これ以外の点においては、HSP ver2.5と同等の情報が受け渡されます。

      関数名の前に「onexit」を入れることにより、終了呼び出し関数として登録することができます。

      例 :
      #func test onexit "_func@16" str,int,int

      上の例では、アプリケーション終了時に自動的に"_func@16"が呼び出されます。
    </Setting>
  </command>
  <command>
    <Name>#cfunc</Name>
    <Title>外部DLL呼び出し関数登録</Title>
    <Format>新規名称 "関数名" タイプ名1,…</Format>
    <Setting>
      外部DLLを呼び出すための新しい関数を登録します。
      先に#uselib命令により外部DLL名を指定しておく必要があります。
      新規名称、関数名、タイプをスペースで区切って書きます。
      新規名称の直前に「global」を入れることで、 すべてのモジュールで永続的に利用することのできる命令を作成することができます。

      関数名は、"関数名"のようにダブルクォートで囲むことで、 DLLの完全なエクスポート名を記述することができます。
      ダブルクォートで囲んでいない場合は、「_関数名@16」というVC++のエクスポート規約に基づいた名前に変換されます。

      タイプ名には、引数の詳細を記述します。
      引数パラメーターは、#func命令と同じものを使用することができます。
      詳しくは、#funcのリファレンスを参照してください。
      #cfunc命令によって登録された新規名称は、関数として式の中に記述することが可能です。

      例 :
      #uselib "test.dll"
      #cfunc test "_func@16" var,int,int,int
      res=test(a,1,2,3)  ; test.dllのfunc(&amp;a,1,2,3)が呼び出される

      登録された関数の戻り値として外部呼出しの結果取得された整数値(32bit int)をそのまま返します。
      HSP2.5互換の呼び出しでは、システム変数statに返される値を関数の戻り値とします。
    </Setting>
  </command>
  <command>
    <Name>#include</Name>
    <Title>別ファイルを結合</Title>
    <Format>
      "filename"
      "filename" : 結合するファイル名
    </Format>
    <Setting>
      インクルードするファイルを指定します。
      ここで指定されたファイルは、もとのファイルに結合してコンパイルされます。
    </Setting>
  </command>
  <command>
    <Name>#addition</Name>
    <Title>別ファイルを結合2</Title>
    <Format>
      "filename"
      "filename" : 結合するファイル名
    </Format>
    <Setting>
      インクルードするファイルを指定します。
      ここで指定されたファイルは、もとのファイルに結合してコンパイルされます。
      #include命令と同じ動作ですが、#additionはファイルが存在しない場合でも、エラーとして停止せずに続行されます。
      追加の定義ファイルなどを結合する場合に使用します。
    </Setting>
  </command>
  <command>
    <Name>#uselib</Name>
    <Title>外部DLLの指定</Title>
    <Format>
      "filename"
      "filename" : 外部DLLファイル名
    </Format>
    <Setting>
      HSPから呼び出す外部DLLのファイル名を指定します。
      DLLのファイル名は、拡張子も含めて完全に書く必要があります。
      ファイル名を省略した場合は、 実行時にスクリプトからDLL名を指定してリンクを行なうことになります。
    </Setting>
  </command>
  <command>
    <Name>#global</Name>
    <Title>モジュールの終了</Title>
    <Format></Format>
    <Setting>
      モジュール区間を終了し、以降を通常のプログラム領域に戻します。
      モジュールについての詳細は、#module命令を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#module</Name>
    <Title>モジュールの開始</Title>
    <Format>
      モジュール名 変数名1,…
      モジュール名 : 新規モジュール名
      変数名       : 登録するモジュール変数名
    </Format>
    <Setting>
      #module以降の区間をモジュールとして別な空間に割り当てます。
      モジュール内の変数やラベルは、モジュール外のものからは独立したものになります。

      "モジュール名"は、複数のモジュールを名前で区分けする時につけることのできる名前で、モジュール名が同じもの同士は、変数名やラベル名を共有します。
      モジュール名が違うものの間では、変数名やラベル名はまったく違うものとして扱われます。

      "モジュール名"を省略した場合は、「m数値」という名前が自動的に割り当てられます。

      モジュールは、必ず「#module」で開始を指示し、「#global」で終了しなければなりません。このようにモジュールの区間を指定することにより、その中を他から独立した空間にすることができます。
      モジュール名は、18文字以内の長さで他の変数名などのキーワードと重複することはできません。
      また、スペースや記号を含まない文字列を指定するようにしてください。 (モジュール名で使用できる文字種は、a〜zまでのアルファベット、0〜9までの数字、「_」記号となります。変数として使用できる文字列と同等です。)

      モジュール変数名は、モジュールに関連付けられたローカルな変数を登録しておくものです。登録されたモジュール変数名は、#modfunc、または#modcfuncで定義された処理ルーチン内で使用することができるようになります。

      モジュール変数についての詳細は、プログラミングマニュアル(hspprog.htm)を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#deffunc</Name>
    <Title>新規命令を登録する</Title>
    <Format>
      p1 p2 p3,…
      p1      : 割り当てられる命令の名前
      p2 p3〜 : パラメータータイプ名・エイリアス名
    </Format>
    <Setting>
      ユーザーによる新規命令を登録します。
      p1に新規命令の名前を、p2以降に呼び出しパラメータタイプを指定します。
      #deffunc命令で定義した名前をスクリプト内で命令として使用することが可能になります。

      新規命令は、#deffuncで指定された行以降が実行される内容になります。
      実行は gosub命令と同じくサブルーチンジャンプとして行なわれ、return命令でもとの実行位置に戻ります。

      例 :
      #deffunc test int a
      mes "パラメーター="+a
      return

      追加された新規命令ではパラメータを受け取ることができるようになります。
      それぞれのパラメータには、パラメータタイプとエイリアス名の指定が可能です。指定するパラメータタイプには以下のものがあります。

      int     :  整数値
      var     :  変数(配列なし)
      array   :  変数(配列あり)
      str     :  文字列
      double  :  実数値
      local   :  ローカル変数

      エイリアス名は、渡されたパラメーターの内容を示すもので、変数とほとんど同じ感覚で使用することができます。
      varとarrayの使い分けには注意が必要なほか、 ローカル変数を示すlocalタイプは特殊な用途となります。
      詳しくは、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。

      特殊な用途として、パラメータータイプの替わりに「onexit」を記述することで、クリーンアップ命令として登録することができます。クリーンアップ命令は、HSPスクリプト実行の終了時に自動的に呼び出されます。

      例:
      #deffunc 名前 onexit

      モジュールによって機能を拡張した場合などにその後始末、システムやメモリの解放などを行なうために利用することができます。

      新規命令の名称は、通常すべてのモジュール空間、グローバル空間で共有されます。
      ただし、local指定の後に名称を指定した場合は、モジュール固有のものとして扱われます。

      例 :
      #module user
      #deffunc local test int a
      mes "パラメーター="+a
      return
      #global
      test@user 5

      これは、モジュール内でのみ使用される命令を定義する場合などに使用することができます。
      local指定により登録された名称は、必ず「名称@モジュール名」の形式で呼び出す必要があります。
    </Setting>
  </command>
  <command>
    <Name>#defcfunc</Name>
    <Title>新規関数を登録する</Title>
    <Format>
      p1 p2 p3,…
      p1      : 登録する関数の名前
      p2 p3〜 : パラメータータイプ名・エイリアス名
    </Format>
    <Setting>
      ユーザーによる新規関数を登録します。
      p1に新規関数の名前を、p2以降に呼び出しパラメータタイプを指定します。
      #defcfunc命令で定義した名前をスクリプト内で関数として使用することが可能になります。

      新規関数は、 #defcfuncで指定された行以降が実行される内容になります。実行はgosub命令と同じくサブルーチンジャンプとして行なわれ、 return命令でもとの実行位置に戻ります。
      その際にreturn命令に戻り値のパラメーターを指定する必要があります。

      例 :
      #defcfunc half int a
      return a/2

      追加された新規関数ではパラメータを受け取ることができるようになります。
      それぞれのパラメータには、パラメータタイプとエイリアス名の指定が可能です。指定するパラメータタイプには以下のものがあります。

      int     :  整数値
      var     :  変数(配列なし)
      array   :  変数(配列あり)
      str     :  文字列
      double  :  実数値
      local   :  ローカル変数

      エイリアス名は、渡されたパラメーターの内容を示すもので、変数とほとんど同じ感覚で使用することができます。
      varとarrayの使い分けには注意が必要なほか、 ローカル変数を示すlocalタイプは特殊な用途となります。
      詳しくは、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。

      新規関数の名称は、通常すべてのモジュール空間、グローバル空間で共有されます。
      ただし、local指定の後に名称を指定した場合は、モジュール固有のものとして扱われます。

      例 :
      #module user
      #defcfunc local test int a
      return a+5
      #global
      mes test@user(5)

      これは、モジュール内でのみ使用される関数を定義する場合などに使用することができます。
      local指定により登録された名称は、必ず「名称@モジュール名」の形式で呼び出す必要があります。
    </Setting>
  </command>
  <command>
    <Name>#pack</Name>
    <Title>PACKFILE追加ファイル指定</Title>
    <Format>
      "filename"
      "filename" : PACKFILEに追加されるファイル
    </Format>
    <Setting>
      実行ファイル自動作成(ctrl+F9)で、 packfileに追加されるファイルを指定します。指定されたファイルは、実行ファイル作成時にリソースとして一緒にパックされます。#packは、通常の形式でパックします。 暗号化してパックしたい場合は#epackをお使い下さい。
      重複したファイルを追加しようとした場合には、無視されます。
      「start.ax」は、実行ファイル自動作成の際に自動的に追加されるため特に追加ファイルとして指定する必要はありません。

      例 :
      #pack "a.txt"

      上の例では、「a.txt」というファイルを実行ファイルと一緒にパックします。
    </Setting>
  </command>
  <command>
    <Name>#epack</Name>
    <Title>PACKFILE暗号化ファイル指定</Title>
    <Format>
      "filename"
      "filename" : PACKFILEに追加されるファイル
    </Format>
    <Setting>
      実行ファイル自動作成(ctrl+F9)で、 packfileに追加されるファイルを指定します。指定されたファイルは、実行ファイル作成時にリソースとして一緒にパックされます。#epackは、指定ファイルを暗号化してパックします。
      暗号化を行なう必要がない場合は#packをお使い下さい。
      重複したファイルを追加しようとした場合には、無視されます。
      「start.ax」は、実行ファイル自動作成の際に自動的に追加されるため特に追加ファイルとして指定する必要はありません。

      例 :
      #epack "a.bmp"

      上の例では、「a.bmp」 というファイルを暗号化して実行ファイルと一緒にパックします。
    </Setting>
  </command>
  <command>
    <Name>#packopt</Name>
    <Title>自動作成オプション指定</Title>
    <Format>
      p1 p2
      p1 : キーワード
      p2 : 設定内容
    </Format>
    <Setting>
      実行ファイル自動作成の動作を指定します。
      キーワード名、の後スペース又は TAB を入れてパラメーター(文字列の場合は「"strings"」のように指定)を記述して下さい。
      #packoptで指定できるキーワードは以下の通りです。

      キーワード |      内      容        | 初期値
      ------------------------------------------------------
      name      | 実行ファイル名         | "hsptmp"
      runtime    | 使用するランタイム     | "hsprt"
      type       | 実行ファイルのタイプ   | 0
      | (0=EXEファイル)        |
      | (1=フルスクリーンEXE)  |
      | (2=スクリーンセーバー) |
      xsize      | 初期ウィンドウXサイズ  | 640
      ysize      | 初期ウィンドウYサイズ  | 480
      hide       | 初期ウィンドウ非表示SW | 0
      orgpath    | 初期ディレクトリ維持SW | 0
      ------------------------------------------------------

      以下の例では、 「test.scr」というスクリーンセーバーを「hsp2c.hrt」というランタイムを使用して作成します。

      例 :
      #packopt type 2
      #packopt name "test"
      #packopt runtime "hsp2c.hrt"

      今まで通りに、「packfile編集」からパックされるファイルを選択して実行ファイルを作成することも可能です。
      「実行ファイル自動作成」を行なうと、packfileが自動的に作成されるため、それまで保存されていたpackfileの情報は上書きされるので注意して下さい。
      尚、「start.ax」はデフォルトで暗号化されたものがpackfileに追加されます。
      また、 「#packopt runtime "ランタイムファイル名"」で指定されたランタイムファイル(拡張子がhrtのもの)は、 hspcmp.dllと同じディレクトリか、または、runtimeディレクトリに置かれているものが使用されます。
    </Setting>
  </command>
  <command>
    <Name>#const</Name>
    <Title>マクロ名の定数定義</Title>
    <Format>マクロ名 定数式</Format>
    <Setting>
      指定されたマクロ名に置換え数値を設定します。
      #defineと同様ですが、 #constは定数(数値)の置き換えを行なう場合にあらかじめ計算を行なった結果を置き換えます。

      例 :
      #const KAZU 100+50
      a=KAZU
      ↓(展開後)
      a=150

      あらかじめソース内で使用する値が確定している場合、ソースの高速化に有効です。すでに定義されているマクロを含めることも可能なので、

      例 :
      #const ALL 50
      #const KAZU 100*ALL
      a=KAZU
      ↓(展開後)
      a=5000

      のように使用することができます。
      計算式は、整数及び実数を使用することができます。
      演算子および数値の記述スタイルは、通常の式と同様のものが使えます。カッコによる順位の指定も可能です。

      #const命令の直後に「global」を入れることで、すべてのモジュールで永続的に利用することのできるマクロを作成することができます。

      例 :
      #module
      #const global test 1234
      #global
      a=test   ; aに1234が代入される

      通常は、モジュール内で#constを定義した場合には、それ以外のモジュールおよびグローバルなエリアでは、同じ名前は認識されません。
      global指定を入れることで、それ以降のすべての場所で定義した名前をマクロで置き換えることができるようになります。

      #const命令の直後に「double」を入れることで、 定義されている数値が強制的に実数と認識されます。
      この指定を行なわなかった場合には、小数点以下の値があるかどうかによって、整数と実数が自動的に判別されます。
    </Setting>
  </command>
  <command>
    <Name>#undef</Name>
    <Title>マクロ名の取り消し</Title>
    <Format>マクロ名</Format>
    <Setting>
      すでに登録されているマクロ名を取り消します。
      登録されていないマクロ名に対して指定してもエラーにはならず無視されます。
    </Setting>
  </command>
  <command>
    <Name>#if</Name>
    <Title>数値からコンパイル制御</Title>
    <Format>数値式</Format>
    <Setting>
      コンパイルのON/OFFを指定します。
      #ifは指定した数値が 0ならば以降のコンパイル出力をOFFにしてコンパイル結果を無視します(プログラムとして実行されません)。
      数値が0以外の場合は、出力がONとなります。
      このコンパイル制御は、#endifが出るまでの区間を対象にします。
      #if、#ifdef、#ifndefのいずれかには、#endifがペアで存在している必要があります。

      例 :
      #if 0
      mes "ABC"       ; この部分は無視されます
      a=111           ; この部分は無視されます
      mes "DEF"       ; この部分は無視されます
      #endif

      #ifの指定には式を使うことも可能なので、

      例 :
      #define VER 5
      #if VER&lt;3
	mes="" "ABC"       ; この部分は無視されます=""
	a="111"           ; この部分は無視されます=""
	mes="" "DEF"       ; この部分は無視されます=""
endif=""

のような使い方もできます。計算式の記述および演算子の注意点などは、#const命令と同様です。=""
また、#if〜#endifのプロックを入れ子にすることも可能です。=""

例="" :=""
ifdef="" SW=""
  ifdef="" SW2=""
 mes="" "AAA"       ; SWとSW2が定義されている場合=""
  else=""
 mes="" "BBB"       ; SWが定義されている場合=""
  endif=""
endif=""

基本的にCやC++のプリプロセッサに近い使い方ができるようになっています。=""
プリプロセッサは、通常のコンパイルで自動的に適用されます。=""
    </Setting>
  </command>
  <command>
    <Name>#ifdef</Name>
    <Title>マクロ定義からコンパイル制御</Title>
    <Format>マクロ名</Format>
    <Setting>
      コンパイルのON/OFFを指定します。
      #ifdefは指定したマクロが定義されていなければ以降のコンパイル出力をOFFにしてコンパイル結果を無視します。定義されている場合は、出力がONとなります。このコンパイル制御は、#endifが出るまでの区間を対象にします。
      コンパイル制御についての詳細は、 #if命令のリファレンスを参照してください。
    </Setting>
  </command>
  <command>
    <Name>#ifndef</Name>
    <Title>マクロ定義からコンパイル制御2</Title>
    <Format>マクロ名</Format>
    <Setting>
      コンパイルのON/OFFを指定します。
      #ifndefは指定したマクロが定義されていれば以降のコンパイル出力をOFFにしてコンパイル結果を無視します。定義されていない場合は、出力がONとなります。このコンパイル制御は、#endifが出るまでの区間を対象にします。
      コンパイル制御についての詳細は、 #if命令のリファレンスを参照してください。
    </Setting>
  </command>
  <command>
    <Name>#else</Name>
    <Title>コンパイル制御を反転</Title>
    <Format></Format>
    <Setting>
      #if、#ifdef、#ifndefなどのコンパイル制御区間内で、ON/OFFを反転します。
      コンパイル制御についての詳細は、 #if命令のリファレンスを参照してください。
    </Setting>
  </command>
  <command>
    <Name>#endif</Name>
    <Title>コンパイル制御ブロック終了</Title>
    <Format></Format>
    <Setting>
      #if、#ifdef、#ifndefなどのコンパイル制御区間を終了します。
      コンパイル制御についての詳細は、 #if命令のリファレンスを参照してください。
    </Setting>
  </command>
  <command>
    <Name>#modfunc</Name>
    <Title>新規命令を割り当てる</Title>
    <Format>
      p1 p2 p3,…
      p1      : 割り当てられる命令の名前
      p2 p3〜 : パラメータータイプ名・エイリアス名
    </Format>
    <Setting>
      モジュール変数を処理するための新規命令を登録します。
      p1に新規命令の名前を、p2以降に呼び出しパラメータタイプを指定します。
      命令を定義した位置より以降は、指定された名前を命令語として使用することが可能です。
      また、#modfuncのルーチン内では、システム変数thismodを、 自分自身のモジュール変数として扱うことができます。

      #modfunc命令のパラメーターは、#deffunc命令と同じ形式になります。
      #deffunc命令との違いは、呼び出しの際にモジュール型の変数を指定する必要がある点です。モジュール変数の詳細については、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#modcfunc</Name>
    <Title>新規関数を割り当てる</Title>
    <Format>
      p1 p2 p3,…
      p1      : 割り当てられる命令の名前
      p2 p3〜 : パラメータータイプ名・エイリアス名
    </Format>
    <Setting>
      モジュール変数を処理するための新規関数を登録します。
      p1に新規命令の名前を、p2以降に呼び出しパラメータタイプを指定します。
      命令を定義した位置より以降は、指定された名前を命令語として使用することが可能です。
      また、#modcfuncのルーチン内では、システム変数thismodを、 自分自身のモジュール変数として扱うことができます。

      #modcfunc命令のパラメーターは、#defcfunc命令と同じ形式になります。
      #defcfunc命令との違いは、呼び出しの際にモジュール型の変数を指定する必要がある点です。モジュール変数の詳細については、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#modinit</Name>
    <Title>モジュール初期化処理の登録</Title>
    <Format>
      p1 p2,…
      p1 p2〜 : パラメータータイプ名・エイリアス名
    </Format>
    <Setting>
      モジュール変数を初期化するための処理(コンストラクタ)を登録します。
      オプションとして呼び出しパラメータタイプ、エイリアス名を指定することができます。
      #modinitで定義した区間は、newmod命令実行時に自動的に呼び出されるようになります。
      また、newmod命令で指定されたオプションパラメーターを、コンストラクタ側で取得することが可能です。
      モジュール変数の詳細については、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。

      #modinit命令のパラメータータイプ、エイリアス名は、#deffunc命令と同じ形式になります。
    </Setting>
  </command>
  <command>
    <Name>#modterm</Name>
    <Title>モジュール解放処理の登録</Title>
    <Format></Format>
    <Setting>
      モジュール変数を破棄するための処理(デストラクタ)を登録します。
      オプションとして呼び出しパラメータタイプ、エイリアス名を指定することができます。
      #modtermで定義した区間は、delmod命令実行時かモジュール変数が破棄された時、自動的に呼び出されます。
      モジュール変数の詳細については、プログラミングマニュアル(hspprog.htm)のモジュール項目を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#regcmd</Name>
    <Title>拡張プラグインの登録</Title>
    <Format>
      "初期化関数名","DLLファイル名",変数型拡張数
      "初期化関数名"  : プラグイン初期化関数のエクスポート名
      "DLLファイル名" : プラグイン初期化関数のDLL名
      変数型拡張数(0) : プラグインで拡張される変数型の数
    </Format>
    <Setting>
      HSP拡張プラグインの登録を行ないます。
      初期化関数名は、 DLLからエクスポートされた名前を正確に指定しなければなりません。VC++からエクスポートした場合には、先頭に「_」が、最後に「@4」が付加されるので、それを含めた名前を記述します。(VC++以外のコンパイラで作成されたDLLの場合は、エクスポート名のルールが異なります。詳しくは、それぞれの環境の資料を参照してください。)
      たとえば、「hpi3sample.dll」の「hsp3cmdinit」 という関数を登録する場合は、

      例 :
      #regcmd "_hsp3cmdinit@4","hpi3sample.dll"

      のようになります。
      変数型をプラグインにより拡張する場合には、「変数型拡張数」を指定する必要があります。
      変数型を１種類追加する場合は、変数型拡張数に１を指定してください。変数型を拡張しない場合は、変数型拡張数は省略するか０を指定してください。変数型拡張数が正しく指定されないと、型の登録は無効になるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>#cmd</Name>
    <Title>拡張キーワードの登録</Title>
    <Format>
      新規キーワード サブID
      新規キーワード : 追加されるキーワード
      サブID         : キーワードの与えられるサブID値
    </Format>
    <Setting>
      HSP拡張プラグインのためにキーワードの登録を行ないます。
      あらかじめ、 #regcmd命令によってプラグイン初期化関数の登録を行なっておく必要があります。

      例 :
      #cmd newcmd $000
      #cmd newcmd2 $001
      #cmd newcmd3 $002

      上の例では、「newcmd」というキーワードがサブID0として、「newcmd2」というキーワードがサブID1、 「newcmd3」というキーワードがサブID2として登録されます。
    </Setting>
  </command>
  <command>
    <Name>#usecom</Name>
    <Title>外部COMインターフェースの指定</Title>
    <Format>
      インターフェース名 "インターフェースIID" "クラスIID"
      インターフェース名    : インターフェースを識別するキーワード
      "インターフェースIID" : COMのインターフェースを示すIID文字列
      "クラスIID"           : COMのクラスを示すIID文字列
    </Format>
    <Setting>
      外部コンポーネント(COM)定義を行ないます。
      指定したインターフェース名に、クラスIID、インターフェースIIDを割り当てて使用可能な状態にします。
      IIDは、レジストリと同様の文字列({〜})で指定することができます。
      また、"クラスIID"は省略することができます。

      例 :
      #define CLSID_ShellLink "{00021401-0000-0000-C000-000000000046}"
      #define IID_IShellLinkA "{000214EE-0000-0000-C000-000000000046}"
      #usecom IShellLinkA IID_IShellLinkA CLSID_ShellLink

      インターフェース名の直前に「global」を入れることで、 すべてのモジュールで永続的に利用することのできるインターフェースを作成することができます。
    </Setting>
  </command>
  <command>
    <Name>#comfunc</Name>
    <Title>外部COM呼び出し命令登録</Title>
    <Format>
      新規名称 インデックス タイプ名1,…
      新規名称     : 命令として認識されるキーワード名
      インデックス : メソッドindex値
      タイプ名     : 引数のタイプを,で区切って指定します
    </Format>
    <Setting>
      外部コンポーネント(COM)を呼び出すための新しい命令を登録します。
      #comfuncは、 #usecom命令によって指定されたインターフェースのメソッドを命令として呼び出すための登録を行ないます。
      以降は、 新規名称で指定された命令とCOMオブジェクト型の変数を組み合わせてコンポーネントを呼び出すことができます。

      新規名称、インデックス、タイプをスペースで区切って書きます。
      新規名称の直前に「global」を入れることで、 すべてのモジュールで永続的に利用することのできる命令を作成することができます。

      タイプ名には、引数の詳細を記述します。
      #deffunc命令と同様に、引数の型を「,」で区切って指定してください。
      引数の数や、型の順番に制限はありません。
      引数の型として使用できる文字列は以下の通りです。

      型      :  内     容
      -------------------------------------------------------------
      int     :  整数値(32bit)
      var     :  変数のデータポインタ(32bit)
      str     :  文字列ポインタ(32bit)
      wstr    :  unicode文字列ポインタ(32bit)
      double  :  実数値(64bit)
      float   :  実数値(32bit)
      pval    :  PVal構造体のポインタ(32bit)
      bmscr   :  (*)BMSCR構造体のポインタ(32bit)
      hwnd    :  (*)現在選択されているウィンドウのハンドル(HWND)
      hdc     :  (*)現在選択されているウィンドウのデバイスコンテキスト(HDC)
      hinst   :  (*)実行中のHSPインスタンスハンドル

      (*)がついている項目は、 引数として指定する必要なく自動的に渡されるパラメーターを示しています。

      例 :
      ; シェルリンクオブジェクトのクラスID
      #define CLSID_ShellLink "{00021401-0000-0000-C000-000000000046}"
      ; IShellLink インターフェースのインターフェースID
      #define IID_IShellLinkA "{000214EE-0000-0000-C000-000000000046}"

      #usecom IShellLinkA IID_IShellLinkA CLSID_ShellLink
      #comfunc IShellLink_SetPath 20 str

      newcom slink, IShellLinkA
      IShellLink_SetPath slink, "c:¥¥hsp261¥¥hsp2.exe"

      上の例では、IShellLinkAインターフェースのIShellLink_SetPathをslinkという変数とともに呼び出しています。
      #comfuncで登録された命令は、最初の引数が常に同じインターフェースを持つCOMオブジェクト型の変数になるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>#enum</Name>
    <Title>マクロ名の定数を列挙</Title>
    <Format>
      マクロ名 = p1
      マクロ名 : 定数を割り当てるマクロ名
      p1       : 割り当てられる定数
    </Format>
    <Setting>
      指定されたマクロ名に連続した値を割り当てます。
      #const命令と同様に、定数を示すマクロ名を定義することができます。

      例 :
      #enum KAZU_A = 0	; KAZU_Aは0になる
      #enum KAZU_B		; KAZU_Bは1になる
      #enum KAZU_C		; KAZU_Cは2になる
      a=KAZU_B
      ↓(展開後)
      a=1

      マクロ名に続いて「=(イコール)」と数値(または式)を書くことで、 定数が初期化されます。 以降は、#enum命令で定義するたびに数値が１づつ増えていきます。
      #enum命令は、連続した値をマクロによって定義したい場合に使用します。
      #const命令により、数値をいちいち指定する必要がなく、後から追加や削除が容易になります。
    </Setting>
  </command>
  <command>
    <Name>#runtime</Name>
    <Title>ランタイムファイルの設定</Title>
    <Format>
      "ランタイム名"
      "ランタイム名" : 設定するランタイム名
    </Format>
    <Setting>
      スクリプトの実行に使用されるランタイムファイル名を設定します。
      (ランタイムファイル名は、   拡張子の除いたファイルの名前部分を指定します。)
      スクリプトエディタからの実行時や実行ファイル作成時のランタイムを設定する場合に使用します。
      #runtime命令が複数設定された場合は、最後に設定された内容が有効になります。
    </Setting>
  </command>
  <command>
    <Name>#cmpopt</Name>
    <Title>コンパイル時の設定</Title>
    <Format>
      オプション名  パラメーター
      オプション名 : オプションの種類
      パラメーター : 設定するパラメーター
    </Format>
    <Setting>
      スクリプトコンパイル時の動作を指定します。
      オプション名、の後スペース又は TAB を入れてパラメーター
      (文字列の場合は「"strings"」のように指定)を記述して下さい。
      #cmpoptで指定できるキーワードは以下の通りです。

      オプション |      内      容            | 初期値
      ------------------------------------------------------
      ppout      | プリプロセッサファイル出力 | 0
      | (0=なし/1=出力する)        |
      optcode    | 不要なコードの最適化       | 1
      | (0=なし/1=最適化する)      |
      optinfo    | 最適化の情報ログ出力       | 0
      | (0=なし/1=出力する)        |
      varname    | デバッグ時以外での         | 0
      | 変数名情報の出力           |
      | (0=なし/1=あり)            |
      varinit    | 未初期化変数のチェック     | 0
      | (0=警告/1=エラー)          |
      optprm     | パラメーターコードの最適化 | 1
      | (0=なし/1=最適化する)      |
      skipjpspc  | 全角スペースの無視         | 1
      | (0=エラー/1=無視する)      |
      ------------------------------------------------------

      以下の例では、プリプロセッサ結果をファイル出力します。

      例 :
      #cmpopt ppout 1

      #cmpopt命令は、基本的にスクリプトの先頭に記述してください。
      複数の#cmpopt命令が記述されている場合は、それぞれのオプションにおいて最後の設定が有効になります。(#packoptオプションと同様です)
      また、特定の範囲だけにオプションを適用するような書き方はできません。
    </Setting>
  </command>
  <command>
    <Name>#aht</Name>
    <Title>AHTファイルヘッダを記述</Title>
    <Format>
      設定名 p1
      設定名 : 定数を割り当てる設定項目の名前
      p1     : 割り当てられる定数
    </Format>
    <Setting>
      ソーススクリプトにAHTファイルの情報を付加します。
      指定された設定名に文字列または数値を割り当てることができます。
      #aht命令により、AHTファイルヘッダが付加されたソーススクリプトは、AHTファイルとして、テンプレートマネージャー等から参照することが可能になります。
      設定名として使用できる

      設定名     |      内      容
      ------------------------------------------------------------
      class      | AHTファイルのクラス名を指定します
      name       | AHTファイルの名称を指定します
      author     | AHTファイルの作者名を指定します
      ver        | AHTファイルのバージョンを指定します
      exp        | AHTファイルについての説明を指定します
      icon       | AHTファイル固有のアイコンファイルを指定します
      iconid     | AHTファイル固有のアイコンIDを指定します
      ------------------------------------------------------------

      AHTファイルについての詳細は、ドキュメント「Additional HSP Template &amp; Tools」(aht.txt)を参照してください。
    </Setting>
  </command>
  <command>
    <Name>#ahtmes</Name>
    <Title>AHTメッセージの出力</Title>
    <Format>
      p1
      p1     : 出力される文字列式
    </Format>
    <Setting>
      AHTパース時に、外部へのメッセージ出力を行ないます。
      主に、「かんたん入力」でエディタ上に追加されるソースコードを記述するために使用しています。
      #ahtmes命令は、mes命令と同様に文字列やマクロを「+」演算子で接続させて出力することができます。

      例 :
      #define 代入する変数	a	;;str
      #const 乱数の範囲 100		;;help="0から指定範囲-1まで発生します"
      #ahtmes	"	"+代入する変数+" = rnd( "+乱数の範囲+" )¥t¥t; 変数 "+代入する変数+" に乱数を代入します。"

      通常のmes命令と異なり、あくまでもプリプロセッサ上で定義されているマクロを接続するという点に注意してください。
      AHTファイルについての詳細は、ドキュメント「Additional HSP Template &amp; Tools」(aht.txt)を参照してください。
    </Setting>
  </command>
  <command>
    <Name>await</Name>
    <Title>一定の時間で待つ</Title>
    <Format>
      p1
      p1=0〜(0) : 待ち時間(1ms単位)
    </Format>
    <Setting>
      プログラムの実行を一定時間だけ中断します。

      wait命令と似ていますが、 await命令は前回waitした時間からの待ち時間を指定します。これにより、描画速度の違いなどから時間が早く過ぎることを防止することができます。リアルタイムで更新される画面などの速度を一定に保つ時に使用します。

      HSPでは、他のWindowsタスクに処理時間を渡すために長い時間ループが起こる可能性がある場所にはwaitかawait命令を入れることを推奨しています。waitや await命令がない命令の中を長い時間ループするようなプログラムを実行すると、ウィンドウをドラッグしにくくなったり、他のタスクに移るのに時間がかかったりします。
    </Setting>
  </command>
  <command>
    <Name>exec</Name>
    <Title>Windowsのファイルを実行する</Title>
    <Format>
      "filename",p1,"command"
      "filename" : 対象となるファイル名
      p1=0〜(0)  : ファイル実行モード
      "command"  : コンテキストメニューの操作名
    </Format>
    <Setting>
      execは "filename" で指定したファイル名のアプリケーションを実行します。
      拡張子がEXEの場合は、拡張子を省略することができます。
      p1で実行時のモードを選ぶことができます。p1を省略した場合は0になります。

      モード0  : HSPノーマル実行
      モード2  : 最小化モードで実行
      モード16 : 関連付けされたアプリケーションを実行
      モード32 : 指定したファイルを印刷する

      "command"が指定された場合は、 "filename"で指定したファイルまたはフォルダ名に対するコンテキストメニュー操作名となります。
      コンテキストメニュー操作名は、レジストリに登録されているアクションを指定する文字列で、標準で以下のようなものが用意されています。

      操作名     |     説    明
      ---------------------------------------------------------------------
      edit       | エディタを開いて編集する。
      explore    | フォルダを選択して、エクスプローラを起動します。
      open       | 関連付けられたアプリケーションでファイルを開きます。
      print      | 関連付けられたアプリケーションでファイルを印刷します。
      properties | ファイルまたはフォルダのプロパティを表示します。

      "command"が指定された場合は、ファイル実行モードの16、 32は無効になります。また、実行結果を示す値がシステム変数statに返されます。

      ノーマル実行は、新しく起動したアプリケーションのウィンドウがアクティブになり、入力フォーカスも移りますが、マルチタスクで、 HSPは終了せずに実行を続けます。

      例 ：
      exec "calc"  ; Windows電卓を起動

      また、ファイル名に続けてパラメータを書くこともできます。

      例 ：
      exec "notepad hsp.txt"  ; ノートパッドでhsp.txtを開く

      モード２は指定したアプリケーションを最小化した状態で実行します。
      DOSアプリケーションの実行時にHSPの画面を遮ることなくバックで実行させることができます。

      モード16は、実行ファイルではなく、データファイルを指定してその拡張子に関連付けられたアプリケーションを実行します。

      例 ：
      exec "hsp.txt",16  ; hsp.txtを関連付けられたアプリケーションで開く

      上の例では、「hsp.txt」を関連付けされたアプリケーションで開きます。
      (通常は、notepad.exe)
      また、 モード16ではインターネットのURLを指定することでインターネットショートカットとしても使用することが可能です。

      例 ：
      ;インターネットのページを開く
      exec "http://www.onionsoft.net/hsp/",16

      モード32では、指定したファイルに関連付けされたアプリケーションを経由して、プリンタに印刷をします。
      たとえば、

      例 ：
      exec "hsp.txt",32  ; hsp.txtをプリンタで印刷

      は、「txt」に関連付けされたアプリケーションで「hsp.txt」を自動的に印刷します。印刷のオプションなどはすべて、関連付けされたアプリケーションで指定されたものになります。

      モードは、複数同時に指定することが可能です。
      たとえば、モード2とモード16を同時に指定する場合は、それぞれの値を加算して18になります。この場合は、「最小化モードで関連付けされたアプリケーションを実行」になります。

      ※HSP2.61までサポートされていたモード1(タスク実行待ち)は、HSP3ではサポートしていません。起動したプロセスを監視するか、コンソールアプリケーションの場合はpipeexec命令をご使用ください。
    </Setting>
  </command>
  <command>
    <Name>end</Name>
    <Title>プログラム終了</Title>
    <Format>
      p1
      p1(0) : 終了コード
    </Format>
    <Setting>
      HSPのプログラムを終了します。
      end命令はスクリプトのどこにあってもかまいません。
      end命令が実行されると、そのアプリケーションは終了します。

      アプリケーションの終了コードをパラメーターp1で指定することができます。p1を省略した場合は、0がアプリケーション終了コードとなります。
      アプリケーション終了コードは、他のプロセスやバッチファイルへの通知に使用されます。通常は、省略(0)していて問題ありません。
    </Setting>
  </command>
  <command>
    <Name>gosub</Name>
    <Title>指定ラベルにサブルーチンジャンプ</Title>
    <Format>
      *label
      *label : ラベル名
    </Format>
    <Setting>
      サブルーチンジャンプをします。
      gosub命令は、*labelで指定した場所にジャンプをします。
      その後、return命令があるとgosub命令の次の行に復帰して実行を続けます。
      gosub〜returnはネスティング(入れ子構造)にすることが可能です。
      (最大ネスティング数はHSPが持つスタックメモリの量により変動します)
    </Setting>
  </command>
  <command>
    <Name>goto</Name>
    <Title>指定ラベルにジャンプ</Title>
    <Format>
      *label
      *label : ラベル名
    </Format>
    <Setting>
      指定したラベルに無条件でジャンプします。
      以降は、ラベル名で指定された場所から実行を続けます。
    </Setting>
  </command>
  <command>
    <Name>if</Name>
    <Title>条件を満たしていればその行の命令を実行</Title>
    <Format>
      p1
      p1 : 条件式
    </Format>
    <Setting>
      p1の条件式が満たされていれば、それ以降の命令を実行する。満たされていない場合は、次の行に移ります。
      BASICと違い、その行の次の命令との間には :(ｺﾛﾝ)を入れなければいけないので注意してください。

      例 ：
      a=10
      if a=10 : mes "aは10です。"

      上の例では、「a=10」の部分が条件式になります。条件式には主に、

      a=b  : aとbは等しい
      a!b  : aとbは等しくない
      a&lt;b  :="" aはbよりも小さい=""
      a=>b  : aはbよりも大きい
      a&lt;=b : aはbよりも小さいか等しい
      a>=b : aはbよりも大きいか等しい

        を使います。if＋条件式の後は：(コロン)で区切り、それに続いて条件が満たされた場合に実行される部分を書きます。
        (C言語やJavaと同じように「=」「!」を「==」「!=」のように記述することも可能です) もし、条件によってプログラムの流れを変えたい場合には、

        例 ：
        a=10
        if a>10 : goto *over10
        mes "aは10以下です。"
        stop
        *over10
        mes "aは10より大きいです。"
        stop

        上のように、goto命令で別なラベルに飛ばすことも可能です。
        また、else命令を使って条件が満たされなかった場合の処理を同じ行に書くことも可能です。

        例 ：
        a=10
        mes "aは、"
        if a=10 : mes "10です。" : else : mes "10ではありません。"
        stop

        この場合は、else命令のある部分までは、条件を満たした場合に実行され、else命令以降は、条件を満たされなかった場合に実行されます。
        次の行以降は、条件に関わらず通常通りに実行されます。

        より複雑な条件判断をするために、論理演算式を使うこともできます。

        a&amp;b  : aとbがともに正しい (and)
        a|b  : aとbのどちらかが正しい (or)

        これによって複数の条件を一度に記述することができます。

        例 ：
        a=10:b=20
        if (a=10)|(b=10) : mes "aかbのどちらかが10です。"

        上の例では、「a=10」と「b=10」 という条件式を|(or)でつないで、どちらかが正しい場合には、正しいという結果が出るようにしています。
        論理演算は、 「|」「&amp;」といった記号の他に「or」「and」という文字列でも記述することができます。

        例 ：
        if (a=10)or(b=10) : mes "aかbのどちらかが10です。"

        上のように書いても、結果は同じになります。

        if命令の条件が正しい時に実行されるスクリプトを複数行に渡って記述する場合は、

        例 :
        a=10
        if a>5 {
        mes "TRUE"
        mes "(MULTILINE IF)"
        }

        のように「{」で始めて「}」で終わる部分までを指定します。
        (上の例では、 見やすくするためにC言語風に行の最初にTABを入れてありますが、特に必要なものではありません。ユーザーの見やすいように記述してください)

        else命令でも複数行の指定ができます。

        例 :
        a=10
        if a>5 {
        mes "TRUE"
        mes "(MULTILINE IF)"
        }
        else {
        mes " FALSE"
        mes " (MULTILINE IF)"
        }
        return

        ただし、else の後に「{」を記述しなければ複数行にはならないので注意してください。
    </Setting>
  </command>
  <command>
    <Name>loop</Name>
    <Title>ループの始まりに戻る</Title>
    <Format></Format>
    <Setting>
      repeat命令で指定したループの終わりを指定します。
      詳しくはrepeat命令の項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>onexit</Name>
    <Title>終了時にジャンプ</Title>
    <Format>
      goto/gosub *label
      *label : ラベル名
    </Format>
    <Setting>
      クローズボックス(ウィンドウ右上の終了ボタン)を押した時に、自動的にジャンプする場所を指定します。

      onexitの後に続けて、 gotoまたはgosubキーワードを指定してからラベルを記述します。
      gotoの場合には、単純なプログラムジャンプ。 gosubの場合はサブルーチンジャンプを行ないます。
      goto/gosubキーワードを省略した場合には、gotoキーワードと同等の動作になります。

      例 :
      onexit gosub *exit_routine  ; 終了時呼び出し

      通常は、クローズボックスを押すとどのような時でも強制終了してしまいますが、この命令が実行された以降は、クローズボックスを押すとonexit命令で指定したラベルにジャンプし、そこから実行を続けるようになります。

      終了時に確認メッセージを表示したい時、終了したらデータを保存するようにしたい時などに使います。

      この命令が実行されると、 end命令以外ではスクリプトの実行が止められなくなるので、十分に注意して使ってください。

      複数のウィンドウを作成した場合は、いずれかのウィンドウにある終了ボタンで割り込みが発生します。この時、システム変数wparamに終了の通知を受けたウィンドウIDが代入されます。

      onexitでジャンプされた直後は、システム変数iparamに終了要因が値として保存されています。
      iparamが0の場合は、ユーザーの意思でプログラムを終了。
      iparamが1の場合は、 Windowsシャットダウン(再起動または電源OFF)による終了です。Windowsシャットダウン時の終了処理には、await、wait、stop命令などでシステムにアイドルタイム(待ち時間)を発生させた場合には、シャットダ
      ウン処理を中止します(シャットダウンされません)。
      await、wait、stop命令を使わずにend命令で終了した場合には、そのままシャットダウン処理が継続されます。

      終了時ジャンプの一時的なON/OFFをすることも可能です。

      onexit 0

      で一時的に割り込みを停止します。

      onexit 1

      で一時停止した割り込みを再開させることができます。
    </Setting>
  </command>
  <command>
    <Name>return</Name>
    <Title>サブルーチンから復帰</Title>
    <Format>
      p1
      p1 : システム変数代入値
    </Format>
    <Setting>
      gosub命令やユーザー定義命令などで呼び出しされたサブルーチンを終了します。return命令により、スタックを戻し呼び出し元に復帰します。
      p1を指定することにより、サブルーチンから値をシステム変数に反映させることができます。
      p1に数値を指定した場合には、システム変数statに代入されます。
      p1に文字列を指定した場合には、システム変数refstrに代入されます。
      p1に実数値を指定した場合には、システム変数refdvalに代入されます。
      p1の指定を省略した場合には、システム変数の代入は行なわれません。
    </Setting>
  </command>
  <command>
    <Name>run</Name>
    <Title>指定したファイルに制御を移す</Title>
    <Format>
      "filename","cmdline"
      "filename" : 実行するHSPオブジェクトファイル名
      "cmdline"  : システム変数dir_cmdlineに代入される文字列
    </Format>
    <Setting>
      別のファイルに書かれたHSPのプログラムを実行します。
      指定するファイルはHSPのオブジェクトファイル (拡張子がAX)でなければなりません。
      オブジェクトファイルは、スクリプトエディタの「オブジェクトファイル作成」によって作成することができます。

      例 ：
      run "MENU2.AX","-s"

      が実行されると、いままでのプログラムはなくなり"MENU2.AX"というファイルのプログラムが最初から実行されます。
      画面の状態は維持されますが、変数、メモリバッファの内容はすべて初期化されます。また、「-s」という文字列がシステム変数 dir_cmdlineに代入された状態で実行が開始されます。

      "cmdline"パラメーターが省略された場合は、システム変数dir_cmdlineの内容は
      空になります。また、システム変数 dir_cmdlineは最大1024文字まで内容が保存されます。
    </Setting>
  </command>
  <command>
    <Name>stop</Name>
    <Title>プログラム中断</Title>
    <Format></Format>
    <Setting>
      プログラムの実行を一時中断します。
      ボタンがクリックされるまで待つ時などに使用します。
    </Setting>
  </command>
  <command>
    <Name>wait</Name>
    <Title>実行を一定時間中断する</Title>
    <Format>
      p1
      p1(100) : 待ち時間(10ms単位)
    </Format>
    <Setting>
      プログラムの実行を一定時間だけ中断します。

      p1に待ち時間の長さを指定します。単位は10ミリ秒になります。(1ミリ秒=1/1000秒)
      CPUの速度に関係なく、どんな機種でも同じ待ち時間になります。


      await命令を使うとwait命令よりも高精度で細かいウエイトが可能ですが、wait命令よりもCPUのタスクを消費します。
      リアルタイムに画像を書き換えるなどの処理でなければ、 wait命令を使用した方がCPU(Windows)の負担が軽くなります。
      常にデスクトップに配置するようなアクセサリにはwait命令を、ゲームアプリケーションなどにはawait命令を使うといった使い分けをするといいでしょう。

      HSPでは、他のWindowsタスクに処理時間を渡すために長い時間ループが起こる可能性がある場所にはwaitかawait命令を入れることを推奨しています。
      waitや await命令がない命令の中を長い時間ループするようなプログラムを実行すると、ウィンドウをドラッグしにくくなったり、他のタスクに移るのに時間がかかったりします。
    </Setting>
  </command>
  <command>
    <Name>repeat</Name>
    <Title>ループの始まりの場所を示す</Title>
    <Format>
      p1,p2
      p1=1〜(-1) : ループ回数
      p2=0〜(0)  : システム変数cntのスタート値
    </Format>
    <Setting>
      repeat〜loopの間をくり返し実行します。
      repeat命令は、くり返しの開始地点を示します。
      loop命令は最後に通過したrepeat命令まで戻ります。つまり、

      repeat 5
      print "やっほー"
      loop

      のようなプログラムは、「やっほー」を5回表示します。
      repeat命令のパラメータ、p1でくり返しの回数を指定することができます。回数の指定を省略、またはマイナス値を指定すると無限ループになります。
      繰り返しの回数が0の場合は、繰り返し部分は実行されず対応する loop命令までジャンプします。

      repeat〜loopを含む部分をさらにループさせるネスト構造も記述することができます。ただし、正常にloop命令を通ってループしないで抜けたりすると、ネスト構造がおかしくなるのでループから強制的に抜けるような構造にはしないようにしてください。

      ループ回数を調べたい時や、カウンターを利用したい時のためにシステム変数cntを参照することができます。cntは通常、0からスタートして、 loop命令でループするたびに1づつ増えていきます。
      ただし、repeat命令のp2でカウンタがスタートする数値を変更することも可能です。たとえば、repeat 3,1 のように指定した場合には、変数cntの値は1,2,3の順で変化します。

      ループの内部で、強制的にループを抜け出す場合には、 break命令を使用してください。また、ループをやり直すためのcontinue命令も用意されています。
    </Setting>
  </command>
  <command>
    <Name>break</Name>
    <Title>ループから抜ける</Title>
    <Format></Format>
    <Setting>
      repeat〜loop間のループから、強制的に抜け出します。

      repeat 5
      if cnt=2 : break
      mes "繰り返し["+cnt+"]"
      loop

      上の例では、システム変数が2になった時点、つまり３回目のループになると、if命令の判断によって、break命令が実行されるしくみになっています。
      break命令が実行されると、繰り返しの回数がまだ残っていても、 強制的に繰り返しから抜け出し、loop命令の次にある命令から実行を続けます。
      break命令以降(上の例では、mes命令)は実行されません。
      この命令を使うと、たとえば次のようなスクリプトが作成可能です。

      repeat
      getkey a,1
      if a>0 : break
      await 10
      loop

      上のスクリプトでは、マウスの左ボタンを押すまで待つループになります。
      repeat命令の回数指定を省略すると無限ループになるので、それを利用してボタンの状態が 1になるまでは、ずっと同じところを繰り返すようになっています。ボタンが押されると、 break命令が実行され繰り返しから抜け出します。
    </Setting>
  </command>
  <command>
    <Name>continue</Name>
    <Title>ループをやり直す</Title>
    <Format>
      p1
      p1 = 0〜 : 繰り返しカウンタ変更値
    </Format>
    <Setting>
      repeat〜loop間のループをやり直します。
      continue命令が実行されると、repeat命令まで戻り次の繰り返しを実行します。

      repeat 5
      if cnt=2 : continue
      mes "cnt="+cnt
      loop

      上の例では、システム変数cntが2になった時点で、continue命令が実行されるしくみになっています。
      上のスクリプトが実行されると、

      cnt=0
      cnt=1
      cnt=3
      cnt=4

      のような表示になり、システム変数cntが２の時だけmes命令が実行されないのがわかります。
      最初はわかりにくいかもしれませんが、continue命令は、loop命令の場所ではないが、loop命令と同じ働きをするとも言えます。
      繰り返しのカウンタは、continue命令が実行された場合でも、loop命令と同様1つ増加します。
      もし、最後の繰り返しでcontinue命令が実行されると、repeat〜loopが終わった状態、つまりloop命令の次の命令から実行を続けます。

      さらにもう１つ、continue命令にはパラメータを指定する使い方が存在します。
      continueの後に、数値または数値型変数を指定することにより、繰り返しのカウンタを示すシステム変数cntの内容を変更することができます。
      たとえば、「continue 1」と指定した場合は、システム変数cntの内容は1になり、その値のままrepeat命令の次から繰り返しを続けます。
      パラメータを省略して、ただの「continue」だけの場合はloop命令と同様の処理、数値を指定すると、カウンタの値を変更して繰り返しをやり直すことになります。
      ですから、

      repeat 1
      await 10
      getkey a,1
      if a=0 : continue 0
      loop

      このようなスクリプトでは、通常1回だけしか実行されないはずの、 repeat〜loopの繰り返しですが、マウスの左ボタンが押されていない場合は、カウンタが0に戻され無限ループの状態になります。 これで、ボタンを押すまで待つという動作になります。
    </Setting>
  </command>
  <command>
    <Name>onkey</Name>
    <Title>キー割り込み実行指定</Title>
    <Format>
      goto/gosub *label
      *label : ラベル名
    </Format>
    <Setting>
      キーボードを押した時に、自動的にジャンプする場所を指定します。

      onkeyの後に続けて、gotoまたはgosubキーワードを指定してからラベルを記述します。gotoの場合には、単純なプログラムジャンプ。 gosubの場合はサブルーチンジャンプを行ないます。
      goto/gosubキーワードを省略した場合には、gotoキーワードと同等の動作になります。

      onkey命令でラベルを指定すると、それ以降はHSPのウィンドウがアクティブな時にキー入力があるたびに*labelで指定したラベルにジャンプします。

      割り込みジャンプは、stop命令および、wait、 await命令で停止している時に割り込みを受け付けてジャンプを行います。
      また、割り込みによりジャンプを行なった後はシステム変数iparam、wparam、lparamがセットされます。

      割り込み要因 | iparam     | wparam | lparam
      ---------------------------------------------------------
      onkey       | 文字コード | wParam | lParam

      システム変数iparamには、割り込み要因ごとのパラメータが代入されます。
      また、wparam,lparamはWindowsメッセージとして渡されたパラメータがそのまま格納されています。
      イベント割り込み実行の一時的なON/OFFをすることも可能です。

      onkey 0

      で一時的にキー割り込みを停止します。

      onkey 1

      で一時停止したキー割り込みを再開させることができます。
    </Setting>
  </command>
  <command>
    <Name>onclick</Name>
    <Title>クリック割り込み実行指定</Title>
    <Format>
      goto/gosub *label
      *label : ラベル名
    </Format>
    <Setting>
      マウスのボタンを押した時に、自動的にジャンプする場所を指定します。

      onclickの後に続けて、gotoまたはgosubキーワードを指定してからラベルを記述します。gotoの場合には、単純なプログラムジャンプ。 gosubの場合はサブルーチンジャンプを行ないます。
      goto/gosubキーワードを省略した場合には、gotoキーワードと同等の動作になります。

      onclicky命令でラベルを指定すると、 それ以降はHSPのウィンドウ上でマウスクリックがあるたびに*labelで指定したラベルにジャンプします。

      割り込みジャンプは、stop命令および、wait、await命令で停止している時に割り込みを受け付けてジャンプを行います。
      また、割り込みによりジャンプを行なった後はシステム変数iparam、wparam、lparamがセットされます。

      割り込み要因 | iparam         | wparam | lparam
      -------------------------------------------------------
      onclick      | マウスボタンID | wParam | lParam

      システム変数iparamには、割り込み要因ごとのパラメータが代入されます。
      また、wparam,lparamはWindowsメッセージとして渡されたパラメータがそのまま格納されています。
      イベント割り込み実行の一時的なON/OFFをすることも可能です。

      onclick 0

      で一時的に割り込みを停止します。

      onclick 1

      で一時停止した割り込みを再開させることができます。
    </Setting>
  </command>
  <command>
    <Name>onerror</Name>
    <Title>エラー発生時にジャンプ</Title>
    <Format>
      goto/gosub *label
      *label : ラベル名
    </Format>
    <Setting>
      スクリプトが原因で HSP内部でエラーが発生した時に、自動的にジャンプする場所を指定します。

      onerrorの後に続けて、gotoまたはgosubキーワードを指定してからラベルを記述します。gotoの場合には、単純なプログラムジャンプ。 gosubの場合はサブルーチンジャンプを行ないます。
      goto/gosubキーワードを省略した場合には、gotoキーワードと同等の動作になります。

      通常は、エラー発生時にシステムのエラーメッセージダイアログが表示されますが、そのかわりに指定したラベルにジャンプするように設定されます。ジャンプ後は、以下のシステム変数に情報が代入されます。

      wparam : エラー番号
      lparam : エラー発生行番号
      iparam : 0(なし)

      onerror命令によりエラー後の処理を指定した場合であっても、 必要な処理が終わったら、そのままアプリケーションの実行は再開せずに、 なるべくend命令で終了させてください。
      onerror命令は、エラーから回復させるものではありません。
      エラー発生の原因によっては、 HSPのシステム自体が不安定になったり障害が発生することも有り得ます。 onerror命令を使う場面としては、実行ファイル作成時にエラーが発生した場合にアプリケーション側で独自のエラー表示を行ないたい場合や、特定のエラーが発生する場合にだけデバッグのための表示を行なうなどが考えられます。

      終了時ジャンプの一時的なON/OFFをすることも可能です。

      onerror 0

      で一時的に割り込みを停止します。

      onerror 1

      で一時停止した割り込みを再開させることができます。
    </Setting>
  </command>
  <command>
    <Name>exgoto</Name>
    <Title>指定ラベルに条件ジャンプ</Title>
    <Format>
      var,p1,p2,*label
      var    : 比較に使用される変数
      p1     : 比較フラグ
      p2     : 比較値
      *label : ラベル名
    </Format>
    <Setting>
      varで指定された変数に代入されている値と、 p2の比較値により指定したラベルに条件でジャンプします。
      比較方法は、p1の比較フラグが0以上(正値)の場合は(varの値>=p2)が成立した時にジャンプ、p1が-1以下(負値)の場合は (varの値&lt;=p2)が成立した時にジャンプを行ないます。
      varで指定された変数は、整数型である必要があります。別な型で初期化されている場合は、実行時にエラーとなります。
      この命令は、 forなど一部のマクロ処理を高速化するために用意された命令です。
      exgoto命令を単体で使用することもできますが、スクリプトの視認性からもif命令による通常の条件分岐を行なうことを推奨致します。
    </Setting>
  </command>
  <command>
    <Name>on</Name>
    <Title>数値による分岐</Title>
    <Format>
      p1 goto/gosub ラベル0,ラベル1…
      p1=0〜(0) : 分岐のための値
      ラベル0〜 : 分岐先のラベル名
    </Format>
    <Setting>
      on命令は、p1で指定された値が0,1,2…に応じて分岐先を選択します。
      「on 数値 goto」または、「on 数値 gosub」 のような書式で、続いて分岐する先のラベルを1つ以上「,」で区切って記述することができます。
      指定された数値が0の場合はラベル0が、数値が1の場合はラベル1が分岐の対象になります、 以降2,3,4…と対応したラベルを任意の数だけ記述していくことが可能です。
      「on 数値 goto」の場合は goto命令と同じ単純な分岐、「on 数値 gosub」の場合はgosub命令と同じサブルーチンジャンプを行ないます。
      数値がマイナス値か、対応したラベルが指定されていない場合は分岐は行なわれずに次の行に進みます。
      n88系のBASICと違い最初のラベルが数値0に対応しているのでご注意下さい。(n88系BASICでは数値1が最初のラベルになります)
    </Setting>
  </command>
  <command>
    <Name>while</Name>
    <Title>while繰り返し開始</Title>
    <Format>
      p1
      p1=条件式(1) : 繰り返しを行なう条件
    </Format>
    <Setting>
      whileに続く条件が満たされている間だけ、whileからwendまでを繰り返します。
      条件が満たされていない場合はwhileからwendまでを実行しません。
      whileに続く条件を省略した場合は、無限に繰り返しを行ないます。

      a=0
      while a&lt;5
	a=a+1:mes "A="+a=""
	wend=""     ; aが5以下の間だけwhile以下を繰り返す=""

また、_continue、_breakマクロによって再開、脱出が可能です。=""
while〜wend制御は、プリプロセッサのマクロ機能を使って実現されています。=""
CやJava等に近い記述をしたいような場合にお使い下さい。=""
初心者の方には、repeat〜loop命令か、if命令による繰り返し記述を推奨します。=""
    </Setting>
  </command>
  <command>
    <Name>wend</Name>
    <Title>while繰り返し終了</Title>
    <Format></Format>
    <Setting>
      whileで指定した繰り返し区間の終わりを指定します。
      詳しくはwhileマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>until</Name>
    <Title>do繰り返し終了</Title>
    <Format>
      p1
      p1=条件式(1) : 繰り返しを行なう条件
    </Format>
    <Setting>
      untilに続く条件が満たされるまで、doからuntilまでの部分を繰り返します。
      条件が満たされている場合でも、最低一回はdo〜until内を実行します。
      untilに続く条件を省略した場合は、繰り返しを行ないません。

      a=0
      do
      a=a+1:mes "A="+a
      until a>5    ; aが5以上になるまでdo以下を繰り返す

      また、_continue、_breakマクロによって再開、脱出が可能です。
      do〜until制御は、プリプロセッサのマクロ機能を使って実現されています。
      CやJava等に近い記述をしたいような場合にお使い下さい。
      初心者の方には、repeat〜loop命令か、goto命令とif命令を組み合わせた繰り返し記述を推奨します。
    </Setting>
  </command>
  <command>
    <Name>do</Name>
    <Title>do繰り返し開始</Title>
    <Format></Format>
    <Setting>
      untilまでの繰り返し区間の始まりを指定します。
      繰り返し条件は、untilマクロによって記述されます。
      詳しくはuntilマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>for</Name>
    <Title>指定回数繰り返し開始</Title>
    <Format>
      p1,p2,p3,p4
      p1    : 変数名
      p2(0) : 初期値
      p3(0) : 終値
      p4(1) : 増分
    </Format>
    <Setting>
      パラメーターとして変数名、初期値、終値、増分などを指定すると、for〜nextの間を指定回数繰り返します。
      カッコ内は省略した場合の値です。変数名は省略できません。
      指定された変数をカウンターとして使用し、初期値から始まって、１回繰り返すごとに増分を足していきます。終値に達した時点で、繰り返しから抜けます(終値はループに含みません)。
      最初から終値の条件が満たされている場合は、繰り返しを実行しません。
      また、_continue、_breakマクロによって再開、脱出が可能です。

      for a,0,5,1
      mes "A="+a
      next    ; aが0から4の間(５回)繰り返す

      この例では、変数aは0,1,2,3,4と５回繰り返してループを終わります。
      増分にマイナス値を指定することも可能です。

      for a,5,0,-1
      mes "A="+a
      next    ; aが5から1の間(５回)繰り返す

      この場合、変数aは5,4,3,2,1と５回繰り返してループを終わります。

      forマクロで指定され初期値及び、終値は必ず整数を指定する必要があります。
      他の型を指定した場合は、エラーとなります。
      また、増分や終値の指定によっては無限ループになる可能性がありますので注意してください。

      for〜next制御は、プリプロセッサのマクロ機能を使って実現されています。
      CやJava等に近い記述をしたいような場合にお使い下さい。
      初心者の方には、repeat〜loop命令か、if命令による繰り返し記述を推奨します。forマクロは、 内部でマクロ展開後に特殊なプログラム制御命令exgotoを生成します。
    </Setting>
  </command>
  <command>
    <Name>next</Name>
    <Title>指定回数繰り返し終了</Title>
    <Format></Format>
    <Setting>
      forで指定した繰り返し区間の終わりを指定します。
      詳しくはforマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>switch</Name>
    <Title>比較ブロック開始</Title>
    <Format>
      p1
      p1 : 比較元
    </Format>
    <Setting>
      switch〜case〜swend は、ブロック内に複数の条件判断と処理をまとめて書くことができる構文です。
      p1で指定する比較元のパラメーターは、変数または式を指定することができます。switch以降は、

      case 比較値

      を置くことで、これ以降に「比較元」が「比較値」と同じだった場合に処理する内容を記述することができます。
      caseは、ブロック内に複数記述することができ、それぞれの比較値ごとの処理を指定できます。caseの比較が正しい場合は、 swbreakが存在するまで以降の命令を実行します。また、caseの替わりに

      default

      を置くと、caseで指定したどの比較値にもあてはまらない条件の場合に以降が実行されます。

      switchブロックが終了した場合は、

      swend

      を必ず最後に書いておく必要があります。
      以下は、switchマクロを使用したスクリプトの例です。

      a=0
      switch a               ; aを比較対象とする
      case 0                 ; aが0だった場合
      mes "A=0"
      swbreak            ; case0の条件実行終了
      case 1                 ; aが1だった場合
      mes "A=1"
      default                ; aが0以外だった場合
      mes "A!=0"
      swbreak
      swend

      この例では、変数aの内容が0か1かそれ以外かで条件分岐を行なっています。
      「case 0」以降は、「swbreak」までが実行されますが、「case 1」の場合は、「swbreak」が存在しないため、「default」以降に実行される「mes "A!=0"」も含めて実行されるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>swend</Name>
    <Title>比較ブロック終了</Title>
    <Format></Format>
    <Setting>
      switchで指定した比較ブロックの終わりを指定します。
      詳しくはswitchマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>default</Name>
    <Title>デフォルト比較指定</Title>
    <Format></Format>
    <Setting>
      switch〜swendの比較ブロック内で、 それまでのcaseにあてはまらない条件の時に実行される処理を指定します。
      詳しくはswitchマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>case</Name>
    <Title>比較値指定</Title>
    <Format>
      p1
      p1 : 比較値
    </Format>
    <Setting>
      switch〜swendの比較ブロック内で、比較元との条件を指定して正しい場合に実行される処理を指定します。
      詳しくはswitchマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>swbreak</Name>
    <Title>比較実行脱出指定</Title>
    <Format></Format>
    <Setting>
      switch〜swendの比較ブロック内から脱出します。
      詳しくはswitchマクロの項を参照してください。
    </Setting>
  </command>
  <command>
    <Name>_continue</Name>
    <Title>マクロループをやり直す</Title>
    <Format></Format>
    <Setting>
      標準マクロによって定義されている繰り返しマクロ、
      while〜wend、do〜until、for〜next間のループをやり直します。
      現在以降の繰り返しブロック内は実行せずに、次の繰り返しから再開されます。
    </Setting>
  </command>
  <command>
    <Name>_break</Name>
    <Title>マクロループを脱出する</Title>
    <Format></Format>
    <Setting>
      標準マクロによって定義されている繰り返しマクロ、
      while〜wend、do〜until、for〜next間のループから抜け出します。
      現在以降の繰り返しブロック内は実行せずに、ループの次にある命令から再開されます。
    </Setting>
  </command>
  <command>
    <Name>foreach</Name>
    <Title>変数の要素数だけ繰り返す</Title>
    <Format>
      p1
      p1=変数名 : ループの対象となる変数
    </Format>
    <Setting>
      配列変数に格納されている要素の数だけ繰り返しを行ないます。
      foreachは、repeat命令と同様にループ開始場所に記述し、 ループの終了場所にloop命令を記述します。
      repeat命令との違いは、指定された配列変数の要素数が繰り返し回数になる点と、モジュール型変数の場合には、delmod命令で削除された要素はループ内容を実行しないという点です。

      例 :
      dim a,10
      foreach a
      mes "#"+cnt+":"+a.cnt
      loop

      ループの中で、システム変数cntを配列要素として指定することで、 すべての要素を繰り返し実行させるような処理を簡潔に書くことができます。
      また、break、continue命令もrepeat命令使用時と同じように機能します。
    </Setting>
  </command>
  <command>
    <Name>oncmd</Name>
    <Title>Windowsメッセージ割り込み実行指定</Title>
    <Format>
      goto/gosub *label,p1
      *label : ラベル名
      p1     : メッセージID
    </Format>
    <Setting>
      指定されたウィンドウメッセージが送られた時に、自動的にジャンプする場所を指定します。

      oncmdの後に続けて、gotoまたはgosubキーワードを指定してからラベルを記述します。
      gotoの場合には、単純なプログラムジャンプ。 gosubの場合はサブルーチンジャンプを行ないます。
      goto/gosubキーワードを省略した場合には、gotoキーワードと同等の動作になります。

      oncmd命令でラベルを指定すると、それ以降はHSPのウィンドウに対してp1のメッセージが送られた時に*labelで指定したラベルにジャンプします。
      oncmd命令は、現在の操作先ウィンドウのみが対象になります。
      複数のウィンドウを作成している場合は、 ウィンドウごとにoncmd命令による登録が可能です。

      既に登録されているウィンドウメッセージが指定された場合は、以前の登録が無効になります。
      また、割り込みの登録は、ウィンドウの初期化とは同期していません。
      一度登録された割り込みは、アプリケーションが終了するまで有効になります。

      割り込みジャンプは、stop命令および、wait、 await命令で停止している時に割り込みを受け付けてジャンプを行います。
      また、割り込みによりジャンプを行なった後はシステム変数iparam、wparam、lparamがセットされます。
      割り込みが発生したウィンドウIDは、 ginfo関数により取得することができます。

      割り込み要因 | iparam       | wparam | lparam
      ---------------------------------------------------------------------
      oncmd        | メッセージID | wParam | lParam

      システム変数iparamには、送信されたメッセージIDが代入されます。
      また、wparam,lparamはWindowsメッセージとして渡されたパラメータがそのまま格納されています。
      割り込みの設定で、 gosubキーワードによるサブルーチンジャンプが発生した場合は、return命令により戻り値を設定することが可能です。
      「return 数値」で、ウィンドウプロシージャーが返す値を指定します。
      return命令にパラメーターを指定しなかった場合には、デフォルトのウインドゥプロシージャーに処理が渡されます。

      イベント割り込み実行の一時的なON/OFFをすることも可能です。

      oncmd 0

      で一時的に割り込みを停止します。

      oncmd 1

      で一時停止した割り込みを再開させることができます。
    </Setting>
  </command>
  <command>
    <Name>else</Name>
    <Title>条件を満たしていなければその行の命令を実行</Title>
    <Format></Format>
    <Setting>
      if命令と組み合わせて使用します。
      詳しくはif命令の解説を参照してください。
    </Setting>
  </command>
  <command>
    <Name>int</Name>
    <Title>整数値に変換</Title>
    <Format>
      (p1)
      p1 : 変換元の値または変数
    </Format>
    <Setting>
      p1で指定された値を整数にしたものを返します。
      値が実数の場合は、小数点以下が切り捨てられます。
      値が文字列の場合は、数値文字列の場合はその数値に、 それ以外は0になります。
    </Setting>
  </command>
  <command>
    <Name>rnd</Name>
    <Title>乱数を発生</Title>
    <Format>
      (p1)
      p1=1〜32768 : 乱数の範囲
    </Format>
    <Setting>
      0から(p1-1)の範囲で整数の乱数値を発生させます。
      p1の値は範囲に含まれません。たとえば、

      例 ：
      a=rnd(10)

      は、変数aに、0〜9までの乱数を代入します。
      rnd関数は、プログラム起動してからは一定のパターンで乱数を発生させます。
      乱数のパターンを一定でないものにする場合は、 randomize命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>strlen</Name>
    <Title>文字列の長さを調べる</Title>
    <Format>
      (p1)
      p1 : 文字列の長さを調べたい文字列かまたは文字列型の変数名
    </Format>
    <Setting>
      p1で指定された文字列または、文字列型変数が持っている文字列の長さを返します。
      文字列が日本語の全角だった場合は、１文字でも２文字分に計算されます。
    </Setting>
  </command>
  <command>
    <Name>length</Name>
    <Title>配列の1次元要素数を返す</Title>
    <Format>
      (p1)
      p1 : 配列を調べる変数
    </Format>
    <Setting>
      p1で指定された変数が持つ配列要素数(1次元)を返します。
      配列要素数が５だった場合は、p1(0)〜p1(4)が存在することになります。
    </Setting>
  </command>
  <command>
    <Name>length2</Name>
    <Title>配列の2次元要素数を返す</Title>
    <Format>
      (p1)
      p1 : 配列を調べる変数
    </Format>
    <Setting>
      p1で指定された変数が持つ配列要素数(2次元)を返します。
      配列要素数が５だった場合は、p1(0,0)〜p1(?,4)が存在することになります。
      配列の次元が存在しない場合は、0が返ります。
    </Setting>
  </command>
  <command>
    <Name>length3</Name>
    <Title>配列の3次元要素数を返す</Title>
    <Format>
      (p1)
      p1 : 配列を調べる変数
    </Format>
    <Setting>
      p1で指定された変数が持つ配列要素数(3次元)を返します。
      配列要素数が５だった場合は、p1(0,0,0)〜p1(?,?,4)が存在することになります。配列の次元が存在しない場合は、0が返ります。
    </Setting>
  </command>
  <command>
    <Name>length4</Name>
    <Title>配列の4次元要素数を返す</Title>
    <Format>
      (p1)
      p1 : 配列を調べる変数
    </Format>
    <Setting>
      p1で指定された変数が持つ配列要素数(4次元)を返します。
      配列要素数が５だった場合は、p1(0,0,0,0)〜p1(?,?,?,4)が存在することになります。配列の次元が存在しない場合は、0が返ります。
    </Setting>
  </command>
  <command>
    <Name>vartype</Name>
    <Title>変数の型を返す</Title>
    <Format>
      (p1)
      p1 : 型を調べる変数、または文字列
    </Format>
    <Setting>
      p1で指定された変数が格納している値の型を調べて返します。
      返される値は、型を示す整数値となります。型の値は、以下の通りです。

      1 : ラベル型
      2 : 文字列型
      3 : 実数型
      4 : 整数型
      5 : モジュール型
      6 : COMオブジェクト型

      プラグイン等で型が拡張されている場合は、これ以外の値が返されます。
      また、p1に文字列を指定した場合には、型を示す型名として扱われます。
      型名は、登録されているものと大文字小文字を含めて完全に一致させる必要があります。

      "int"    : 整数型
      "str"    : 文字列型
      "double" : 実数型
      "struct" : モジュール型

      標準的な型名として、使用できるも文字列は上の通りです。ただし、これ以外にもプラグイン等で型が拡張されている場合は、指定できる型名も追加されます。
    </Setting>
  </command>
  <command>
    <Name>varptr</Name>
    <Title>変数データのポインタを返す</Title>
    <Format>
      (p1)
      p1 : ポインタを調べる変数、または命令
    </Format>
    <Setting>
      p1で指定された変数が格納しているデータがあるメモリアドレスを返します。
      p1に外部拡張命令(#funcで定義されているDLL呼び出し用の命令)を指定した場合には、実際に実行される外部関数のアドレスを返します。
      この関数は、 外部DLLにポインタを渡したい時など特殊な場合に使用するもので、通常は覚えておく必要のないものです。
      varptrによって取得したポインタは、配列の拡張や内容の更新などにより変化する可能性があるため、値を参照する直前で使用するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>gettime</Name>
    <Title>時間・日付を取得する</Title>
    <Format>
      (p1)
      p1=0〜7(0) : 取得するタイプ
    </Format>
    <Setting>
      p1で指定したタイプの日付・時刻情報を返します。
      取得するタイプは以下の通りです。


      0 : 年(Year)
      1 : 月(Month)
      2 : 曜日(DayOfWeek)
      3 : 日(Day)
      4 : 時(Hour)
      5 : 分(Minute)
      6 : 秒(Second)
      7 : ミリ秒(Milliseconds)

      たとえば、


      例 ：
      a=gettime(4)   ; いま何時?

      は、変数aに現在時刻が何時かを代入します。
    </Setting>
  </command>
  <command>
    <Name>str</Name>
    <Title>文字列に変換</Title>
    <Format>
      (p1)
      p1 : 変換元の値または変数
    </Format>
    <Setting>p1で指定された値を文字列にしたものを返します。</Setting>
  </command>
  <command>
    <Name>dirinfo</Name>
    <Title>ディレクトリ情報の取得</Title>
    <Format>
      (p1)
      p1=0〜5 : 取得するタイプ
    </Format>
    <Setting>
      p1で指定したタイプのディレクトリ名を返します。
      取得するタイプは以下の通りです。

      0 : カレント(現在の)ディレクトリ(dir_cur)
      1 : HSPの実行ファイルがあるディレクトリ(dir_exe)
      2 : Windowsディレクトリ(dir_win)
      3 : Windowsのシステムディレクトリ(dir_sys)
      4 : コマンドライン文字列(dir_cmdline)
      5 : HSPTVディレクトリ(dir_tv)

      p1を省略することはできません。
      また、p1に0x10000以上の値を指定した場合は、ビット0〜15までをCSIDL値として特殊フォルダの取得を行ないます。
      これにより、デスクトップ(0x10000)やマイドキュメント(0x10005)等のシステムが管理しているほとんどのフォルダを取得することができます。
      通常は、hspdef.as内で定義されてる「dir_*」マクロを通してご使用ください。
    </Setting>
  </command>
  <command>
    <Name>double</Name>
    <Title>実数値に変換</Title>
    <Format>
      (p1)
      p1 : 変換元の値または変数
    </Format>
    <Setting>
      p1で指定された値を実数にしたものを返します。
      値が文字列の場合は、数値文字列の場合はその数値に、 それ以外は0になります。
    </Setting>
  </command>
  <command>
    <Name>sin</Name>
    <Title>サイン値を返す</Title>
    <Format>
      (p1)
      p1=(0.0) : 角度値(ラジアン)
    </Format>
    <Setting>
      p1のサイン(正弦)値を実数で返します。
      p1で指定する単位はラジアン(2πが360度)になります。
    </Setting>
  </command>
  <command>
    <Name>cos</Name>
    <Title>コサイン値を返す</Title>
    <Format>
      (p1)
      p1=(0.0) : 角度値(ラジアン)
    </Format>
    <Setting>
      p1のコサイン(余弦)値を実数で返します。
      p1で指定する単位はラジアン(2πが360度)になります。
    </Setting>
  </command>
  <command>
    <Name>tan</Name>
    <Title>タンジェント値を返す</Title>
    <Format>
      (p1)
      p1=(0.0) : 角度値(ラジアン)
    </Format>
    <Setting>
      p1のタンジェント(正接)値を実数で返します。
      p1で指定する単位はラジアン(2πが360度)になります。
    </Setting>
  </command>
  <command>
    <Name>atan</Name>
    <Title>アークタンジェント値を返す</Title>
    <Format>
      (p1,p2)
      p1      : Y値
      p2(1.0) : X値
    </Format>
    <Setting>
      p1をY、p2をXの値として、 Y/Xの角度(アークタンジェント値)を実数のラジアン単位(2πが360度)で返します。
      p2を省略した場合は1.0が使用されます。また、p2が0の場合は0.5π(90度)が返されます。
    </Setting>
  </command>
  <command>
    <Name>sqrt</Name>
    <Title>ルート値を返す</Title>
    <Format>
      (p1)
      p1=0.0〜(0.0) : ルートを求める値
    </Format>
    <Setting>
      p1のルート(平方根)値を、実数で返します。
      p1にマイナス値を指定することはできません。
    </Setting>
  </command>
  <command>
    <Name>sysinfo</Name>
    <Title>システム情報の取得</Title>
    <Format>
      (p1)
      p1=0〜 : 取得するタイプ
    </Format>
    <Setting>
      p1で指定したタイプのシステム情報値を返します。
      取得できるタイプは以下の通りです。

      0 : 文字列 OS名とバージョン番号
      1 : 文字列 ログイン中のユーザー名
      2 : 文字列 ネットワーク上のコンピュータ名
      16 : 数値 使用しているCPUの種類(コード)
      33 : 数値 物理メモリサイズの使用量(単位%)
      34 : 数値 全体の物理メモリサイズ
      35 : 数値 空き物理メモリサイズ
      36 : 数値 スワップファイルのトータルサイズ
      37 : 数値 スワップファイルの空きサイズ
      38 : 数値 仮想メモリを含めた全メモリサイズ
      39 : 数値 仮想メモリを含めた空きメモリサイズ
    </Setting>
  </command>
  <command>
    <Name>peek</Name>
    <Title>バッファから1byte読み出し</Title>
    <Format>
      (p1,p2)
      p1=変数 : 内容を読み出す元の変数名
      p2=0〜  : バッファのインデックス(Byte単位)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある1バイト(8bit)の内容を数値として返します。
      関数の戻り値は、0〜255までの整数値になります。
    </Setting>
  </command>
  <command>
    <Name>wpeek</Name>
    <Title>バッファから2byte読み出し</Title>
    <Format>
      (p1,p2)
      p1=変数 : 内容を読み出す元の変数名
      p2=0〜  : バッファのインデックス(Byte単位)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある2バイト(16bit)の内容を数値として返します。
      関数の戻り値は、0〜65535までの整数値になります。
    </Setting>
  </command>
  <command>
    <Name>lpeek</Name>
    <Title>バッファから4byte読み出し</Title>
    <Format>
      (p1,p2)
      p1=変数 : 内容を読み出す元の変数名
      p2=0〜  : バッファのインデックス(Byte単位)
    </Format>
    <Setting>
      変数に保存されたデータメモリ上の任意の場所にある4バイト(32bit)の内容を数値として返します。
      関数の戻り値は、0〜$ffffffffまでの整数値になります。
    </Setting>
  </command>
  <command>
    <Name>callfunc</Name>
    <Title>外部関数の呼び出し</Title>
    <Format>
      (p1,p2,p3)
      p1 : パラメーターが格納されている配列変数
      p2 : 関数アドレス
      p3 : パラメーター数
    </Format>
    <Setting>
      p2で指定されているアドレスをネイティブな関数として呼び出します。
      呼び出しの引数として、p1で指定された数値型配列変数に格納されている値を使用します。p3でパラメーター数を指定することができます。

      例 :
      a.0=1
      a.1=2
      a.2=3
      res = callfunc( a, proc, 3 )

      上の例では、procが示すアドレスの関数を(1,2,3)という引数で呼び出します。
      呼び出した関数の戻り値が、そのままcallfuncの戻り値となります。
      この関数は、自前で関数アドレスを用意して呼び出す特殊な状況に使用するものです。
      通常は使用する必要がありません。また、外部関数呼び出しに失敗した場合には、フリーズや予期しない結果が起こる場合があるので、十分に注意して使用するようにしてください。
    </Setting>
  </command>
  <command>
    <Name>absf</Name>
    <Title>実数の絶対値を返す</Title>
    <Format>
      (p1)
      p1 : 絶対値に変換する実数値
    </Format>
    <Setting>
      p1の絶対値を実数で返します。
      整数の絶対値が必要な場合は、abs関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>abs</Name>
    <Title>整数の絶対値を返す</Title>
    <Format>
      (p1)
      p1 : 絶対値に変換する整数値
    </Format>
    <Setting>
      p1の絶対値を整数で返します。
      実数の絶対値が必要な場合は、absf関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>logf</Name>
    <Title>対数を返す</Title>
    <Format>
      (p1)
      p1=0.0〜(0.0) : 対数を求める値
    </Format>
    <Setting>
      p1の対数(log)値を、実数で返します。
      p1に0を指定した場合は無限大(INF)を返します。
    </Setting>
  </command>
  <command>
    <Name>expf</Name>
    <Title>指数を返す</Title>
    <Format>
      (p1)
      p1=0.0〜(0.0) : 指数を求める値
    </Format>
    <Setting>
      p1の指数(exp)値を、実数で返します。
      オーバーフローした場合は無限(INF)を返し、アンダーフローした場合は0を返します。
    </Setting>
  </command>
  <command>
    <Name>limit</Name>
    <Title>一定範囲内の整数を返す</Title>
    <Format>
      (p1,p2,p3)
      p1 : 対象となる値
      p2 : 最小値
      p3 : 最大値
    </Format>
    <Setting>
      p1に指定した値を、p2〜p3の範囲内に収まる整数に変換したものを返します。
      p1の値がp2よりも小さい場合は、p2の値が返され、p1の値がp3よりも大きい場合にはp3の値が返されます。
      これにより、limit関数が返す値は、必ずp2〜p3の範囲内となります。
      実数の範囲を求める場合には、limitf関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>limitf</Name>
    <Title>一定範囲内の実数を返す</Title>
    <Format>
      (p1,p2,p3)
      p1 : 対象となる値
      p2 : 最小値
      p3 : 最大値
    </Format>
    <Setting>
      p1に指定した値を、p2〜p3の範囲内に収まる実数に変換したものを返します。
      p1の値がp2よりも小さい場合は、p2の値が返され、p1の値がp3よりも大きい場合にはp3の値が返されます。
      これにより、limitf関数が返す値は、必ずp2〜p3の範囲内となります。
      整数の範囲を求める場合には、limit関数を使用してください。
    </Setting>
  </command>
  <command>
    <Name>varuse</Name>
    <Title>変数の使用状況を返す</Title>
    <Format>
      (p1)
      p1 : 使用状況を調べる変数
    </Format>
    <Setting>
      p1に指定した変数の使用状況を返します。
      varuseは、モジュール型やCOMオブジェクト型の変数など、 実態を持たない状況が発生する場合にのみ有効です。
      指定された変数が有効であれば1を、そうでなければ0を返します。
      モジュール型変数であれば、未使用(0)か、初期化済み(1)、または他の変数のクローン(2)かどうかを調べることができます。
      COMオブジェクト型であれば、有効なCOMオブジェクトを保持しているかを調べられます。
    </Setting>
  </command>
  <command>
    <Name>libptr</Name>
    <Title>外部呼出しコマンドの情報アドレスを得る</Title>
    <Format>
      (p1)
      p1 : アドレスを調べるコマンド
    </Format>
    <Setting>
      p1に指定したコマンドの情報アドレスを取得して整数値として返します。
      外部DLL呼び出しコマンドや関数をパラメーターとして指定することで、コマンドに関する情報が格納されているSTRUCTDAT構造体のアドレスを取得することができます。
      STRUCTDAT構造体は、HSPSDK内で以下のように定義されています。

      typedef struct STRUCTDAT {
      short	index;           // base LIBDAT index
      short	subid;           // struct index
      int	prmindex;            // STRUCTPRM index(MINFO)
      int	prmmax;              // number of STRUCTPRM
      int	nameidx;             // name index (DS)
      int	size;                // struct size (stack)
      int	otindex;             // OT index(Module)  / cleanup flag(Dll)
      union {
      void	*proc;       // proc address
      int	funcflag;        // function flags(Module)
      };
      } STRUCTDAT;

      p1にCOM呼び出しコマンドやユーザー定義命令、 ユーザー定義関数を指定した場合も同様にSTRUCTDAT構造体のアドレスが取得されます。
      libptr関数は、HSPが使用している内部データへのアクセスを補助するもので、ここで扱う情報の内容について十分な知識を持った上で使用するようにしてください。
      通常の使用範囲では、この関数を利用したり覚えておく必要はありません。

      STRUCTDAT構造体を参照することで、 外部呼出しDLLのアドレスや、DLLハンドルなどの情報を得ることが可能です。
    </Setting>
  </command>
  <command>
    <Name>comevdisp</Name>
    <Title>COMイベントの内容を確認</Title>
    <Format>
      (p1)
      p1      : 変数名
    </Format>
    <Setting>
      p1で指定された変数(COMオブジェクト型)のイベントサブルーチン内で、イベントのディスパッチID(DISPID)を取得します。
      p1で指定された変数は、comevent命令により初期化されている必要があります。
      また、取得は必ずイベントサブルーチン内で行なう必要があります。
    </Setting>
  </command>
  <command>
    <Name>powf</Name>
    <Title>累乗（べき乗）を求める</Title>
    <Format>
      (p1, p2)
      p1 : 底（0以上）
      p2 : 指数
    </Format>
    <Setting>
      p1をp2乗した値を求めます。結果は実数で与えられます。
      p1は必ず正でなければなりません。負の場合はエラーにはなりませんが、非数（-1.#IND00）が返ります。
      p2は正負どちらでも構いません。また、実数を指定することも可能です。
    </Setting>
  </command>
  <command>
    <Name>getease</Name>
    <Title>イージング値を整数で取得</Title>
    <Format>
      (p1,p2)
      p1(0) : 時間経過値(整数値)
      p2(4096) : 時間経過値の最大(整数値)
    </Format>
    <Setting>
      決められた範囲の数値を任意の計算式で補間するイージング関数の計算結果値を整数で取得します。
      イージング関数を使用する際には、必ず先にsetease命令により出力される最小値、最大値および計算式を設定しておく必要があります。
      p1で指定する時間経過値は、0から始まる整数値で、時間経過値の最大(p2パラメーター)までを指定することで、イージング関数の計算結果を返します。
      最大値(p2パラメーター)を省略した場合は、4096が使用されます。
      通常は、時間経過値がマイナスの値だった場合は、0とみなされます。また、時間経過値が最大値(p2パラメーター)を超えた場合も、最大値として扱われます。
      (ただし、setease命令による計算式のタイプ設定で、ease_loop(補間のループ)を加算した場合は、範囲外の値も含めて補間のループ(繰り返し)を行ないます。)
    </Setting>
  </command>
  <command>
    <Name>geteasef</Name>
    <Title>イージング値を実数で取得</Title>
    <Format>
      (p1,p2)
      p1(0) : 時間経過値(実数値)
      p2(1.0) : 時間経過値の最大(実数値)
    </Format>
    <Setting>
      決められた範囲の数値を任意の計算式で補間するイージング関数の計算結果値を実数で取得します。
      イージング関数を使用する際には、必ず先にsetease命令により出力される最小値、最大値および計算式を設定しておく必要があります。
      p1で指定する時間経過値は、0から始まる実数値で、時間経過値の最大(p2パラメーター)までを指定することで、イージング関数の計算結果を返します。
      最大値(p2パラメーター)を省略した場合は、1.0が使用されます。
      通常は、時間経過値がマイナスの値だった場合は、0とみなされます。また、時間経過値が最大値(p2パラメーター)を超えた場合も、最大値として扱われます。
      (ただし、setease命令による計算式のタイプ設定で、ease_loop(補間のループ)を加算した場合は、範囲外の値も含めて補間のループ(繰り返し)を行ないます。)
      geteasef命令はより細かいイージング関数の計算結果を取得します。通常の座標値など整数で渡される値を取得する場合は、getease関数を使用した方が高速になります。
    </Setting>
  </command>
  <command>
    <Name>getkey</Name>
    <Title>キー入力チェック</Title>
    <Format>
      p1,p2
      p1=変数   : 読み込むための変数
      p2=1〜(1) : キーコード
    </Format>
    <Setting>
      キーボード及びマウスボタンの状態をチェックして変数に代入します。指定したボタンが押されていれば、1を代入し、押されていなければ0が代入されます。
      キーコードで指定する値の詳細は、以下の通りです。

      キーコード : 実際のキー
      ------------------------------------------
      1    : マウスの左ボタン
      2    : マウスの右ボタン
      3    : キャンセル（[CTRL]+[BREAK]）
      4    : ３ボタンマウスのまん中のボタン
      8    : [BACKSPACE]（PC98の[BS]）
      9    : [TAB]
      13    : [ENTER]
      16    : [SHIFT]
      17    : [CTRL]
      18    : [ALT]（PC98の[GRPH]）
      20    : [CAPSLOCK]
      27    : [ESC]
      32    : スペースキー
      33    : [PAGEUP]（PC98の[ROLLDOWN]）
      34    : [PAGEDOWN]（PC98の[ROLLUP]）
      35    : [END]（PC98の[HELP]）
      36    : [HOME]（PC98の[HOMECLR]）
      37    : カーソルキー[←]
      38    : カーソルキー[↑]
      39    : カーソルキー[→]
      40    : カーソルキー[↓]
      48〜57    : [0]〜[9]（メインキーボード）
      65〜90    : [A]〜[Z]
      96〜105    : [0]〜[9]（テンキー）
      112〜121    : ファンクションキー [F1]〜[F10]

      この表に載っているキー以外でも、取得できる場合があります。(サンプルを実行するとキーコードを調べることができます。)
    </Setting>
  </command>
  <command>
    <Name>mouse</Name>
    <Title>マウスカーソル座標設定</Title>
    <Format>
      p1,p2
      p1,p2 : 設定するX,Y座標
    </Format>
    <Setting>
      マウスカーソルをp1,p2で指定した座標に変更します。
      指定する座標は、  ウィンドウ内の座標ではなくディスプレイでの座標(X=0〜ginfo_dispx/Y=0〜ginfo_dispy)を指定します。
      p1または、p2が-1の場合は、HSPウィンドウ上でのマウスカーソルの表示をOFFにします。
      p1やp2の指定を省略した場合は、現在の座標がそのまま適用されます。
      マウスカーソルの表示をOFFにした後は、p1とp2を省略した「mouse」のみを実行すると再び表示されるようになります。

      マウスカーソル表示の設定は、システムの内部カウンタにより制御されています。
      OFFにした表示を、再度表示するためには、OFFにした回数分だけ表示のリクエストを行なう必要があるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>randomize</Name>
    <Title>乱数発生の初期化</Title>
    <Format>
      p1
      p1=0〜(不定) : 乱数の初期化パラメーター
    </Format>
    <Setting>
      rnd関数で発生させる乱数のパターンを初期化します。

      p1に同じ値を指定して初期化された乱数は、常に同じパターンで乱数を発生させられます。
      p1を省略した場合は、 Windowsのタイマから得られた不定な値を使って初期化します。これによって、毎回まったく違う乱数を発生させることができます。
    </Setting>
  </command>
  <command>
    <Name>stick</Name>
    <Title>キー入力情報取得</Title>
    <Format>
      p1,p2,p3
      p1=変数    : 読み込むための変数
      p2=0〜(0)  : 非トリガータイプキー指定
      p3=0〜1(1) : ウィンドウアクティブチェックON/OFF
    </Format>
    <Setting>
      よく使われるキーボード及びマウスボタンの状態をまとめてチェックして変数に代入します。

      stick命令が実行されると以下のような複数のボタン情報が１つの数値として、p1で指定した変数に代入されます。

      1 : カーソルキー左(←)
      2 : カーソルキー上(↑)
      4 : カーソルキー右(→)
      8 : カーソルキー下(↓)
      16 : スペースキー
      32 : Enterキー
      64 : Ctrlキー
      128 : ESCキー
      256 : マウスの左ボタン
      512 : マウスの右ボタン
      1024 : TABキー

      何もボタンが押されていない場合には0が代入されます。

      もし複数のボタンが同時に押されていた場合には、それらの数値がすべて加算されます。
      たとえば、カーソルキーの右とスペースキーが同時に押されている場合には、4+16の20が変数に読み込まれます。
      この数値をif命令などでチェックする場合には、演算子「&amp;」が役に立ちます。

      例 :
      stick a,0            ; 変数aにキー状態を読み出し
      if a&amp;16 : goto *spc  ; スペースが押されたか?
      if a&amp;32 : goto *ent  ; Enterが押されたか?

      このように「変数&amp;キー情報」で複数のボタン情報が入った数値から、 １つだけのキー情報を取り出すことができます。

      stick命令は、 getkey命令によく似ていますが、最大の違いはボタンが押された瞬間だけを検出する点です。つまり、ボタンが押された時に１度だけ押されている情報を返し、あとは押されているボタンをはなすまでは、押されていることになりません。

      ただし、p2の非トリガータイプキー指定により、押しっぱなしであっても情報を検出することができるようになります。

      p2に押しっぱなしでも検出されるキーのコード(上の表にあるコードです。 複数の場合はそれぞれの数値を加えます)を指定すると、 そのキーだけはボタンが押されている間ずっと検出されるようになります。

      この命令は、非常に複雑に見えますがキーを使ったスクリプトを作る際にとても便利な機能となるでしょう。
      たとえば、シューティングゲームを思い浮かべてみてください。自分の機体は上下左右の方向にボタンが押されている間ずっと移動しなければなりません。しかし、ミサイルを発射するボタンは１回押してはなすまでは次の弾は発射されません。
      このような場合には、上下左右のキーだけは非トリガータイプのキーに指定して、それ以外は１度だけ押された情報を返すようにすればいいわけです。

      また、p3でウィンドウがアクティブでない場合は入力を無効にする機能をON/OFFすることができます。
      p3が1か省略された場合は、HSPウィンドウがアクティブでない場合にはキー入力が無効になります。
      p3が0の場合は、すべての状況下でキー入力を行ないます。
    </Setting>
  </command>
  <command>
    <Name>logmes</Name>
    <Title>デバッグメッセージ送信</Title>
    <Format>
      "message"
      "message" : ログに記録するメッセージ
    </Format>
    <Setting>
      デバッグウィンドウ表示時に、"message"の内容をデバッグログに記録します。
      ある時点での変数の内容や、通過チェックなどに利用できます。
      スクリプトエディタからデバッグウィンドウの表示モードを設定するか、assert命令によってデバッグウィンドウを表示させておく必要があります。
      実行ファイル作成時は、この命令は無効になります。
    </Setting>
  </command>
  <command>
    <Name>assert</Name>
    <Title>デバッグウィンドウ表示</Title>
    <Format>
      p1
      p1(0) : デバッグ時の条件式
    </Format>
    <Setting>
      プログラムを一時的に中断してデバッグウィンドウを表示します。
      p1に条件式が指定された場合には、p1の条件が正しくない場合にのみデバッグウィンドウを表示します。
      (p1には、通過する時の条件式を書くことになるので注意してください。)

      assert a>5  ; aが5以下の時にデバッグする

      実行ファイル作成時は、この命令は無効になります。
    </Setting>
  </command>
  <command>
    <Name>mcall</Name>
    <Title>メソッドの呼び出し</Title>
    <Format>
      p1,p2,p3…
      p1 : 変数名
      p2 : メソッド名
      p3 : パラメーター
    </Format>
    <Setting>
      p1で指定された変数の型に応じてメソッドを呼び出します。
      p1の変数にCOMオブジェクト型を指定することで、COMオートメーションのメソッドを呼び出すことが可能です。
      p2でメソッド名(文字列)または、ディスパッチID(DISPID)を指定して、p3以降に引数を指定します。
      p3以降のパラメーター数や、型はそのまま適切に変換されメソッドに渡されます。
      メソッドを実行した結果の返値は、comres命令で設定された変数に代入されます。
      また、メソッド実行が成功した場合にはシステム変数 statは0になり、実行エラーが起こった場合には、 システム変数statに結果コード(HRESULT)が代入されます。

      mcall命令は、拡張された変数の型を用意することで、 新しい機能を提供することが可能です。標準では、COMオブジェクト型のみに対応しています。
    </Setting>
  </command>
  <command>
    <Name>setease</Name>
    <Title>イージング関数の計算式を設定</Title>
    <Format>
      p1,p2,p3
      p1 : 出力される最小値(実数値)
      p2 : 出力される最大値(実数値)
      p3 : 計算式のタイプ値
    </Format>
    <Setting>
      決められた範囲の数値を任意の計算式で補間するイージング関数の設定を行ないます。
      ここで指定された設定は、イージング関数(getease,geteasef)で値を取得する際に反映されます。
      計算式のタイプ値には、以下を指定することができます。

      マクロ名                補間内容
      ------------------------------------------------------------
      ease_linear		リニア(直線補間)
      ease_quad_in		加速(Quadratic)
      ease_quad_out		減速(Quadratic)
      ease_quad_inout		加速→減速(Quadratic)
      ease_cubic_in		加速(Cubic)
      ease_cubic_out		減速(Cubic)
      ease_cubic_inout	加速→減速(Cubic)
      ease_quartic_in		加速(Quartic)
      ease_quartic_out	減速(Quartic)
      ease_quartic_inout	加速→減速(Quartic)
      ease_bounce_in		バウンス効果(入)
      ease_bounce_out		バウンス効果(出)
      ease_bounce_inout	バウンス効果(入出)
      ease_shake_in		シェイク効果(入)
      ease_shake_out		シェイク効果(出)
      ease_shake_inout	シェイク効果(入出)
      ease_loop		補間のループ(*)

      (*)で示されたタイプは、他のタイプに付加することができます。

      計算式のタイプ値が省略された場合は、以前に設定された値がそのまま使用されます。

      イージング関数は、自然な動きのアニメーションを得るための基本的な計算をサポートします。
      たとえば、X座標が100だった物体を、X座標200まで50フレームのアニメーションで移動させるとします。
      通常であれば、1フレームごとにX座標を100,102,104,106…というように2ずつ加算して新しい座標を得ることでアニメーションとなります。
      しかし、これは直線的な動きにしかなりません。イージング関数は、フレームごとの座標を特定の計算式から取得することができます。
      計算式の設定によって、ゆっくり移動を開始して、加速しながら移動、目標の前でまた減速するといった有機的なアニメーションを実現できるほか、放物線を描いてバウンドするような動き、振り回す(シェイクする)ような動きなど様々な用途に使用することができます。
      イージング関数を使用するには、まずsetease命令で値が変化する範囲と、計算式を指定します。

      ;	イージング関数の設定
      setease 100,200,ease_cubic_inout

      上の例では、100から200までの値を得るためのイージング関数をease_cubic_inoutの計算式で設定します。
      次に、getease または geteasef関数により実際の値を取得します。
      geteaseと、geteasefは基本的に同じもので、取得される値が整数値か、実数値かが異なります。
      通常の座標を扱う場合は、整数値として取得しても問題ありません。(イージング関数の内部ではどちらも、実数による計算が行なわれています)

      ;	イージング関数の設定
      setease 100,200,ease_cubic_inout
      i=0
      repeat
      redraw 0
      color 0,0,0:boxf	; 画面をクリア
      x = getease(i,50)	; イージング値の取得(整数)
      color 255,255,255
      pos x,100 : mes "●"
      redraw 1
      await 30
      i=i+1
      loop

      getease関数の引数は、getease(時間経過値,最大値)となります。
      時間経過値は、0から始まる整数値で、最大値で指定された値までを指定します。
      つまり上の例で言えば、getease(0,50)は、setease命令で設定した100から200までの範囲でのスタート値、つまり100が返されます。
      時間経過値が増えるごとに、100から200に向けて返される値も増加していきます。そして、getease(50,50)になった時に200が返るような計算式になっています。

      時間経過値が0の時 = setease命令で指定した出力最小値が返される
      時間経過値が最大値の時 = setease命令で指定した出力最大値が返される

      最大値のパラメーターを省略した場合は、4096が使用されます。
      geteasef関数の場合も、引数はgeteasef(時間経過値,最大値)と変わりません。
      ただし、時間経過値、最大値ともに実数を使用することができ、より細かい精度でイージング関数を利用できます。また、geteasef関数で最大値のパラメーターを省略した場合は、1.0が使用されます。

      通常は、時間経過値がマイナスの値だった場合は、0とみなされます。また、時間経過値が最大値を超えた場合も、最大値として扱われます。
      ただし、setease命令による計算式のタイプ設定で、ease_loop(補間のループ)を加算した場合は、範囲外の値も含めて補間のループ(繰り返し)を行ないます。補間のループでは、時間経過値にしたがって出力最小値、出力最大値を往復するような動きになります。

      イージング関数は、馴れないうちは結果が想像しにくいところがありますが、使いこなすことで高度なアニメーションを手軽に利用することができる便利な機能です。
      また標準で内蔵されている命令のため、HSP3DishやHGIMG4などあらゆるランタイムでも同様に呼び出すことができます。
    </Setting>
  </command>
  <command>
    <Name>getstr</Name>
    <Title>バッファから文字列読み出し</Title>
    <Format>
      p1,p2,p3,p4,p5
      p1=変数   : 内容を読み出す先の変数名
      p2=変数   : バッファを割り当てた変数名
      p3=0〜    : バッファのインデックス(Byte単位)
      p4=0〜255 : 区切りキャラクタのASCIIコード
      p5=0〜(1024) : 読み出しを行なう最大文字数
    </Format>
    <Setting>
      メモリ上のバッファの任意の場所にある内容を文字列として変数に読み出します。
      文字列は、00というコードか、改行コードがあるまで読み出されます。改行コードは文字列には含まれません。

      また、区切りキャラクタコードを指定することができ任意の文字で区切られた文字列を取り出すこともできます。

      この命令で読み出されたByte数は自動的に strsizeというシステム変数に代入されます。strsizeは、次のインデックスまでの移動量を得る時に使用します。

      たとえば、変数bのバッファに'A' 'B' 'C' ',' 'D' 'E' 'F' 00(終了コード)というデータが入っている場合、

      getstr a,b,0,','

      を実行すると、変数aの内容は、'A' 'B' 'C' の部分が読み出されて"ABC"という文字列になり、strsize は4になります。

      p5パラメーターにより、読み出しを行なう最大文字数(byte数)を指定することができます。
      p5パラメーターが省略された場合には、1024文字(byte)までの読み出しを行ないます。
      (p1で指定された変数のバッファは自動的に確保されるので、sdim命令等でバッファの設定を行なっておく必要はありません。)

      この命令は、複数行を含むテキスト文字列データや、特定の文字で区切られたデータを効率よく切り出すためのものです。
      複数行を含むテキストを扱うためには、他にもメモリノートパッド命令セットがあります。また、文字列から特定数の文字を取り出すためには、strmid命令が用意されています。
    </Setting>
  </command>
  <command>
    <Name>noteadd</Name>
    <Title>指定行の追加・変更</Title>
    <Format>
      p1,p2,p3
      p1=文字列  : 追加・変更をする文字列または変数名
      p2=0〜(-1) : 追加するインデックス
      p3=0〜1(0) : 上書きモード指定(0=追加・1=上書き)
    </Format>
    <Setting>
      メモリノートパッドの内容を追加・変更します。

      p1に追加・変更するための文字列を指定します。p2で、対象となるインデックスを指定します。
      p2パラメータを省略するか、-1を指定すると最終行が対象になります。
      p3パラメータで、追加か上書きかを指定します。省略するか、0を指定すると、追加モードとなり、対象となるインデックス以降が１つづつシフトします。
      p3が1の場合は、上書きモードとなり、 対象となるインデックスの内容は消去され、指定した文字列に置き換えられます。

      noteaddは、 変数バッファにsdim命令などであらかじめ確保された容量を超えて内容を追加しようとした場合は、自動的に確保容量を増加させて格納します。
      つまり、「sdim a,64」 で６４文字までしか記憶できないメモリバッファであっても、追加するサイズに応じて自動的にメモリサイズを調節して安全に記憶させることができます。

      メモリノートパッド命令(noteget,noteadd,notedel,noteinfo)を使用するためには、最初にnotesel命令で対象となるバッファを設定しなければなりません。
    </Setting>
  </command>
  <command>
    <Name>notedel</Name>
    <Title>行の削除</Title>
    <Format>
      p1
      p1=0〜 : 削除するインデックス
    </Format>
    <Setting>
      メモリノートパッドの指定したインデックスを削除します。
      p1で指定したインデックスの内容は削除され、以降のインデックスが１つづつシフトします。

      メモリノートパッド命令(noteget,noteadd,notedel,noteinfo)を使用するためには、最初にnotesel命令で対象となるバッファを設定しなければなりません。
    </Setting>
  </command>
  <command>
    <Name>noteget</Name>
    <Title>指定行を読み込み</Title>
    <Format>
      p1,p2
      p1=変数   : 読み出し先の変数名
      p2=0〜(0) : 読み出すインデックス
    </Format>
    <Setting>
      メモリノートパッド内の、p2で指定したインデックスの内容をp1で指定された変数に代入します。メモリノートパッド内の任意の行にある内容を読み出すことができます。

      インデックスは0から始まるので注意してください。
      p1で指定する変数には、変数バッファにsdim命令などであらかじめ確保された容量を超えて内容を追加しようとした場合は、自動的に確保容量を増加させて格納します。また、p1の変数は強制的に文字列型に変更されます。

      メモリノートパッド命令(noteget,noteadd,notedel,noteinfo)を使用するためには、最初にnotesel命令で対象となるバッファを設定しなければなりません。
    </Setting>
  </command>
  <command>
    <Name>noteinfo</Name>
    <Title>メモリノートパッド情報取得</Title>
    <Format>
      (p1)
      p1(0) : 情報取得モード
    </Format>
    <Setting>
      noteinfo関数は、現在対象となっているメモリノートパッドについての情報を取得します。
      p1で情報取得モードを指定します。また、それぞれのモードに対応したマクロが定義されています。

      モード : マクロ    内容
      -----------------------------------------------------------
      0   : notemax   全体の行数
      1   : notesize  全体の文字数(バイト数)

      notemaxマクロは、 複数行の文字列ですべての行に対して繰り返し処理を行ないたい場合などに使用します。
      全体の行数とは、つまりメモリノートパッド内にある要素の数です。
      「APPLE」「ORANGE」「GRAPE」という行がある場合には、3になります。
      この場合、インデックスは0〜2までになります。

      メモリノートパッド命令(noteget,noteadd,notedel,noteinfo)を使用するためには、最初にnotesel命令で対象となるバッファを設定しなければなりません。
    </Setting>
  </command>
  <command>
    <Name>notesel</Name>
    <Title>対象バッファ指定</Title>
    <Format>
      p1
      p1=変数 : バッファを割り当てた変数名
    </Format>
    <Setting>
      p1で指定した変数をメモリノートパッド命令のバッファに設定します。

      p1で指定した変数は、強制的に文字列型に変更されます。
      他のメモリノートパッド命令(noteget,noteadd,notedel,noteinfo)を使用するためには、最初に notesel命令で対象となるバッファを設定しなければなりません。
    </Setting>
  </command>
  <command>
    <Name>noteunsel</Name>
    <Title>対象バッファの復帰</Title>
    <Format></Format>
    <Setting>
      noteunsel命令は、notesel命令で対象となるバッファを設定する前に設定されていたバッファ設定に戻します。
      noteunsel命令は必ず入れておく必要はありませんが、notesel命令で設定したバッファを使い終わった後に入れておくことで、noteselによるバッファ指定が多重に行なわれることを防止します。
    </Setting>
  </command>
  <command>
    <Name>strmid</Name>
    <Title>文字列の一部を取り出す</Title>
    <Format>
      (p1,p2,p3)
      p1=変数名 : 取り出すもとの文字列が格納されている変数名
      p2=-1〜   : 取り出し始めのインデックス
      p3=0〜    : 取り出す文字数
    </Format>
    <Setting>
      p1で指定した文字列型変数の中から、 p2,p3で指定した条件で文字を取り出したものを返します。
      p2で取り出し始めるインデックスを指定します。これは、文字列の始まり１文字目を0として、1,2,3...と順番に増えていくものです。1から始まりではないので注意してください。
      p3で取り出す文字数を指定します。実際に格納されている文字数よりも多く指定した場合は、実際の文字数までが取り出されます。
      また、p2に-1を指定すると文字列の右からp3で指定した文字数だけ取り出します。
    </Setting>
  </command>
  <command>
    <Name>instr</Name>
    <Title>文字列の検索をする</Title>
    <Format>
      (p1,p2,"string")
      p1=変数名 : 検索される文字列が格納されている文字列型変数名
      p2=0〜(0) : 検索を始めるインデックス
      "string"  : 検索する文字列
    </Format>
    <Setting>
      p1で指定した文字列型変数の中に、"string"で指定した文字列があるかどうか調べて、インデックスを返します。

      指定した文字列が見つかった場合には、インデックス値が返されます。これは、文字列の始まり１文字目を0として、1,2,3...と順番に増えていくものです(strmid命令で指定するインデックスと同様です)。
      1から始まりではないので注意してください。
      (p2を指定した場合、インデックスはp2を起点(0)とするものになります。)
      (p2がマイナス値の場合は常に-1が返されます。)
      もし、指定した文字列が見つからなかった場合には-1が返されます。
    </Setting>
  </command>
  <command>
    <Name>notesave</Name>
    <Title>対象バッファ保存</Title>
    <Format>
      "filename"
      "filename" : 書き込みファイル名
    </Format>
    <Setting>
      メモリノートパッド命令のバッファの内容を指定したファイルにテキストファイルとして保存します。
      必ず最初にnotesel命令で対象となるバッファを設定する必要があるので注意してください。
      notesave命令は、指定バッファに含まれる文字列の長さで保存します。
    </Setting>
  </command>
  <command>
    <Name>noteload</Name>
    <Title>対象バッファ読み込み</Title>
    <Format>
      "filename",p1
      "filename" : 読み込みファイル名
      p1(-1)     : 読み込みサイズの上限値
    </Format>
    <Setting>
      指定したファイルをメモリノートパッド命令のバッファに読み込みます。
      通常は、テキストファイルを読み込み、メモリノートパッド命令で読み出す対象とします。
      メモリノートパッド命令のバッファは、自動的にファイルのサイズに従って確保サイズが調節されるため、バッファのサイズをあらかじめ指定しておく必要はありません。
      p1で、読み込むファイルの最大サイズを指定することができます。
      指定を省略またはマイナス値にした場合は、どんなサイズでも読み込みます。
      テキストファイル以外のファイルを読み込むことも可能です。
      必ず最初にnotesel命令で対象となるバッファを設定する必要があるので注意してください。
    </Setting>
  </command>
  <command>
    <Name>getpath</Name>
    <Title>パスの一部を取得</Title>
    <Format>
      (p1,p2)
      p1=文字列 : 取り出す元の文字列
      p2=0〜    : 情報のタイプ指定
    </Format>
    <Setting>
      p1で指定したファイルパスを示す文字列をp2で指定したタイプの情報に変換したものを文字列として返します。

      例 :
      a="c:¥¥disk¥¥test.bmp"
      b = getpath(a,8+1)
      mes b
      ↓(結果)
      "test"となる

      タイプ指定の詳細は以下の通りです。

      タイプ : 内容
      -----------------------------------------------------------
      0    : 文字列のコピー(操作なし)
      1    : 拡張子を除くファイル名
      2    : 拡張子のみ(.???)
      8    : ディレクトリ情報を取り除く
      16    : 文字列を小文字に変換する
      32    : ディレクトリ情報のみ

      タイプ値は、合計することで複数指定を行なうことが可能です。
      タイプ16が指定された場合は、すべての英文字列を小文字に変換します。
    </Setting>
  </command>
  <command>
    <Name>strf</Name>
    <Title>書式付き文字列を変換</Title>
    <Format>
      ("format",p1...)
      "format" : 書式指定文字列
      p1       : 書式指定パラメーター
    </Format>
    <Setting>
      整数または実数値を適切な書式で文字列に変換した文字列を返します。
      "format"で、以下のような書式指定文字列を指定します。

      例 :
      a=123
      mes strf("10進[%d]",a)
      mes strf("16進[%x]",a)
      mes strf("10進桁数指定付き[%05d]",a)
      mes strf("16進桁数指定付き[%05x]",a)
      a=sqrt(2)
      mes strf("10進実数[%f]",a)
      mes strf("10進実数桁数指定付き[%3.10f]",a)

      p1以降で指定したパラメーターを示す部分には、「%」に続く指定を行ないます。
      「%d」は整数値を、「%x」は１６進整数値を、「%c」は文字コード、「%f」は実数値をそれぞれ表示させることができます。
      複数のパラメーターを書式で指定した場合は、その数だけ「,」で区切ってパラメーターを続けて記述してください。
      通常の「%」記号を表示したい場合は、「%%」を指定してください。

      例 :
      a=1:b=2.0:c="ABC"
      mes strf("[%03d] [%f] [%s]",a,b,c)

      書式指定文字列は、Cランタイムライブラリがサポートしているsprintfの書式とほぼ同様です。

      %[width][.precision][I64]type

      width : 出力する最小文字数
      precision : 出力する最大文字数
      (typeがfの場合は小数点以下の桁数)
      I64   : 64bit値を示すプレフィックス
      type  : 入力されるパラメーターの型

      のような形式となり、[]内の記述は省略することが可能です。
      typeで指定可能な文字は以下の通りです。

      文字           内容
      ---------------------------------------------
      c     1バイト文字コード
      d	符号付き 10 進整数
      i	符号付き 10 進整数
      u	符号なし 10 進整数
      o	符号なし 8 進整数
      x	符号なし 16 進整数(小文字)
      X	符号なし 16 進整数(大文字)
      e	[sign]dd[d] 形式の符号付きの実数値
      E	[sign]dd[d] 形式の符号付きの実数値(大文字)
      f	dddd.dddd 形式の符号付きの実数値
      (整数部の桁数は、その数値の絶対値によって決定され、
      小数部の桁数は要求される精度によって決定されます。)
      g	書式fまたはeで出力される符号付きの値のうち、
      指定された値および精度を表現できる短い方の書式
      G	書式Gと同様で大文字を使用する
      p	16進数の引数が指すアドレスを出力します
      s	文字列

      書式指定文字列は、1023文字までの文字列のみ認識されますので注意してください。
    </Setting>
  </command>
  <command>
    <Name>cnvwtos</Name>
    <Title>unicodeを通常文字列に変換</Title>
    <Format>
      (p1)
      p1=変数 : 内容を読み出す元の変数名
    </Format>
    <Setting>
      変数に保存されたデータをunicodeとして読み取り、 通常の文字列に変換したものを返します。
      unicodeデータを扱う場合や、外部DLL、 COMオブジェクトとのデータ変換などで使用することができます。
    </Setting>
  </command>
  <command>
    <Name>cnvstow</Name>
    <Title>通常文字列をunicodeに変換</Title>
    <Format>
      p1,"string"
      p1=変数  : 結果を書き込む変数名
      "string" : 変換元の文字列
    </Format>
    <Setting>
      "文字列"で指定されたデータをunicode文字列に変換して変数バッファに保存します。
      unicodeデータを扱う場合や、外部DLL、 COMオブジェクトへのデータ変換などで使用することができます。
    </Setting>
  </command>
  <command>
    <Name>strtrim</Name>
    <Title>指定した文字だけを取り除く</Title>
    <Format>
      (p1,p2,p3)
      p1=変数 : 元の文字列が代入された変数
      p2=0〜3(0) : 除去する位置の指定
      p3=0〜65535(32) : 文字コード
    </Format>
    <Setting>
      p1で指定した変数に格納されている文字列の中から指定した文字だけを取り除きます。
      p2で、除去する位置の指定を行なうことができます。
      p2が省略された場合は、文字列の両端が指定文字だった場合のみ除去されます。
      p3で除去する文字コードを指定することができます。
      p3が省略された場合は、半角スペース(32)となります。

      例 :
      a=" ABC DEF "
      b = strtrim(a,0,' ')
      mes b

      p2で指定する、除去位置を示す値の詳細は以下の通りです。

      タイプ : 内容
      -----------------------------------------------------------
      0    : 両端にある指定文字を除去する(デフォルト)
      1    : 左端にある指定文字を除去する
      2    : 右端にある指定文字を除去する
      3    : 文字列内にあるすべての指定文字を除去する

      p3で指定する文字コードには、全角文字を示す2バイトコードを指定することができます。

      例 :
      s="　こんにちは　全角文字です　"
      zenspace="　"				; 全角スペース
      code = wpeek(zenspace,0)		; 全角スペースのコードを取得
      mes strtrim(s,3,code)
    </Setting>
  </command>
  <command>
    <Name>split</Name>
    <Title>文字列から分割された要素を代入</Title>
    <Format>
      p1,"string",p2...
      p1=変数  : 元の文字列が代入された変数
      "string" : 区切り用文字列
      p2=変数  : 分割された要素が代入される変数
    </Format>
    <Setting>
      指定した文字列で分割された要素を変数に代入します。
      たとえば、「12,34,56」のように「,」で区切られた文字列から、「12」「34」「56」の要素を取り出して、別々の変数に代入することができます。
      p1で、もとの文字列が代入された変数名を指定します。(変数は、文字列型である必要があります)
      "string"に区切るための文字列を指定します。
      p2以降に、分割された要素が代入される変数名を指定します。
      代入される変数は、「,」で区切っていくつでも指定することができます。
      最初に指定した変数から順番に、分割された要素が代入されます。

      例 :
      buf="12,34,56"
      split buf, ",", a, b, c
      mes a
      mes b
      mes c

      指定された変数の数よりも、もともとの要素の数が少ない場合は、残りの変数に空の文字列("")が代入されます。
      指定された変数の数よりも、分割された要素が多い場合は、指定された変数の配列に代入されていきます。

      例 :
      buf="12,34,56,78"
      split buf, ",", results
      repeat stat
      mes "配列("+cnt+")="+results(cnt)
      loop

      実行後に、システム変数statに分割できた数が代入されます。
    </Setting>
  </command>
  <command>
    <Name>strrep</Name>
    <Title>文字列の置換をする</Title>
    <Format>
      p1,"検索文字列","置換文字列"
      p1=変数名 : 検索される文字列が格納されている文字列型変数名
      "検索文字列" : 検索する文字列
      "置換文字列" : 置換する文字列
    </Format>
    <Setting>
      p1で指定した文字列型変数の内容すべてにおいて、
      "検索文字列"で指定した文字列を、"置換文字列"に置き換えます。

      実行後、システム変数statに文字列を置換した回数が代入されます。
    </Setting>
  </command>
  <command>
    <Name>imeinit</Name>
    <Title>IME情報を取得</Title>
    <Format>
      v1,n2
      v1 : IME情報を代入する変数
      n2 : mesboxのID
    </Format>
    <Setting>
      IME情報を取得します。
      n2にmesboxのIDを代入します。
    </Setting>
  </command>
  <command>
    <Name>imeopen</Name>
    <Title>IMEウィンドウを開く</Title>
    <Format>
      v1,n2
      v1 : imeinitに使用した変数
      n2 : 開くか閉じるかを示すフラグ
    </Format>
    <Setting>
      imeinitで取得したIMEを開きます。
      n2を1にするとIMEウィンドウを閉じることができます。
    </Setting>
  </command>
  <command>
    <Name>imestr</Name>
    <Title>IMEに文字列を送る</Title>
    <Format>
      v1,"s2"
      v1 : imeinitに使用した変数
      s2 : IMEに送る文字列
    </Format>
    <Setting>
      IMEに文字列を送ります。
      文字列内にタブや改行があっては行けません。
      文字列には半角文字(英字、かな)、全角文字(英字、ひらがな、カタカナ)が使用できます。
    </Setting>
  </command>
  <command>
    <Name>imesend</Name>
    <Title>IMEにメッセージを送る</Title>
    <Format>
      v1,n2,n3,n4
      v1 : imeinitに使用した変数
      n2 : IMEに送るメッセージ
      n3 : パラメータ1
      n4 : パラメータ2
    </Format>
    <Setting>
      IMEへメッセージを送ります。

      n2の値
      0       候補ウィンドウを開く
      1       候補ウィンドウを閉じる
      2       n3ページのn4番目の候補を選択
      3       候補ウィンドウのn4番目のページを表示
      4       決定(0)、変換実行(1)、戻す(2)、キャンセル(3)(括弧内はn3の値)
      5       候補ウィンドウのサイズを変える(n3:0〜31)
    </Setting>
  </command>
  <command>
    <Name>linesel</Name>
    <Title>mesbox内の一行を選択</Title>
    <Format>
      n1.n2
      n1 : mesboxのID
      n2 : 選択する行
    </Format>
    <Setting>
      mesbox n1 内のn2行を選択します。n2は0から数えます。
      n2を-1にするとカーソルがある行を選択します。
      n2を-2にするとmesbox内の文字全てを選択します。
    </Setting>
  </command>
  <command>
    <Name>selget</Name>
    <Title>mesbox内の選択部分の文字列を取得</Title>
    <Format>
      v1,n2
      v1 : mesbox内の選択されている部分を代入する変数
      n2 : mesboxのID
    </Format>
    <Setting>mesbox n2 の選択されている部分を取得します。</Setting>
  </command>
  <command>
    <Name>draw_icon</Name>
    <Title>アイコンの描画</Title>
    <Format>
      n1,n2,n3,n4
      n1 : 描画するアイコン(get_iconで取得したもの)
      n2 : x座標
      n3 : y座標
      n4 : redrawしないかどうかのフラグ
    </Format>
    <Setting>
      n1で指定したアイコンを座標(x,y)に描画します。
      この命令を使うたびにredrawを行います。複数のアイコンを描画するときは効率が悪いのでn4を1にして、全てのアイコンを書き終えたらredrawを実行してください。
    </Setting>
  </command>
  <command>
    <Name>get_fileicon</Name>
    <Title>ファイルに使用されているアイコンの取得</Title>
    <Format>
      v1,"s2",n3
      v1 : 取得したアイコンを入れる変数
      s2 : ファイル名
      n3 : 取得するもの
    </Format>
    <Setting>
      s2に指定したファイルに使われるアイコンを取得します。


      n3の値
      0       s2のファイルに使われているアイコン
      1       s2のファイルに使われている小さいアイコン
      2       ツリービューで選択されているときのアイコン(s2がフォルダなどの場合)
      4       リストビューで選択されている状態のアイコン
      8       アイコンにリンクのマークを付ける
      $10     s2のファイルに使われるアイコンが含まれているファイル名
      $20     s2のファイルが表示されるときに使われる名前(s2に"B:¥¥"などを使ったとき)
      $40     s2のファイルの種類

      0,1,2,4,8は組み合わせて使うことができます。
    </Setting>
  </command>
  <command>
    <Name>get_icon</Name>
    <Title>アイコンの取得</Title>
    <Format>
      v1,"s2",n3,n4
      v1 : 取得したアイコンを入れる数値変数
      s2 : アイコンを含むファイル名
      n3 : アイコンの番号
      n4 : 小さいアイコンを取得するかどうかのフラグ
    </Format>
    <Setting>
      s2に指定したファイルから、n3番目のアイコンを取得します。
      もしn3番目のアイコンが小さいアイコンをもっているときはn4を1にすると小さいアイコンの方を取得します。
      取得したアイコンはdraw_iconで描画できます。
      アイコン取得に失敗したときは変数に0が代入されます。

      n3を-1にすると、s2がもっているアイコンの数がstatに代入されます。
      n3を-2にすると、s2がもっているアイコン全てを取得します。ただしファイルs2が16個以上のアイコンを持っているときは、変数v1を
      alloc v1,'アイコンの数'×4
      として拡張しておかないとエラーになります。
    </Setting>
  </command>
  <command>
    <Name>getptr</Name>
    <Title>変数のポインタを取得する</Title>
    <Format>
      v1,v2
      v1 : ポインタを代入する変数
      v2 : ポインタを取得する変数
    </Format>
    <Setting>
      変数v2のポインタを取得し、変数v1に代入します。
      取得したポインタはdllへ渡すパラメータなどに使用できます。
    </Setting>
  </command>
  <command>
    <Name>dllproc</Name>
    <Title>外部dllの関数を呼び出す</Title>
    <Format>
      "s1",v2,n3,n4
      s1 : 関数名
      v2 : 関数に渡すパラメータが代入された変数
      n3 : 関数に渡すパラメータの数
      n4 : dllのインスタンス
    </Format>
    <Setting>
      n4に指定したdll内のs1の関数を使用します。
      関数の返り値はシステム変数statに代入されます。
      llmod3内では主用なdllがロードされていて、そのdllを使用する場合はn4に以下の数値を使用できます。

      DLL名          数値(defineされている名前)
      kernel32.dll   0 (D_KERNEL)
      user32.dll     1 (D_USER)
      shell32.dll    2 (D_SHELL)
      comctl32.dll   3 (D_COMCTL)
      comdlg.dll     4 (D_COMDLG)
      gdi32.dll      5 (D_GDI)
    </Setting>
  </command>
  <command>
    <Name>_makewnd</Name>
    <Title>WinAPIのCreateWindowAを呼び出す</Title>
    <Format>
      v1, "s2"
      v1 : CreateWindowに渡すパラメータが代入された変数
      s2 : ウィンドウのクラス名
    </Format>
    <Setting>
      v1に代入されたパラメータを使用してCreateWindowAを呼び出します。
      v1にはx座標, y座標, 幅, 高さ, スタイル, 親ウィンドウのハンドル, dwExStyleの順にパラメータを代入します。
      s2は作成するウィンドウのクラス名です。
      作成したウィンドウのハンドルはv1に代入されます。
      親ウィンドウのハンドルを0にすると_makewndが呼ばれたとき操作対象になっているウィンドウのハンドルが使用されます。
    </Setting>
  </command>
  <command>
    <Name>_objsel</Name>
    <Title>llmod3のモジュールで作成したオブジェクトをアクティブにする</Title>
    <Format>
      n1
      n1 : アクティブにするオブジェクトのID
    </Format>
    <Setting>
      n1に指定したオブジェクトをアクティブにします。
      n1を-1にすると現在アクティブになっているオブジェクトのIDを
      statに代入します。
    </Setting>
  </command>
  <command>
    <Name>_clrobj</Name>
    <Title>llmod3のモジュールで作成したオブジェクトを消去する</Title>
    <Format>
      n1
      n1 : 消去するオブジェクトのID
    </Format>
    <Setting>
      llmod3のモジュールで作成したlistview,progbox,trackbox,treebox,udbtnなどのオブジェクトを消去します。

      ※llmod3で作成したオブジェクトはHSP標準命令のcls、screenなどで消去されません。
      これらの命令を使用したときは_cls、_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>_cls</Name>
    <Title>llmod3のモジュールで作成したものを含む全てのオブジェクトを消去する</Title>
    <Format>
      n1
      n1 : clsに渡すパラメータ
    </Format>
    <Setting>
      llmod3のモジュールで作成したlistview,progbox,trackbox,treebox,udbtnなどのオブジェクトとHSP標準命令で作成したオブジェクトを全て消去します。
      n1は_clsの内部で呼び出されているHSP標準命令のclsに渡すパラメータとして使用されます。

      ※llmod3で作成したオブジェクトはHSP標準命令のcls、screenなどで消去されません。
      これらの命令を使用したときは_cls、_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>charupper</Name>
    <Title>WinAPIのCharUpperAを使い変数内の英字を大文字に変換する</Title>
    <Format>
      v1
      v1 : CharUpperに渡す文字列変数
    </Format>
    <Setting>変数内の英字を大文字に変換します。</Setting>
  </command>
  <command>
    <Name>charlower</Name>
    <Title>WinAPIのCharLowerAを使い変数内の英字を大文字に変換する</Title>
    <Format>
      v1
      v1 : CharLowerに渡す文字列変数
    </Format>
    <Setting>変数内の英字を小文字に変換します。</Setting>
  </command>
  <command>
    <Name>tooltip</Name>
    <Title>ツールチップを付ける</Title>
    <Format>
      n1,n2,n3
      n1 :  button,input,treeboxなどのID
      n2 : ツールチップ上に表示する文字列
      n3 : ツールチップの背景色 (IE3.0以上)
    </Format>
    <Setting>
      オブジェクトにツールチップを付けます。
      ツールチップとはマウスカーソルがbuttonなどのオブジェクト上で一定時間停止したときに現れる小さなウィンドウです。
    </Setting>
  </command>
  <command>
    <Name>strtoint</Name>
    <Title>文字列を数値に変換</Title>
    <Format>
      s1,n2
      s1 : 数値に変換する文字列
      n2 : 基数(2〜36)
    </Format>
    <Setting>文字列を数値に変換します。</Setting>
  </command>
  <command>
    <Name>btnimg</Name>
    <Title>buttonに画像を貼りつける</Title>
    <Format>
      n1, n2, n3, n4, n5, n6
      n1 : イメージを貼りつけるボタンのID(0〜63)
      n2 : イメージが描画されているウィンドウのID(0〜7)
      n3 : イメージの位置
      n4 : イメージの位置
      n5 : イメージの幅
      n6 : イメージの高さ
    </Format>
    <Setting>buttonに画像を貼りつけます。</Setting>
  </command>
  <command>
    <Name>objgray</Name>
    <Title>オブジェクトの使用可、不可設定</Title>
    <Format>
      n1,n2
      n1 : オブジェクトのID
      n2 : 使用可にするか不可するかのフラグ
    </Format>
    <Setting>
      buttonなどのオブジェクトを使用可にしたり、不可にしたりします。
      n1にはbuttonやlistviewなどのIDを代入します。
      n2を0にするとオブジェクトを使用できない状態にし、1にすると使用できる状態にします。
      n2を-1にするとそのオブジェクトが使用可か不可かを調べます。

      この命令を呼び出した後のstatの値
      1       エラー無し
      0,-1    エラー
      n2を-1にしたとき
      1       使用可
      0       使用不可
    </Setting>
  </command>
  <command>
    <Name>p_wndscr</Name>
    <Title>ウィンドウ座標系をスクリーン座標系に変換</Title>
    <Format>
      v1
      v1 : ウィンドウ座標系が入った数値変数
    </Format>
    <Setting>
      ウィンドウ座標系をスクリーン座標系に変換します。
      v1にx座標、y座標を代入しておきます。
      描画対象となっているウィンドを基準にします。
    </Setting>
  </command>
  <command>
    <Name>resizeobj</Name>
    <Title>オブジェクトのサイズ変更</Title>
    <Format>
      n1,v2,n3
      n1 : オブジェクトのID
      v2 : サイズ、位置が入った数値変数
      n3 : 位置、サイズを変更しないかどうかのフラグ
    </Format>
    <Setting>
      オブジェクトn1のサイズを変更します。
      v2には幅、高さ、x座標,y座表の順に代入しておきます。
      n3を1にすると位置を変えずにサイズだけ変更します。
      n3を2にするとサイズを変えずに位置だけ変更します。
    </Setting>
  </command>
  <command>
    <Name>getobjsize</Name>
    <Title>オブジェクトのサイズと位置取得</Title>
    <Format>
      v1,n2
      v1 : オブジェクトのサイズ、位置を取得するための数値変数
      n2 : オブジェクトのID
    </Format>
    <Setting>
      オブジェクトのサイズと位置を取得します。
      n2にはbuttonやlistviewなどのIDを代入します。
      v1にはオブジェクトのサイズ、位置が以下のように代入されます。

      v1.0	幅
      v1.1	高さ
      v1.2	左上のx座標
      v1.3	左上のy座標
      v1.4	右下のx座標
      v1.5	右下のy座標

      各座標はウィンドウ座標系です。
    </Setting>
  </command>
  <command>
    <Name>p_scrwnd</Name>
    <Title>スクリーン座標系をウィンドウ座標系に変換</Title>
    <Format>
      v1
      v1 : スクリーン座標系が入った数値変数
    </Format>
    <Setting>
      スクリーン座標系をウィンドウ座標系に変換します。
      v1にx座標、y座標を代入しておきます。
      描画対象となっているウィンドウを基準にします。
    </Setting>
  </command>
  <command>
    <Name>listview</Name>
    <Title>リストビューの作成</Title>
    <Format>
      n1,n2,n3
      n1 : 幅
      n2 : 高さ
      n3 : スタイル
    </Format>
    <Setting>
      リストビューを作成します。
      リストビューは、Explorerの右側にある様なオブジェクトです。
      この命令を呼び出した後、statにリストビューのIDが代入されます。

      スタイル
      スタイルは以下の値を足して、複数のスタイルを指定することができます。
      0           大きいアイコン表示
      1           詳細表示
      2           小さいアイコン表示
      3           リスト表示
      4           複数選択できないようにする
      8           listviewが選択されていないときでも、選択されているアイテムの色を変える
      $10         昇順でアイテムをソートする
      $20         降順でアイテムをソートする
      $40         セットしたイメージリストをlistview消去時に消去しない(複数のlistviewで同じイメージを使う場合に指定する)
      $80         アイコン表示のとき、アイテムのテキストを折り返さない(デフォルトではテキストは長いと折り返される)
      $100        ?
      $800        ?
      $2000       スクロールバーがつかない
      $4000       欄の名前を表示する部分を付けない

      以下のスタイルはcomctl32.dllのバージョンによっては有効にならない場合があります。
      $10000      リスト表示時に罫線を付ける
      $40000      チェックボックスを付ける
      $100000     欄の名前を表示する所をドラッグ&amp;ドロップできる
      $200000     リスト表示時にアイテムが選択されたときサブアイテムも色を変える
      $400000     アイテムの上にマウスポインタが来たときカーソルを指の形にする
      $800000     アイテムクリックされたときカーソルを指の形にする
      $1000000    スクロールバーを平らなスタイルに変える
      $8000000    $400000,$800000のスタイルを指定したとき、アイテムの上にマウスポインタが来ると下線がつく
      $10000000   $400000,$800000のスタイルを指定したとき、下線がつく


      ※チェックボックスを付けたときのスタイルで、アイテムがチェックされているかを調べるときは以下のようにしてください

      ;list_id : listviewのID
      ;idx : アイテムのインデックス
      prm=list_id,4140,idx,61440
      sendmsg prm
      chk=stat>>12-1
      if chk : dialog ""+idx+"番目のアイテムはチェックされています"

      チェックをはずしたり、つけたりしたいときは以下のようにします。

      dim lvi,9
      idx = 0			;idx番目のアイテム
      if uncheck != 0 {
      lvi = 8,0,0,1&lt;&lt;12,$f000
	} else=""
		lvi = "8,0,0,2"&lt;&lt;12,$f000
	}
	prm = "list_id,4139,idx" :="" getptr="" prm.3,lvi="" :="" sendmsg="" prm=""

※listviewはHSP標準命令のclsやscreen命令では消去されません。_clsまたは_clrobjを使用してください。=""
    </Setting>
  </command>
  <command>
    <Name>listadd</Name>
    <Title>リストビューにアイテムを追加</Title>
    <Format>
      n1,"s2",n3,n4,n5,n6
      n1 : アイテムの位置
      s2 : アイテムのテキスト
      n3 : 欄の番号
      n4 : アイコン番号
      n5 : アイテムの状態
      n6 : アイテムに持たせる数値
    </Format>
    <Setting>
      リストビューのn1番目の位置にアイテムをつけ加えます。
      n3には何番目の欄に追加するかを指定するインデックス、n4にはアイコン番号、n5にはアイテムの状態を入れます。

      欄への追加は、listaddclで欄を追加しているときのみ有効です。
      またアイコン番号は、listiconでアイコンを追加している場合のみ有効になり、欄へ追加するときはアイコン番号は無視されます。

      n6に値を入れてアイテムにその数値を持たせることができます。
      この命令を呼び出した後、statに追加したアイテムのインデックスが代入されます。(-1ならエラー)

      アイテムの状態
      listviewのアイテムの状態には、以下のものがあります。

      状態                     数値
      フォーカスがあっている   1
      選択されている           2
      切り取られた状態         4
      ハイライト               8

      ※ハイライトはlistselで選択状態を解除しないと元に戻りません。
    </Setting>
  </command>
  <command>
    <Name>listdel</Name>
    <Title>リストビューのアイテムを消去</Title>
    <Format>
      n1
      n1 : アイテムのインデックス
    </Format>
    <Setting>
      n1番目のアイテムを消去します。
      n1を-1にすると全てのアイテムを消去します。
    </Setting>
  </command>
  <command>
    <Name>listaddcl</Name>
    <Title>リストビューに欄を追加</Title>
    <Format>
      n1,"s2",n3,n4
      n1 : 欄のインデックス
      s2 : 欄の名前
      n3 : 欄の幅
      n4 : 欄の名前の位置
    </Format>
    <Setting>
      欄を追加します。
      n3を省略したときのデフォルト値は100です。


      n4の値
      0    左寄せ
      1    右寄せ
      2    中央
    </Setting>
  </command>
  <command>
    <Name>listdelcl</Name>
    <Title>欄を消去</Title>
    <Format>
      n1
      n1 : 欄のインデックス
    </Format>
    <Setting>n1番目の欄を消去します。</Setting>
  </command>
  <command>
    <Name>listsel</Name>
    <Title>リストビューのアイテムを選択</Title>
    <Format>
      n1,n2
      n1 : アイテムのインデックス
      n2 : 選択状態のタイプ
    </Format>
    <Setting>
      n1番目のアイテムを選択します。
      n2を-1にすると選択状態を解除します。
      n2を省略するとフォーカスをあわせて、選択状態にします。


      状態                     数値
      フォーカスがあっている   1
      選択されている           2
      切り取られた状態         4
      ハイライト               8
    </Setting>
  </command>
  <command>
    <Name>listget</Name>
    <Title>リストビューのアイテムを取得</Title>
    <Format>
      v1,n2,n3,n4
      v1 : 取得したものを入れる変数
      n2 : アイテムのインデックス
      n3 : 取得するもの
      n4 : 取得するアイテムの状態
    </Format>
    <Setting>
      主にアイテムのインデックスを取得します。
      n3で以下の値を代入すると取得するものが変わってきます。


      n3の値                               n4の値
      1   n2の上のアイテムのindexを取得    0 or 取得するアイテムの状態
      2   n2の下のアイテムのindexを取得    0 or 取得するアイテムの状態
      3   n2の左のアイテムのindexを取得    0 or 取得するアイテムの状態
      4   n2の右のアイテムのindexを取得    0 or 取得するアイテムの状態
      5   n2のテキスト取得                 変数のサイズ or -1
      6   n2のアイテムに持たせた値を取得   0 or 1


      n3を5にしたときはstatにアイテムに持たせた値が入ります。
      n3を5にしたときn4を-1にすると、v1に入っている文字列を使ってアイテムのテキストを再設定できます。
      n3を6にしたときn4を1にすると、v1に入っている値を使ってアイテムに持たせた値を再設定できます。

      n4を以下の値にするとn4で指定した状態のアイテムを(n2+1)番目のアイテムからn3で指定した方向に向かって検索します。(n3を0にすると方向は指定しません)
      n4の状態のアイテムが見つかればv1にアイテムのインデックスが代入されます。
      見つからなかった場合はv1に-1が代入されます。
      n2を-1にすると先頭のアイテムから検索します。


      n4の値
      0    状態は指定しない
      1    フォーカスがあっている
      2    選択されている
      4    切り取られた状態
      8    ハイライト
    </Setting>
  </command>
  <command>
    <Name>listicon</Name>
    <Title>リストビューのアイコンを設定</Title>
    <Format>
      v1,n2,n3
      v1 : アイコンが入った数値変数(get_iconで取得したもの)
      n2 : アイコンの数
      n3 : セットするアイコンの大小
    </Format>
    <Setting>
      リストビューのアイテムのアイコンを設定します。
      アイコンをセットするには、imgモジュールが必要です。

      ※必ず、listview.hspより先にimg.hspをインクルードしてください。

      n3を0にすると大きいアイコンを表示するときのアイコンをセットし、n3を1にすると小さいアイコンを表示するときのアイコンをセットします。

      この命令を呼び出した後、のstatにセットしたアイコンについての情報が入った特別な値が代入されます。(イメージリストと呼ばれるものです。)

      listviewはtreeboxと違って、_clrobjなどでlistviewが消去されると、アイコンをセットして消費したメモリを自動的に開放するので、
      destroy_imglist 'listicon実行後にstatに代入された値'
      を実行する必要はありません。
      ただし、listviewのスタイルに'セットしたイメージリストをlistview消去時に消去しない'を指定している場合は、メモリは自動的に開放されません。このときは、
      destroy_imglist 'listicon実行後にstatに代入された値'
      を実行してください。
    </Setting>
  </command>
  <command>
    <Name>listmax</Name>
    <Title>リストビューのアイテムの数を取得</Title>
    <Format>
      v1,n2
      v1 : リストビュー内のアイテムの数を入れる数値変数
      n2 : フラグ
    </Format>
    <Setting>
      リストビュー内のアイテムの数を取得します。
      n2を1にするとリストビュー内に完全に見えているアイテムの数を取得します。
    </Setting>
  </command>
  <command>
    <Name>listhit</Name>
    <Title>マウスの下にあるアイテムを取得</Title>
    <Format></Format>
    <Setting>
      マウスの下にあるアイテムのインデックスを取得します。

      statにマウスの下にあるアイテムのインデックスが代入されます。
      マウスの下にアイテムが無ければ-1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sel_listview</Name>
    <Title>操作するリストビューを選択</Title>
    <Format>
      n1
      n1 : リストビューのID
    </Format>
    <Setting>
      この命令使用後はn1で指定したリストビューに対して各操作を行います。
      リストビュー新規に作成すると、自動的にそのリストビューが各操作の対象になります。
      複数のリストビューを作成したときは、この命令で操作するリストビューを選択してください。
    </Setting>
  </command>
  <command>
    <Name>progbox</Name>
    <Title>プログレスボックスの作成</Title>
    <Format>
      n1,n2,n3
      n1 : 幅
      n2 : 高さ
      n3 : スタイル
    </Format>
    <Setting>
      プログレスボックスを作成します。
      プログレスボックスは、進捗状況を表示するのに便利です。

      スタイル(comctl32.dllのバージョンが4.70以上でなければ無効です)

      n4の値
      1    進み方がスムーズになります。
      4    垂直に目盛りが進みます。

      この命令を呼び出した後、statにプログレスボックスのIDが代入されます。

      ※progboxはHSP標準命令のclsやscreen命令では消去されません。_clsまたは_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>sel_progbox</Name>
    <Title>操作するプログレスボックスを選択</Title>
    <Format>
      n1
      n1 : プログレスボックスのID
    </Format>
    <Setting>
      この命令使用後はn1で指定したプログレスボックスに対して各操作を行います。
      プログレスボックス新規に作成すると、自動的にそのプログレスボックスが各操作の対象になります。
      複数のプログレスボックスを作成したときは、この命令で操作するプログレスボックスを選択してください。
    </Setting>
  </command>
  <command>
    <Name>progrng</Name>
    <Title>プログレスボックスの範囲を設定</Title>
    <Format>
      n1,n2,n3
      n1 : 最小値
      n2 : 最大値
      n3 : 最大値の拡張フラグ
    </Format>
    <Setting>
      プログレスボックスの範囲の設定をします。
      設定できる値は、最小値が0以上、最大値は65535以下です。
      n3に1を代入すると最大値が$ffffffffまでになります。ただしこの設定はcomctl32.dllのバージョンが4.70以上でなければ無効です。

      この命令を呼び出した後のstatの値
      以前セットしていた範囲 [ 最小値 | (最大値&lt;&lt;16)]の形式="" (n3="0のときのみ")</Setting>
  </command>
  <command>
    <Name>progset</Name>
    <Title>プログレスボックスの各設定</Title>
    <Format>
      n1,n2
      n1 : セットする値
      n2 : セットするタイプ
    </Format>
    <Setting>
      プログレスボックスの各設定を行います。
      セットするタイプは以下の通りです。

      目的                 n1の値          n2の値   progset実行後のstatの値
      進ませる             0               0        進ませる前の位置
      進ませる量のセット   進ませる量      0        以前セットした進ませる量
      位置をセット         セットする位置  1        セットする前の位置
      特定の量を増加させる 増加させる量    2        増加させる前の位置

      (以下のものはcomctl32.dllのバージョンが4.70以上でなければ無効です)
      目盛りの色           色              3        セットする前の色
      目盛りの後ろの色     色              4        セットする前の色
      (色は   r|(g&lt;&lt;8)|(g&lt;&lt;16)   の形式=""
(値が="" 0="" になっている所は省略できる=""

statの値が=""'セットする前の色'となっている所は、セットする前の色がシステムのデフォルトの色だった場合='' -16777216($ff000000)がstatに代入されます。また、色をセットするときに$ff000000を使うとシステムのデフォルトの色に設定できます。=''
    </Setting>
  </command>
  <command>
    <Name>trackbox</Name>
    <Title>トラックボックスの作成</Title>
    <Format>
      n1,n2,n3
      n1 : 幅
      n2 : 高さ
      n3 : スタイル
    </Format>
    <Setting>
      トラックボックスを作成します。
      トラックボックスとはつまみを持ったオブジェクトです。
      決まった選択範囲の中から数値を得たいときなどに使うのに便利です。

      この命令を呼び出した後、statにトラックボックスのIDが代入されます。

      trackboxのスタイル(n4)は以下の値を組み合わせて持つことができます。
      例えば、
      n4=2|8|$100	;または n4=2+8+$100
      trackbox 200,70,n4
      なら垂直で両側に目盛りが付き、ツールチップを持つスタイルになります。

      n4の値
      0       水平
      1       自動で目盛りを付ける
      2       垂直
      4       '水平'のとき  目盛りを上側に付ける
      '垂直'のとき  目盛りを左側に付ける
      8       目盛りを両側に付ける
      $10     目盛りを付けない
      $20     つまみの部分に選択領域を付ける
      $40     $20 のスタイルのとき、つまみが動いても選択領域を固定したままにする
      $80     つまみなし
      $100    つまみがクリックされているときツールチップを付ける(このスタイルは
      comctl32.dllのバージョンによっては効果がない場合があります。)


      ※trackboxはHSP標準命令のclsやscreen命令では消去されません。_clsまたは_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>sel_trackbox</Name>
    <Title>操作するトラックボックスを選択</Title>
    <Format>
      n1
      n1 : トラックボックスのID
    </Format>
    <Setting>
      この命令使用後はn1で指定したトラックボックスに対して各操作を行います。
      トラックボックス新規に作成すると、自動的にそのトラックボックスが各操作の対象になります。
      複数のトラックボックスを作成したときは、この命令で操作するトラックボックスを選択してください。
    </Setting>
  </command>
  <command>
    <Name>trackpos</Name>
    <Title>トラックボックスのつまみの位置の設定と取得</Title>
    <Format>
      n1,n2
      n1 : 設定する位置
      n2 : 位置を取得するフラグ
    </Format>
    <Setting>
      トラックボックスのつまみの位置を設定します。
      n2を1にするとつまみの位置を取得します。

      この命令を呼び出した後のstatの値
      n2を1にするとstatにつまみの位置が代入されます。
      それ以外はstatは0になります。
    </Setting>
  </command>
  <command>
    <Name>trackrng</Name>
    <Title>トラックボックスの範囲の設定と取得</Title>
    <Format>
      n1,n2,n3
      n1 : 最小値
      n2 : 最大値
      n3 : 範囲を取得するフラグ
    </Format>
    <Setting>
      トラックボックスの範囲を設定、取得します。
      n3を1にすると設定範囲の値を取得します。

      この命令を呼び出した後のstatの値
      n3を1にして、n1を1にするとtrackboxの最小位置、n2を1にすると最大位置がstatに代入されます。
      それ以外はstatは0になります。
    </Setting>
  </command>
  <command>
    <Name>trackmrk</Name>
    <Title>トラックボックスの目盛りの設定と取得</Title>
    <Format>
      n1,n2
      n1 : 目盛りをつける位置
      n2 : フラグ
    </Format>
    <Setting>
      トラックボックスの目盛りの位置を設定、取得します。

      n2の値  機能
      0       n1で指定した位置に目盛りを付けます。
      1       付けられている目盛りの数を取得します。
      2       間隔をn1で指定した値にして目盛り付けます。ただし、トラックボックスのスタイルを'自動で目盛りを付ける'(1)にしたときのみ有効です。
      3       n1番目の目盛りの位置を取得します。
      4       付けられている目盛りをすべてクリアします。
    </Setting>
  </command>
  <command>
    <Name>tracksel</Name>
    <Title>トラックボックスの選択範囲の設定と取得</Title>
    <Format>
      n1,n2,n3
      n1 : 最小値
      n2 : 最大値
      n3 : フラグ
    </Format>
    <Setting>
      トラックボックスの選択範囲を設定、取得します。
      ただし、トラックボックス作成時に'つまみの部分に選択領域を付ける'($20)という
      スタイルを指定している場合に限ります。

      n3を0にするとn1-n2の範囲を選択します。
      n3を1にすると開始位置(n1の値)のみをセットします。
      n3を2にすると終了位置(n2の値)のみをセットします。
      n3を3にすると選択範囲をクリアします。

      この命令を呼び出した後のstatの値
      n1、n2をともに0すると選択開始位置がstatに代入されます。
      n1、n2をともに1すると選択終了位置がstatに代入されます。
    </Setting>
  </command>
  <command>
    <Name>treemax</Name>
    <Title>ツリーボックスのアイテムの数を取得</Title>
    <Format>
      v1,n2
      v1 : ツリーボックス内のアイテムの数を入れる数値変数
      n2 : フラグ
    </Format>
    <Setting>
      ツリーボックス内のアイテムの数を取得します。
      n2を1にするとツリーボックス内に完全に見えているアイテムの数を取得します。
    </Setting>
  </command>
  <command>
    <Name>treesel</Name>
    <Title>ツリーボックスのアイテムを選択</Title>
    <Format>
      n1,n2
      n1 : アイテムのID
      n2 : 選択状態のタイプ
    </Format>
    <Setting>
      n1で指定したアイテムを選択します。
      n2に$10を足すとアイテムが子をもっているとき、そのアイテムを収縮します。
      n2に$20を足すとアイテムが子をもっているとき、そのアイテムを展開します。


      n2の値   選択状態
      0        普通のタイプ
      1        DragDropのtargetのようなタイプ
      2        itemを先頭に持っていって選択(家の環境ではならないような... tom)
      +$10     展開
      +$20     収縮
      +$30     逆の状態にする
    </Setting>
  </command>
  <command>
    <Name>treedel</Name>
    <Title>ツリーボックスのアイテムを消去</Title>
    <Format>
      n1
      n1 : アイテムのID
    </Format>
    <Setting>n1で指定したアイテムを消去します。</Setting>
  </command>
  <command>
    <Name>treesort</Name>
    <Title>ツリーボックスのアイテムをソート</Title>
    <Format>
      n1
      n1 : アイテムのID
    </Format>
    <Setting>
      n1で指定したアイテムの子をソートします。
      n1を省略するとトップのアイテムをソートします。
    </Setting>
  </command>
  <command>
    <Name>treeicon</Name>
    <Title>ツリーボックスのアイコンを設定</Title>
    <Format>
      v1,n2
      v1 : アイコンが入った数値変数(get_iconで取得したもの)
      n2 : アイコンの数
    </Format>
    <Setting>
      ツリーボックスのアイテムのアイコンを設定します。
      アイコンをセットするには、imgモジュールが必要です。

      ※必ず、treebox.hspより先にimg.hspをインクルードしてください。

      この命令実行後にstatにセットしたアイコンについての情報が入った特別な値が返されます。(イメージリストと呼ばれるものです。)
      treeboxがいらなくなってtreeboxを消去したときはなるべく
      destroy_imglist 'treeicon実行後にstatに代入された値'
      を実行してください。
      (アイコンをセットするとメモリを消費します。destroy_imglistを実行することでセットして消費したメモリを開放します。)
      treeboxがまだあるうちにdestroy_imglistを実行すると、セットされたアイコンは無効になります。
    </Setting>
  </command>
  <command>
    <Name>treehit</Name>
    <Title>マウスの下にあるアイテムを取得</Title>
    <Format></Format>
    <Setting>
      マウスの下にあるアイテムのIDを取得します。

      statにマウスの下にあるアイテムのIDが代入されます。
      マウスの下にアイテムが無ければ0が代入されます。
    </Setting>
  </command>
  <command>
    <Name>sel_treebox</Name>
    <Title>操作するツリーボックスを選択</Title>
    <Format>
      n1
      n1 : ツリーボックスのID
    </Format>
    <Setting>
      この命令使用後はn1で指定したツリーボックスに対して各操作を行います。
      新規にツリーボックスを作成すると、自動的にそのツリーボックスが各操作の対象になります。
      複数のツリーボックスを作成したときは、この命令で操作するツリーボックスを選択してください。
    </Setting>
  </command>
  <command>
    <Name>treeget</Name>
    <Title>ツリーボックスの各情報を取得</Title>
    <Format>
      v1,n2,n3,n4
      v1 : 取得したものを入れる変数
      n2 : 取得するタイプ
      n3 : n2によって変わる
      n4 : n2によって変わる
    </Format>
    <Setting>
      主にアイテムのIDを取得します。
      n2で以下の値を代入すると取得するものが変わってきます。


      n2の値                               n3の値        n4の値
      0   選択されているｱｲﾃﾑのIDを取得     0             0
      1   次のｱｲﾃﾑのID(同じレベル)を取得   アイテムのID  0
      2   前のｱｲﾃﾑのID(同じレベル)を取得   アイテムのID  0
      3   親ｱｲﾃﾑのIDを取得                 アイテムのID  0
      4   一番目の子どもｱｲﾃﾑのIDを取得     アイテムのID  0
      5   最初に見えているｱｲﾃﾑのIDを取得   アイテムのID  0
      6   アイテムのテキスト取得           アイテムのID  変数のサイズ or -1
      7   アイテムに持たせた値を取得       アイテムのID  0 or 1
      -1  ルートを取得                     0             0


      値が0の所は省略できます。
      n2が6の場合、n4に何文字まで取得するか指定します。63文字以内なら省略できます。
      n2が6のときはstatにtreeaddでアイテムに持たせた値が代入されます。

      n2を6にしたときn4を-1にすると、v1に入っている文字列を使ってアイテムのテキストを再設定できます。
      n2を7にしたときn4を1にすると、v1に入っている値を使ってアイテムに持たせた値を再設定できます。
    </Setting>
  </command>
  <command>
    <Name>treeadd</Name>
    <Title>treeboxにアイテムを追加</Title>
    <Format>
      n1,"s2",n3,n4,n5,n6
      n1 : 親アイテムのID
      s2 : アイテムのテキスト
      n3 : アイテムの追加の仕方
      n4 : アイテムが収縮している時のアイコン番号
      n5 : アイテムが展開している時のアイコン番号
      n6 : アイテムに持たせる数値
    </Format>
    <Setting>
      ツリーボックスにn1を親にしてアイテムを加えます。
      n1に0を代入すると一番目のアイテムになります。
      n3にはどのようにアイテムを追加するか、n4には収縮している時のアイコン番号(0から)、n5には展開しているときのアイコン番号(0から)を入れます。

      どのように追加するかは、1で先頭の子として追加、0または2で一番最後の子として追加、3でソートして追加、となります。
      アイコンはtreeiconでセットします。

      n6に値を入れてアイテムにその数値を持たせることができます。
      n6で設定した数値はtreegetで取得できます。

      この命令を呼び出した後、statに追加したアイテムのIDが代入されます。(0ならエラー)
    </Setting>
  </command>
  <command>
    <Name>treebox</Name>
    <Title>treeboxの作成</Title>
    <Format>
      n1,n2,n3
      n1 : 幅
      n2 : 高さ
      n3 : スタイル
    </Format>
    <Setting>
      ツリーボックスを作成します。
      ツリーボックスとはエクスプローラーの左側にあるようなものです。
      スタイルは以下の値を組み合わせて使うことができます。

      n3の値
      1       アイテムが子を持つとき'+','-'のマークが付く
      2       アイテムとアイテムを繋ぐ線がつく
      4       最初のアイテムに線が付く(2が指定されているときのみ)
      8       ※この数字は使わないで下さい。
      $10     ※この数字は使わないで下さい。
      $20     ツリーボックスが選択されていないときにも選択されているアイテムが分かるように色が付く
      $40     ※よく分からない(tom)
      $80     アイテムがツリーボックスからはみ出ていてもツールチップがつかない
      ※以下のスタイルはcomctl32.dllのバージョンによっては使用できないものもあります。
      $100    項目にチェックボックスが付く
      $200    マウスがアイテムの上に来ると下線が付く
      $400    マウスでクリックされたアイテムのみが展開される
      $800    ※よく分からない(tom)
      $1000   スタイル2 が指定されていないとき、選択されたアイテムの背景が変わる
      $2000   アイテムがツリーボックス内に収まらない時でも、スクロールバーが付かない
      $4000   ※よく分からない(tom)
      $8000   水平スクロールバーが付かない


      この命令を呼び出した後、statにツリーボックスのIDが代入されます。

      ※treeboxはHSP標準命令のclsやscreen命令では消去されません。_clsまたは_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>udbtn</Name>
    <Title>アップダウンボタンの作成</Title>
    <Format>
      n1,n2,n3,n4
      n1 : 幅
      n2 : 高さ
      n3 : スタイル
      n4 : アップダウンボタンを付けるオブジェクトのID
    </Format>
    <Setting>
      アップダウンボタンを作成します。
      アップダウンボタンとは矢印ボタンを持ったオブジェクトです。
      input等の入力ボックスから数値を得たいときなどに使うと便利です。
      (一応button等にも付けることはできます。)
      n4にはbuttonなどのオブジェクトのIDを入れます。

      この命令を呼び出した後、statにアップダウンボタンのIDが代入されます。

      udbtnのスタイル(n4)は以下の値を組み合わせて持つことができます。

      n4の値  スタイル
      1       最小、最大値に達したときに折り返す
      4       オブジェクトの右側に付ける
      8       オブジェクトの左側に付ける
      $20     方向キーで数値を変えられるようにする
      $40     水平タイプ
      $80     数字をカンマで区切らない

      ※udbtnはHSP標準命令のclsやscreen命令では消去されません。_clsまたは_clrobjを使用してください。
    </Setting>
  </command>
  <command>
    <Name>sel_udbtn</Name>
    <Title>操作するアップダウンボタンの選択</Title>
    <Format>
      n1
      n1 : アップダウンボタンのID
    </Format>
    <Setting>
      この命令使用後はn1で指定したアップダウンボタンに対して各操作を行います。
      アップダウンボタン新規に作成すると、自動的にそのアップダウンボタンが各操作の対象になります。
      複数のアップダウンボタンを作成したときは、この命令で操作するアップダウンボックスを選択してください。
    </Setting>
  </command>
  <command>
    <Name>udset</Name>
    <Title>アップダウンボタンの設定</Title>
    <Format>
      n1,n2,n3
      n1 : セットするタイプ
      n2 : n1によって変わる
      n3 : n1によって変わる
    </Format>
    <Setting>
      アップダウンボタンの設定をします。
      設定するものはn1の値によって異なります。

      n1の値
      0       アップダウンボタンの相手を設定します。
      n2にオブジェクトのIDを指定します。

      1       アップダウンボタンの範囲を設定します。
      n2に最小値(0から$7FFFまで),n3に最大値(0から$7FFFまで)を指定します。

      2       アップダウンボタンの位置を設定します。
      n2にアップダウンボタンの位置を指定します。

      3       アップダウンボタンの数値を16進で表示します。
      n2を省略すると16進になり、0以外の値を入れると10進に戻ります。

      4       アップダウンボタンの増加量を変化させる時間を設定します。
      n2に設定する数、n3に設定する時間、増加量が入った数値変数のポインタを指定します。
      (例)
      udbtn 100,100
      ;最初は1ずつ、3秒後に10ずつ、6秒後に50ずつ増加させるようにする
      a=0,1,	3,10,  6,50
      getptr p,a
      udset 4,3,p		;設定する時間は3つ

      この命令を呼び出した後のstatの値
      n1の値    statの値
      0        セットする前の相手のID
      1        0
      2        セットする前の位置
      3        セットする前の表示タイプ
      4        セットが成功した場合は1、失敗した場合は0
    </Setting>
  </command>
  <command>
    <Name>udget</Name>
    <Title>アップダウンボタンの各種情報の取得</Title>
    <Format>
      n1
      n1 : 取得するタイプ
    </Format>
    <Setting>
      アップダウンボタンの各種情報を取得します。
      取得するものはn1の値によって異なります。
      各情報はstatに代入されます。

      n1の値
      0       アップダウンボタンの相手を取得します。
      1       アップダウンボタンの範囲を取得します。
      statの値は ' 最小値 | (最大値&lt;&lt;16) ' の形式になっています。
      2       アップダウンボタンの位置を取得します。
      3       アップダウンボタンの数値の表示の仕方を取得します。
    </Setting>
  </command>
  <command>
    <Name>ss_running</Name>
    <Title>スクリーンセーバーが作動しているかシステムに知らせる</Title>
    <Format>
      n1
      n1 : 作動しているか、いないかのフラグ
    </Format>
    <Setting>
      スクリーンセーバーが作動しているかシステム(Windows)に知らせます。
      n1に1を代入すると、システム(Windows)にスクリーンセーバーが作動中であることを知らせます。
      n1に0を代入すると、スクリーンセーバーは作動してない、とシステムに知らせます。

      ※ n1を1にしてこの命令を実行すると、ALT+CTRL+DEL,ALT+TAB,winボタンなどのキーが効かなくなります。
      n1を1にしてこの命令を実行したら、必ずn1を0にしてもう一度この命令を実行してください。

      この命令を呼び出した後のstatの値
      0         エラー
      0以外     エラー無し
    </Setting>
  </command>
  <command>
    <Name>ss_chkpwd</Name>
    <Title>Windows標準のパスワードチェックダイアログ</Title>
    <Format></Format>
    <Setting>
      Windows標準のパスワードチェックダイアログを呼び出します。
      ただし、コントロールパネルの'画面のプロパティ'で'ﾊﾟｽﾜｰﾄﾞによる保護'がチェックされている場合のみです。

      この命令を呼び出した後のstatの値
      0         キャンセルされた
      0以外     正確なパスワードが入力された
      ('ﾊﾟｽﾜｰﾄﾞによる保護'がチェックされていない場合も含む)
    </Setting>
  </command>
  <command>
    <Name>ss_chgpwd</Name>
    <Title>Windows標準のパスワード変更ダイアログ</Title>
    <Format></Format>
    <Setting>
      Windows標準のパスワード変更ダイアログを呼び出します。

      この命令を呼び出した後のstatの値
      0       パスワードが変更された
      0以外   キャンセルされた
    </Setting>
  </command>
  <command>
    <Name>about</Name>
    <Title>プログラムのバージョンを表示するダイアログを作成</Title>
    <Format>
      "s1","s2"
      s1 : アプリケーション名が入った文字列変数または文字列
      s2 : 製作者名が入った文字列変数または文字列
    </Format>
    <Setting>
      プログラムのバージョンを表示する時などに使われるダイアログを表示します。
      アプリケーション名s1を"my.exeのﾊﾞｰｼﾞｮﾝ情報#my.exe ver 1.00"
      のように#で区切ると'Microsoft my.exe ver 1.00'という表示が加わります。
    </Setting>
  </command>
  <command>
    <Name>msgdlg</Name>
    <Title>拡張dialog(type 0〜3 )</Title>
    <Format>
      "s1","s2",n3,n4
      s1 : メッセージが入った文字列変数または文字列
      s2 : タイトルが入った文字列変数または文字列
      n3 : タイプ
      n4 : アイコンタイプ
    </Format>
    <Setting>
      HSPのdialog命令の拡張版です。

      タイプ
      0 Ok
      1 Ok ｷｬﾝｾﾙ
      2 中止　再試行　無視
      3 はい　いいえ　ｷｬﾝｾﾙ
      4 はい　いいえ
      5 再開試行 ｷｬﾝｾﾙ

      アイコンタイプ
      0 アイコン無し
      1 エラー(x)
      2 クエスチョンマーク(?)
      3 警告(!)
      4 情報(i)
      5 EXEが持っているアイコン

      この命令を呼び出した後のstatの値
      値 選択されたボタン
      1 Ok
      2 ｷｬﾝｾﾙ
      3 中止
      4 再試行
      5 無視
      6 はい
      7 いいえ
      -1 エラー発生

      タイプに以下の値を加えるとデフォルトボタンが変えられます。
      0       ボタン1
      $100    ボタン2
      $200    ボタン3
      アイコンタイプに以下の値を加えるとビープ音が変えられます。
      0       高い音(ノーマル)
      $100    警告音
    </Setting>
  </command>
  <command>
    <Name>multiopen</Name>
    <Title>複数のファイル名を取得</Title>
    <Format>
      v1,v2,n3,n4
      v1 : 選択されたファイル名を受け取るための変数
      v2 : 情報
      n3 : フィルタのインデックス(1から)
      n4 : Read Onlyボックスを付ける
    </Format>
    <Setting>
      HSPのdialog(type 16,17)で複数のファイルを選択できるようにしたものです。
      multiopen呼び出し時に、v1.0,v1.1にそれぞれv1,v2のサイズを代入しておきます。
      v2には例のような形式でフィルタを代入します。
      n3を省略、またはマイナスの値を使ったときの動作は備考参照。
      n4を1にするとReadOnlyボックスを付けます。2にするとReadOnlyボックスをチェックした状態にします。

      この命令を呼び出した後のstatの値

      0 キャンセルされた
      1 ファイルが選択されてOKボタンが押された
      2 ファイルが選択されてOKボタンが押された(ReadOnlyがチェックされている。ただし複数選択されていない場合のみ)

      p3を0(省略)にしてp1,p2に文字列を入れるとp1がタイトルになり、p2は初期フォルダになります。
      p3をマイナス値にすると保存するファイル名を得るときに使うことができます。(ただし複数選択はできません)

      複数のファイルが選択されたかはnotesel,notemaxを使って調べます。
      ファイルが一つしか選択されなかった場合、p1にはファイル名のフルパスが代入され、p2にはファイルの拡張子が代入されます。
      ファイルが複数選ばれた場合は、p1にnotegetで取得できる形式でファイル名が複数入っていて、p2には選択されたファイルがあるフォルダが代入されます。(p1のファイル名は'¥r'($0d)で区切られています。)
    </Setting>
  </command>
  <command>
    <Name>console_end</Name>
    <Title>コンソールウィンドウを閉じる</Title>
    <Format></Format>
    <Setting>コンソールウィンドウを閉じます。</Setting>
  </command>
  <command>
    <Name>console</Name>
    <Title>コンソールウィンドウを作成</Title>
    <Format></Format>
    <Setting>コンソールウィンドウを作成します。</Setting>
  </command>
  <command>
    <Name>puts</Name>
    <Title>コンソールに文字列を書き込む</Title>
    <Format>
      v1
      v1 : コンソールに表示する文字列が入った文字列変数
    </Format>
    <Setting>
      コンソールに文字列を表示します。
      (putzを使うとv1に直接文字列を使用することができます。)
    </Setting>
  </command>
  <command>
    <Name>gets</Name>
    <Title>コンソールから文字列を読み込む</Title>
    <Format>
      v1,n2
      v1 : コンソールからの文字列を取得する変数
      n2 : 取得する文字の数
    </Format>
    <Setting>
      コンソールから文字列を取得します。
      n2を省略したときの値は63です。
    </Setting>
  </command>
  <command>
    <Name>console_color</Name>
    <Title>コンソールのテキストの色設定</Title>
    <Format>
      n1
      n1 : コンソールの文字列の色
    </Format>
    <Setting>
      コンソールに表示する文字列の色を設定します。
      n1は以下の値を組み合わせて使います。1+4だと紫になります。
      1+4+8で明るい紫になります。


      n1の値  色
      1       青
      2       緑
      4       赤
      8       強調
      $10     青(背景)
      $20     緑(背景)
      $40     赤(背景)
      $80     強調(背景)
    </Setting>
  </command>
  <command>
    <Name>console_pos</Name>
    <Title>コンソールの文字表示位置設定</Title>
    <Format>
      n1,n2
      n1 : x座標
      n2 : y座標
    </Format>
    <Setting>文字列を表示する座標を設定します。</Setting>
  </command>
  <command>
    <Name>to_uni</Name>
    <Title>Unicodeへ変換</Title>
    <Format>
      v1,v2,n3
      v1 : Unicodeを格納する変数
      v2 : Unicodeに変換する文字列変数
      n3 : Unicodeに変換する文字列の長さ
    </Format>
    <Setting>
      ANSI文字列(SJIS)をUNICODEに変換します。

      この命令を呼び出した後、statにバッファに書き込まれたUnicode文字の数が代入されます。
      0ならエラーです。

      unicode呼び出し後にstatに入る値の'バッファに書き込まれたUnicode文字の数'は、1バイト(半角)文字は1文字､2バイト(全角)文字も1文字と数えます。
      例えば
      s="abcあいう"
      をすべてUnicodeに変換したあとのstat値は6+1(*注 +1は最後の文字列終結文字ぶん)。となります。

      n3を-1にすると指定した文字列全てを変換します。
      n3を0にするとUnicodeを格納するのに必要な変数のサイズを返します。(バイト単位)
    </Setting>
  </command>
  <command>
    <Name>from_uni</Name>
    <Title>UnicodeからANSIに変換</Title>
    <Format>
      v1,v2,n3
      v1 : Multibyteを格納する変数
      v2 : Multibyteに変換するUnicode文字列が入っている変数
      n3 : Multibyteに変換するUnicode文字列の長さ
    </Format>
    <Setting>
      UNICODEをANSI文字列に変換します。

      この命令を呼び出した後、statにバッファに書き込まれたMultibyte文字の数が代入されます。
      0ならエラーです。

      この命令を呼び出した後のstatの値、'バッファに書き込まれたMultibyte文字の数'は1バイト(半角)文字は1文字､2バイト(全角)文字は2文字と数えます。

      'Multibyteに変換するUnicode文字列の長さ'を-1にすると全て変換します。
      'Multibyteに変換するUnicode文字列の長さ'を0にするとMultibyteを格納するのに必要な変数のサイズを返します。(バイト単位)
    </Setting>
  </command>
  <command>
    <Name>dd_accept</Name>
    <Title>ドラッグ&amp;ドロップをできるようにする</Title>
    <Format>
      v1,v2,n3
      v1 : ドラッグ&amp;ドロップされたファイル名を入れる変数
      v2 : ドラッグ&amp;ドロップされたファイル数を入れる変数
      n3 : ウィンドウID
    </Format>
    <Setting>
      n3で指定したウィンドウにドラッグ&amp;ドロップ(以下D&amp;D)をできるようにします。
      ただし、ウィンドウID 1は設定できません。
      dd_acceptを実行した後、ウィンドウにファイルがD&amp;Dされるとv1で指定した変数にD&amp;Dされたファイル名が入ります。
      v2にはD&amp;Dされたファイルの数、D&amp;Dされた座標、ウィンドウIDが代入されます。

      D&amp;Dされたファイル名は"¥n"で区切られています(D&amp;Dされたファイルが1つの場合でも)。
      1つのファイル名を取り出したいときはノートパッド命令を使うと便利です。

      dd_accept実行後は、v1,v2に設定した変数はalloc,dim,sdimなどに使用しないで下さい。
    </Setting>
  </command>
  <command>
    <Name>dd_reject</Name>
    <Title>ドラッグ&amp;ドロップをできないようにする</Title>
    <Format>
      n1,n2
      n1 : ウィンドウID
      n2 : フラグ
    </Format>
    <Setting>
      ドラッグ&amp;ドロップをできないようにします。
      dd_acceptを実行していない場合には効果がありません。
      n2を1にするともう一度ドラッグ&amp;ドロップをできるようにします。
    </Setting>
  </command>
  <command>
    <Name>keybd_event</Name>
    <Title>キーボード操作</Title>
    <Format>
      n1,n2,n3
      n1 : キーコード
      n2 : キーを放すフラグ
      n3 : オプション
    </Format>
    <Setting>
      キーボード操作を行います。
      n1に押したいキーのキーコードを指定します。
      n2を0にしてこの命令を実行するとn1を前回実行したときと同じキーコード、
      n2を1にしてもう一度この命令を実行しないとキーを放したことになりません。
      n2を-1にすると押して放したことになります。
      n3のオプションはスクリーンショットキーを押すときに使用します。n3を0にするとフルスクリーン、1にするとアクティブなウィンドウがクリップボードにコピーされます。

      keybd_eventは他のプログラムのウィンドウがアクティブな場合でも実行されます。

      &lt;>キーコード
      キーコードはgetkeyで使用するものと同じです。
      ほかにも以下のようなものがあります。

      n1の値
      44       スクリーンショット
      45       INS
      46       DEL
      106      テンキーの'*'
      107      テンキーの'+'
      108      テンキーの','
      109      テンキーの'-'
      110      テンキーの'.'
      111      テンキーの'/'
    </Setting>
  </command>
  <command>
    <Name>mouse_event</Name>
    <Title>マウス操作</Title>
    <Format>
      n1,n2,n3
      n1 : 操作タイプ
      n2 : 水平方向の移動量
      n3 : 垂直方向の移動量
    </Format>
    <Setting>
      マウス操作を行います。
      n1に指定するタイプでマウス操作を行うことができます。
      水平方向の移動量は、画面左から右へ移動させるときが正、その逆が負
      垂直方向の移動量は、画面上から下へ移動させるときが正、その逆が負
      であることに注意してください。

      mouse_eventはHSPのプログラムがアクティブでないときでもマウス操作に影響します。

      &lt;>操作タイプ
      n1の値は以下のものを組み合わせて使用することができます。

      n1の値
      $1       マウス移動
      $2       左のボタンを押す
      $4       左のボタンを放す
      $8       右のボタンを押す
      $10      右のボタンを放す
      $20      中のボタンを押す
      $40      中のボタンを放す
    </Setting>
  </command>
  <command>
    <Name>winver</Name>
    <Title>Windowsのバージョン取得</Title>
    <Format>
      v1
      v1 : バージョンを受け取るための数値変数
    </Format>
    <Setting>
      ウィンドウズのバージョンを取得します。
      変数には以下の値が入ります。

      v.0     プラットフォーム
      0     Windows 3.1
      95    Windows 95
      98    Windows 98
      100   Windows Me
      $100  Windows NT 3.5
      $101  Windows NT 4.0
      2000  Windows 2000
      2001  Windows XP
      v.1    メジャーバージョン
      v.2    マイナーバージョン
      v.3    ビルドナンバー
      v.4    メジャー&amp;マイナーバージョン(プラットフォームが Windows 95,98,Meの時のみ)
    </Setting>
  </command>
  <command>
    <Name>verinfo</Name>
    <Title>バージョン情報取得</Title>
    <Format>
      "s1",n2
      s1 : ファイル名
      n2 : 取得するタイプ
    </Format>
    <Setting>
      s1で指定したファイルから、バージョン情報を取得します。
      s1にはdllやexeなどのバイナリファイルを指定します。
      refstrにバージョン情報が代入されます。

      16bitファイルからはバージョンを取得できません。
      エラーが起きた場合はstatに1が代入されます。


      n2の値   取得するもの
      0        会社名
      1        ファイルの説明
      2        ファイルバージョン
      3        内部ファイル名
      4        著作権
      5        もとのファイル名
      6        製品名
      7        製品バージョン
    </Setting>
  </command>
  <command>
    <Name>fontdlg</Name>
    <Title>フォント選択ダイアログを開く</Title>
    <Format>
      p1, p2
      p1 : 戻り値を格納する数値型配列変数
      p2 = 0〜(0) : オプション
    </Format>
    <Setting>
      フォント選択ダイアログを開きます。
      フォント名はrefstrに、その他の情報はp1で指定した配列変数に代入されます。

      p2にはオプションを指定します。0x100を指定すると、打ち消し線・下線・文字色を指定できるようになります。

      正常に終了した場合、statには0以外が返ります。キャンセルされた場合やエラーが発生した場合はstatに0が返ります。
    </Setting>
  </command>
  <command>
    <Name>imgload</Name>
    <Title>画像ファイル読み込み</Title>
    <Format>
      "ファイル名"
      "ファイル名" : 読み込むファイル名
    </Format>
    <Setting>
      ImgCtxを利用して画像ファイルを読み込みます。
      BMP,JPEG,GIF,ICO,PNG形式の画像ファイルに対応しています。

      picloadとは異なり、ウィンドウのリサイズは行われませんので注意してください。
      また、パックされたファイルは読み込めません。
    </Setting>
  </command>
  <command>
    <Name>joyGetPosEx</Name>
    <Title>ジョイスティックの入力を取得する</Title>
    <Format>
      p1, p2
      p1 : 入力状態を代入する数値型配列変数
      p2 : ポート番号
    </Format>
    <Setting>
      ジョイスティックの入力を取得します。
      配列変数p1には以下の情報が代入されます。

      data(0) = 常に 52  が入ります
      data(1) = 常に 255 が入ります
      data(2) = 第 1 軸の状態（普通のジョイスティックの X 軸）
      data(3) = 第 2 軸の状態（普通のジョイスティックの Y 軸）
      data(4) = 第 3 軸の状態（スロットル等）
      data(5) = 第 4 軸の状態
      data(6) = 第 5 軸の状態
      data(7) = 第 6 軸の状態
      data(8) = ボタンの状態（最大32ボタン）
      data(9) = 同時に押されているボタンの数
      data(10) = POV スイッチの状態
      data(11) = 予備情報1
      data(12) = 予備情報2

      システム変数statが0であれば入力は正常です。
    </Setting>
  </command>
  <command>
    <Name>jstick</Name>
    <Title>stick命令互換の値を取得する</Title>
    <Format>
      p1, p2
      p1 : 代入する変数
      p2 : ポート番号
    </Format>
    <Setting>
      stick命令互換の値を変数に返します。
      システム変数statには入力が正常の場合は0が、入力が異常の場合は0以外が代入されます。
    </Setting>
  </command>
  <command>
    <Name>addmenu</Name>
    <Title>メニュー項目を追加する</Title>
    <Format>
      p1, p2, p3, p4
      p1 : メニューハンドル
      p2 : メニュー文字列
      p3 : メニューアイテムID値
      p4 : メニュー項目属性
    </Format>
    <Setting>
      newmenuで作成したメニューに項目を追加します。
      メニューの作成に失敗するとstatに0が返ります。

      p1には項目を追加するメニューのハンドルを指定します。

      p2にはメニューアイテムに表示する文字列を指定します。半角の&amp;に続けて半角アルファベットを記述すると、ショートカットキーとして割り当てることができます。

      p3にはメニューアイテムのIDを指定します。p4に0x0010を指定した場合は、ドロップダウンメニューまたはサブメニューのハンドルを指定します。

      p4にはメニューアイテムのオプションを指定します。オプションは加算あるいはOR演算で組み合わせて使用できます。
    </Setting>
  </command>
  <command>
    <Name>applymenu</Name>
    <Title>メニューをウィンドウに割り当てる</Title>
    <Format>
      p1
      p1 : メニューハンドル
    </Format>
    <Setting>newmenuで作成したメニューを現在選択されているウィンドウに割り当てます。必ずメニュー作成終了後に実行してください。</Setting>
  </command>
  <command>
    <Name>newmenu</Name>
    <Title>新しいメニューハンドルを取得する</Title>
    <Format>
      p1, p2
      p1 : 結果を格納する変数名
      p2 : 種類の指定
    </Format>
    <Setting>
      新しくメニューを作成し、そのハンドルをp1へ代入します。
      p2で作成するメニューの種類を指定します。0ならばメニュー項目用、1ならばポップアップ項目用のメニューが作成されます。
    </Setting>
  </command>
  <command>
    <Name>picfont</Name>
    <Title>画像を使用したフォント表示準備</Title>
    <Format>
      id, cx, cy, mode, offset
      id : フォント画像のあるバッファID
      cx,cy  : フォント１文字あたりのXYサイズ
      mode   : 表示時のモード(gmodeのモード値)
      offset : 表示位置のオフセット
    </Format>
    <Setting>
      画像を使用したフォント表示の準備を行ないます。
      idでフォント画像が存在するバッファIDを指定します。
      画像には、あらかじめ半角英数字の等幅文字を１６文字×８段(文字コード順)で格納されている必要があります。
      この画像は、HGIMG3のsetfont命令で使用するものと互換性があります。
      cx,cyにより、１文字あたりの文字サイズを指定します。
      modeにより、表示時のコピーモード(gmodeで指定するモード値)を指定します。
      (たとえば、2を指定した場合は背景の黒色を透過して表示します)
      offsetには、１文字を表示する際に横位置を補正する値を指定します。
      この値が大きいほど、文字間隔が広がり、小さいほど間隔が狭くなります。
      0を指定した場合は、フォントサイズと同じ文字送りとなります。
      picfont命令により初期化されたフォント画像は、picfprt命令により表示することができます。
    </Setting>
  </command>
  <command>
    <Name>picfprt</Name>
    <Title>画像を使用したフォント表示</Title>
    <Format>
      "message"
      "message" : 表示するメッセージ
    </Format>
    <Setting>
      picfont命令により初期化されたフォント画像を表示します。
      "message"に表示する文字列を指定します。表示できる文字列は、半角英数字のみとなります。
      表示される文字の位置は、pos命令で指定されるカレントポジションとなります。
      picfprtでは、改行コードを認識します。
      また、メッセージ表示後は、改行された位置にカレントポジションが移動します。
    </Setting>
  </command>
  <command>
    <Name>rssload</Name>
    <Title>XMLパーサー(MSXML)を使用してRSSを読み込む</Title>
    <Format>
      p1, p2, "path", p3
      p1=変数 : RSSの内容を代入する文字列型配列変数
      p2=変数 : リンク先を代入する文字列型配列変数
      "path" : URLまたはファイルパス
      p3=0〜(5) : 読み込むRSSフィールドの数
    </Format>
    <Setting>
      XMLパーサー(MSXML)を使用してRSSを読み込みます。

      結果はp1およびp2に代入されます。p1およびp2は自動的に文字列型配列変数として初期化されます。

      p3には読み込むRSSフィールドの数を指定します。p3を省略した場合は5つ読み込みます。

      RSSの読み込みに成功すると、システム変数statに0が返ります。
      取得に失敗した場合はstatに1が、指定したURLまたはファイルパスがRSSのものではなかった場合はstatに2が返ります。
    </Setting>
  </command>
  <command>
    <Name>qreset</Name>
    <Title>OBAQ初期化</Title>
    <Format></Format>
    <Setting>
      OBAQが持つ、すべての情報が初期化されます。
      qreset命令により初期化を行なうと、画面全体を囲む壁(枠)が自動的に設定されます。
      壁のサイズや位置を変更したい場合は、qborder命令により再設定を行なってください。
      qreset実行時に、HSPの描画対象として設定されていたウィンドウが、OBAQでも描画の対象となります。
      描画の対象となるウィンドウを変更する場合には、qview命令を使用してください。
    </Setting>
  </command>
  <command>
    <Name>qterm</Name>
    <Title>OBAQ終了処理</Title>
    <Format></Format>
    <Setting>
      OBAQが持つ、すべての情報を破棄します。
      プログラム終了時などに内部で呼び出されます。
      通常は呼び出す必要はありません。
    </Setting>
  </command>
  <command>
    <Name>qexec</Name>
    <Title>OBAQフレーム処理</Title>
    <Format></Format>
    <Setting>
      フレームごとの物理演算を実行します。
      これにより、すべてのオブジェクト座標が更新されます。
      メインループでは、必ずqexec命令によりオブジェクトの移動更新を行なう必要があります。
      また、内部の描画を利用する場合は、qdraw命令による画面の更新も必要になります。
    </Setting>
  </command>
  <command>
    <Name>qdraw</Name>
    <Title>OBAQ描画処理</Title>
    <Format>
      mode
      mode(0) : デバッグ表示モード設定(0=ON/1=OFF)
    </Format>
    <Setting>
      OBAQによるオブジェクトの描画処理を行ないます。
      それぞれのオブジェクトに設定されたマテリアル情報をもとに、適切な表示を行ないます。
      modeの設定により、デバッグ表示のON/OFFを設定することができます。
      デバッグ表示時は、ワイヤーフレームによるオブジェクトの形状や中心位置、グループなどを確認することができます。
      表示先ウインドゥの変更や、表示倍率、表示位置オフセットの設定はqview命令を使用してください。
      qdraw命令による描画は、WindowsのシステムAPI(GDI)を利用していますので、
      画面クリアと、redraw命令による更新も行なう必要があります。
      他のシステムによる描画(DirectX等)を行なう場合は、qexec命令による更新だけを行なってから、
      各オブジェクトの表示位置を自前で取得して描画を行なう必要があります。
      (表示座標の変換用にqcnvaxis命令やqgetaxis命令が用意されています。)
    </Setting>
  </command>
  <command>
    <Name>qview</Name>
    <Title>ビュー設定</Title>
    <Format>
      zoomx,zoomy,ofsx,ofsy
      zoomx(4.0) : X方向のズーム倍率(実数)
      zoomy(4.0) : Y方向のズーム倍率(実数)
      ofsx(0.0)  : X方向の表示オフセット(実数)
      ofsy(0.0)  : Y方向の表示オフセット(実数)
    </Format>
    <Setting>
      qdraw命令により描画される際の表示設定を行ないます。
      zoomx,zoomyにより表示倍率(OBAQの内部座標を画面に反映させる際の倍率)を設定します。
      ofsx,ofsyにより、表示位置のオフセットを設定することができます。
      また、qview実行時に、HSPの描画対象として設定されていたウィンドウが、描画の対象として再設定されます。
    </Setting>
  </command>
  <command>
    <Name>qsetreq</Name>
    <Title>システムリクエスト設定</Title>
    <Format>
      reqid,val
      reqid(0) : リクエストID
      val(0.0) : 設定値(実数)
    </Format>
    <Setting>
      OBAQに対して様々なシステム設定を行ないます。
      reqid値で指定できるのは以下のシンボルです。

      シンボル名        	内容
      ------------------------------------------------------------------------
      REQ_PHYSICS_RATE	1フレームあたりの物理計算回数
      REQ_MAXOBJ		オブジェクト最大数(512以内)(*)
      REQ_MAXLOG		コリジョンログ最大数(*)
      REQ_DEFAULT_WEIGHT	デフォルトの重さ
      REQ_DEFAULT_MOMENT	デフォルトのモーメント
      REQ_DEFAULT_FRICTION	デフォルトの摩擦

      (*)のシンボルは、qreset命令実行まで内容が反映されません。
    </Setting>
  </command>
  <command>
    <Name>qgetreq</Name>
    <Title>システムリクエスト取得</Title>
    <Format>
      var,reqid
      var      : 内容を取得する変数
      reqid(0) : リクエストID
    </Format>
    <Setting>
      OBAQのシステム設定値を取得します。
      varで指定された変数に内容を読み出します。
      varの変数は、自動的に実数型に設定されます。
      reqid値で指定できるのは以下のシンボルです。

      シンボル名            初期値	内容
      ------------------------------------------------------------------------------
      REQ_PHYSICS_RATE	4	1フレームあたりの物理計算回数
      REQ_MAXOBJ		512	オブジェクト最大数(512以内)(*)
      REQ_MAXLOG		256	コリジョンログ最大数(*)
      REQ_DEFAULT_WEIGHT	6.0	デフォルトの重さ
      REQ_DEFAULT_MOMENT	1200.0	デフォルトのモーメント
      REQ_DEFAULT_FRICTION	1.0	デフォルトの摩擦

      (*)のシンボルは、qreset命令実行まで内容が反映されません。
    </Setting>
  </command>
  <command>
    <Name>qborder</Name>
    <Title>外壁を設定</Title>
    <Format>
      x1,y1,x2,y2
      x1(-100) : 左上X座標(実数)
      y1(-100) : 左上Y座標(実数)
      x2(100)  : 右下X座標(実数)
      y2(100)  : 右下Y座標(実数)
    </Format>
    <Setting>
      標準的に設定されている外壁のサイズを再設定します。
      画面の中央を(0,0)として、左上と右下の座標(OBAQの内部座標)を指定してください。
      外壁は、何も壁のない状態で画面内にオブジェクトを配置した際に、
      画面外まで落下するのを防ぐためのものです。
    </Setting>
  </command>
  <command>
    <Name>qgravity</Name>
    <Title>重力を設定</Title>
    <Format>
      gx,gy
      gx(0.0)   : X方向の重力(実数)
      gy(0.005) : Y方向の重力(実数)
    </Format>
    <Setting>
      空間の重力を設定します。
      初期値は、(0,0.005)が設定されています。
    </Setting>
  </command>
  <command>
    <Name>qcnvaxis</Name>
    <Title>X,Y座標値を変換</Title>
    <Format>
      var_x,var_y,x,y,opt
      var_x  : Xを取得する変数
      var_y  : Yを取得する変数
      x(0.0) : 変換元のX座標(実数)
      y(0.0) : 変換元のY座標(実数)
      opt(0) : 変換モード
    </Format>
    <Setting>
      X,Y座標値を指定された方法に従って変換します。
      変換元の座標を(x,y)で指定すると、var_x,var_yにそれぞれ変換済みのX,Y座標値が代入されます。
      optで指定する変換モードは、以下の値を選ぶことができます。

      変換モード        	内容
      ------------------------------------------------------------------------
      0                       内部座標を画面上の座標に変換
      1                       画面上の座標を内部座標に変換

      変換モード0(または省略時)は、内部座標をqdraw命令で表示される画面上の座標に変換します。(var_x,var_yは整数型に設定されます。)
      変換モード1は、qdraw命令で表示される画面上の座標を内部座標に変換します。(var_x,var_yは実数型に設定されます。)
    </Setting>
  </command>
  <command>
    <Name>qgetaxis</Name>
    <Title>内部座標を取得</Title>
    <Format>
      num,var_x,var_y,type
      num(0) : オブジェクトID
      var_x  : Xを取得する変数
      var_y  : Yを取得する変数
      type(0): 取得タイプ
    </Format>
    <Setting>
      OBAQのオブジェクトが持つ内部座標及び表示パラメーターを変数に読み出します。
      var_x,var_yは整数型として自動的に設定されます。
      typeで指定できる内容は以下の通りです。

      取得タイプ        	内容
      ------------------------------------------------------------------------
      0                       オブジェクトの左上座標
      1                       オブジェクトの右下座標
      2			オブジェクトのX,Yサイズ(*)

      (*)のシンボルは、表示画面上でのサイズ(ドット数)が返されます
    </Setting>
  </command>
  <command>
    <Name>qdel</Name>
    <Title>オブジェクト削除</Title>
    <Format>
      num
      num(0) : オブジェクトID
    </Format>
    <Setting>
      指定されたオブジェクトを削除します。
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qaddpoly</Name>
    <Title>多角形オブジェクト追加</Title>
    <Format>
      var,shape,x,y,r,sx,sy,colsw,mygroup,exgroup,loggroup
      var      : オブジェクトIDを取得する変数
      shape(3) : 頂点数
      x(0.0)   : 配置X座標(実数)
      y(0.0)   : 配置Y座標(実数)
      r(0.0)   : 配置角度(実数)(単位はラジアン)
      sx(10.0) : 配置Xサイズ(実数)
      sy(10.0) : 配置Yサイズ(実数)
      colsw(1) : 配置チェックのモード
      mygroup(1)  : 自分が属するコリジョングループ
      exgroup(0)  : 衝突を除外するグループ
      loggroup(0) : コリジョンログを作成するグループ
    </Format>
    <Setting>
      OBAQに多角形オブジェクトを追加します。
      shapeで指定された頂点を持つオブジェクトが生成されます。
      (shapeの頂点数は3以上でなければなりません。)
      (x,y)で配置の座標を指定します。(OBAQの内部座標を設定します。)
      rで配置角度(+方向が時計周りになります)を指定します。単位はラジアンとなります。
      (sx,sy)で、配置時の大きさを指定します。デフォルトでは、(10,10)のサイズが使用されます。
      mygroup,exgroup,loggroupはコリジョン(衝突)の検出のために設定されるグループ値になります。
      グループ値は、32bitいずれかのビットが1の値(1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768…)によって示されます。
      colswで配置チェックのモードを選択することができます。

      モード        値	内容
      ------------------------------------------------------------------------
      colsw_none     0        出現時コリジョンチェック無し
      colsw_active   1        出現時active状態の岩との接触を避ける
      colsw_all      2        出現時reserve状態以外の岩との接触を避ける

      オブジェクトが正常に追加された時には、varで指定された変数にオブジェクトID値が代入されます。(変数は自動的に整数型となります。)
      登録数の限界でオブジェクトの追加が行なわれなかった場合は、varで指定された変数に-1が代入されます。
      コリジョン(衝突)検出のためオブジェクトの追加が行なわれなかった場合は、varで指定された変数に-2が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qaddmodel</Name>
    <Title>自由設定オブジェクト追加</Title>
    <Format>
      var,shape_var,nvertex,x,y,r,sx,sy,colsw,mygroup,exgroup,loggroup
      var      : オブジェクトIDを取得する変数
      shape_var: 形状データを代入した配列変数
      nvertex(-1) : 形状データの個数
      x(0.0)   : 配置X座標(実数)
      y(0.0)   : 配置Y座標(実数)
      r(0.0)   : 配置角度(実数)(単位はラジアン)
      sx(10.0) : 配置Xサイズ(実数)
      sy(10.0) : 配置Yサイズ(実数)
      colsw(1) : 配置チェックのモード
      mygroup(1)  : 自分が属するコリジョングループ
      exgroup(0)  : 衝突を除外するグループ
      loggroup(0) : コリジョンログを作成するグループ
    </Format>
    <Setting>
      OBAQに自由設定された形状のオブジェクトを追加します。
      一般的な多角形は、qaddpoly命令によって生成することができます。
      qaddmodel命令では、頂点を個別に指定することでより自由な形を登録することができます。
      shape_varに、形状データを代入した配列変数を指定する必要があります。
      配列変数には、x1,y1,x2,y2…の順番に座標を格納しておいてください。
      座標は、必ず左回り(反時計回り)で指定し、凸面体でなければなりません。
      1つのオブジェクトに複数の凸面体を内包させることも可能です。
      その場合は、左回りで指定する座標の最後を、最初の座標と同一にして閉じた形にした後で、
      新しい別な形の座標を指定するようにしてください。

      nvertexでデータの個数(頂点の個数ではありません)を指定します。
      nvertexがマイナス値か省略された場合は、配列に設定された要素数が使用されます。
      形状データを格納した配列変数には、実数型、整数型のどちらかを使用できます。
      規定の頂点数を超えるデータを扱うことはできませんので注意してください。詳しくは、OBAQ.DLLのマニュアルを参照してください。

      ;	自由な形状のモデルを追加
      ;
      model=-1.0,-1.0, -1.0,2.0, 2.0,1.0, 1.0,-1.0
      qaddmodel i,model,-1, 30,64,0

      (x,y)で配置の座標を指定します。(OBAQの内部座標を設定します。)
      rで配置角度(+方向が時計周りになります)を指定します。単位はラジアンとなります。
      (sx,sy)で、配置時の大きさを指定します。デフォルトでは、(10,10)のサイズが使用されます。
      mygroup,exgroup,loggroupはコリジョン(衝突)の検出のために設定されるグループ値になります。
      グループ値は、32bitいずれかのビットが1の値(1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768…)によって示されます。
      colswで配置チェックのモードを選択することができます。

      モード        値	内容
      ------------------------------------------------------------------------
      colsw_none     0        出現時コリジョンチェック無し
      colsw_active   1        出現時active状態の岩との接触を避ける
      colsw_all      2        出現時reserve状態以外の岩との接触を避ける

      オブジェクトが正常に追加された時には、varで指定された変数にオブジェクトID値が代入されます。(変数は自動的に整数型となります。)
      登録数の限界でオブジェクトの追加が行なわれなかった場合は、varで指定された変数に-1が代入されます。
      コリジョン(衝突)検出のためオブジェクトの追加が行なわれなかった場合は、varで指定された変数に-2が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qtype</Name>
    <Title>typeパラメーターを設定</Title>
    <Format>
      num,type,option
      num(0)    : オブジェクトID
      type(0)   : 設定値
      option(0) : 設定オプション
    </Format>
    <Setting>
      指定したオブジェクトのtypeパラメーターを設定します。
      typeパラメーターには、以下の内容を指定することができます。

      マクロ名        値	内容
      -----------------------------------------------------------
      type_normal	0	通常のオブジェクト
      type_inner	1	接触判定を反転したオブジェクト
      type_bindX	0x40	X軸を背景に固定
      type_bindY	0x80	Y軸を背景に固定
      type_bindR	0x100	回転を固定
      type_bind	0x1c0	背景に完全固定(物理挙動なし)
      type_autowipe	0x100000  ボーダー範囲を越えたら自動的に消去

      type_innerは、外壁を作成する際に使用します。
      デフォルトの壁(qborder命令で作成される形状)に使用されていますが、
      この用途以外では使用しないよう注意してください。
      type_autowipeは、qborder命令で設定したボーダー領域(枠)の範囲を出たオブジェクトを自動的に消去するためのフラグです。

      optionで、type値の設定方法を指定することができます。

      option       	内容
      ------------------------------------------------------------------------
      0               type値をセット(set)
      1               type値を追加(or)
      2               type値を除外(not)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qstat</Name>
    <Title>statパラメーターを設定</Title>
    <Format>
      num,stat,sleepcount
      num(0)        : オブジェクトID
      stat(0)       : 設定値
      sleepcount(0) : スリープカウント値
    </Format>
    <Setting>
      指定したオブジェクトのstatパラメーター、及びスリープカウント値を設定します。
      statパラメーターには、以下の内容を指定することができます。

      マクロ名        値	内容
      -------------------------------------------------------------------
      stat_reserve 	0	未使用オブジェクト
      stat_sleep 	1	出現待ちオブジェクト
      stat_active 	2	出現しているオブジェクト

      optionで、type値の設定方法を指定することができます。
      スリープカウント値は、statにstat_sleepを指定している際に参照される値です。
      stat_sleepになっているオブジェクトは、スリープカウント値の回数だけ点滅して
      出現します。(スリープカウント値が0の場合は、出現せず準備状態を維持します。)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qpos</Name>
    <Title>位置、角度パラメーターを設定</Title>
    <Format>
      num,x,y,angle
      num(0)     : オブジェクトID
      x(0.0)     : X座標設定値(実数)
      y(0.0)     : Y座標設定値(実数)
      angle(0.0) : 角度設定値(実数)(ラジアン)
    </Format>
    <Setting>
      指定したオブジェクトの位置、角度パラメーターを設定します。
      (x,y)でオブジェクトの基準となる位置(中心座標)を指定します。
      angleでオブジェクト回転角度(+方向が時計周り)を指定します。単位はラジアンとなります。
      OBAQでは、基本的に物体を動かす場合でも、直接物体の座標を
      変更するのではなく動かしたい方向に力を加えたり、qgetspeed命令により
      加速度を設定することで実現してください。
      強制的に座標を変更した場合には、正しい物理挙動にならない可能性があります。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qspeed</Name>
    <Title>速度パラメーターを設定</Title>
    <Format>
      num,px,py,pr,option
      num(0)     : オブジェクトID
      px(0.0) : X方向設定値(実数)
      py(0.0) : Y方向設定値(実数)
      pr(0.0) : 回転速度パラメーター(実数)
      option(0) : 設定オプション
    </Format>
    <Setting>
      指定したオブジェクトの速度パラメーターを設定します。
      (px,py)でオブジェクトのX,Y方向に対する移動速度を指定します。
      prで回転に対する速度を指定します。
      optionで、設定方法を指定することができます。

      option       	内容
      ------------------------------------------------------------------------
      0               速度値を加算(add)
      1               速度値×２を上書き(set)
      2               速度値を上書き(set)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
      option(設定オプション)値が2の場合は、指定された値が設定されます。
      option(設定オプション)値が1の場合は、指定された値の２倍が設定されますので注意してください。
    </Setting>
  </command>
  <command>
    <Name>qweight</Name>
    <Title>重さなどのパラメーターを設定</Title>
    <Format>
      num,weight,moment
      num(0) : オブジェクトID
      weight(6.0)    : 重さの値(実数)
      moment(1200.0) : モーメント値(実数)
    </Format>
    <Setting>
      指定したオブジェクトの重さ、モーメント、摩擦などのパラメーターを設定します。
      weight(重さ)は、半径rの円に標準的な比重の場合、

      (r  2) / 32.0

      くらいを目安に設定してください。
      moment(モーメント)は、回転のしやすさに関わるパラメーターだと考えて下さい。

      半径rの円盤： weight * (r  2) / 2.0
      辺の長さがa, bの長方形 : weight * ((a  2) + (b  2)) / 12.0

      のような値を目安に設定してください。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qdamper</Name>
    <Title>吸振などのパラメーターを設定</Title>
    <Format>
      num,damper,friction
      num(0) : オブジェクトID
      damper(0.7)    : 吸振パラメーター値(実数)
      friction(1.0)  : 摩擦抵抗値(実数)
    </Format>
    <Setting>
      指定したオブジェクトの吸振、惰性、重力係数などのパラメーターを設定します。
      damper(吸振)は、接触した際のゆれを抑える力を示しています。
      0.0から1.0までの値を設定するようにしてください。(範囲チェックは行なわれません)
      friction(摩擦)は、物体同士が接触した時に減衰する力の係数になります。
      接触する物体のfrictionと乗算した値が参照され計算されます。
      0.0から1.0までの値を設定するようにしてください。(範囲チェックは行なわれません)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qinertia</Name>
    <Title>惰性などのパラメーターを設定</Title>
    <Format>
      num,inertia,gravity
      num(0) : オブジェクトID
      inertia(0.999) : 惰性パラメーター値(実数)
      gravity(1.0)   : オブジェクトの重力値(実数)
    </Format>
    <Setting>
      指定したオブジェクトの惰性、重力係数などのパラメーターを設定します。
      inertia(惰性)は、0.0に近づくほど抵抗が発生してねっとりした動きに
      なります。0.0から1.0までの値を設定するようにしてください。(範囲チェックは行なわれません)
      gravity(オブジェクトの重力)は、空間に設定されている重力に乗算される形で
      オブジェクトのみに反映されます。
      特定のオブジェクトだけに、異なる重力を与える場合に使用します。
      現実にはありえない形で、特定のオブジェクトだけに無重力や反重力を与えるため、ゲームなどのキャラクター制御に有効です。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgroup</Name>
    <Title>グループパラメーターを設定</Title>
    <Format>
      num,mygroup,exgroup,loggroup
      num(0)      : オブジェクトID
      mygroup(1)  : 自分が属するコリジョングループ値
      exgroup(0)  : 衝突を除外するグループ値
      loggroup(0) : コリジョンログを作成するグループ値
    </Format>
    <Setting>
      指定したオブジェクトのグループパラメーターを設定します。
      グループパラメーターは、衝突する相手オブジェクトを特定する場合などの識別に使用されます。
      グループ値は、32bitいずれかのビットが1の値(1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768…)によって示されます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qmat</Name>
    <Title>マテリアルパラメーターを設定</Title>
    <Format>
      num,type,id,subid
      num(0)   : オブジェクトID
      type(0)  : マテリアルタイプ値
      id(0)    : 参照id値
      subid(0) : 参照subid値
    </Format>
    <Setting>
      指定したオブジェクトのマテリアルパラメーターを設定します。
      マテリアルパラメーターは、qdraw命令による描画時に反映されます。
      マテリアルタイプ値により、表示方法を選択することができます。

      タイプ          値	内容
      -------------------------------------------------------------------
      mat_none	0	何もしない(非表示)
      mat_spr		1	スプライト
      mat_spr2	2	スプライト(サイズ設定付き)
      mat_wire	3	ワイヤーフレーム
      mat_wire2	4	ワイヤーフレーム(輪郭付き)
      mat_delay	0x1000	後から描画

      スプライトは、形状全体をカバーする形で矩形が貼り付けられます。
      ワイヤーフレームの場合は、それぞれの頂点を線で繋ぎます。
      mat_spr、mat_spr2を選択した場合は、idにスプライトとして表示する
      画像のウィンドウID、subidに分割画像No.を指定します。
      ウィンドウIDと分割画像No.は、celput命令で使用されるパラメーターと
      同様で、素材となる画像をceldiv命令によって分割したものを参照することができます。
      mat_wireまたは、mat_wire2を選択した場合は、idでワイヤーの色コード
      (RGBをパックした24bit値)、subidで輪郭の色コードを設定します。
      マテリアルタイプ値に、mat_delay(0x1000)を加算したオブジェクトは、
      後から描画されるようになります。
      これは、半透明を使った表示などで利用することができます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qmat2</Name>
    <Title>マテリアル詳細パラメーターを設定</Title>
    <Format>
      num,offsetx,offsety,zoomx,zoomy
      num(0)   : オブジェクトID
      offsetx(0) : X方向表示オフセット
      offsety(0) : Y方向表示オフセット
      zoomx(1.0) : X方向表示倍率(実数)
      zoomy(1.0) : Y方向表示倍率(実数)
    </Format>
    <Setting>
      指定したオブジェクトのマテリアル詳細パラメーターを設定します。
      マテリアル詳細パラメーターは、qdraw命令による描画時に反映されます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qmat3</Name>
    <Title>マテリアル表示パラメーターを設定</Title>
    <Format>
      num,gmode,rate
      num(0)   : オブジェクトID
      gmode(0) : コピーモード
      rate(256): 半透明レート
    </Format>
    <Setting>
      指定したオブジェクトのマテリアル表示パラメーターを設定します。
      マテリアル表示パラメーターは、qdraw命令による描画時に反映されます。
      gmodeは、スプライトを描画する際のコピーモードを指定します。
      これは、HSPのgmode命令で指定されるモード値と同じです。
      また、rate(半透明レート)も同様にgmode命令で指定された場合と同じ結果になります。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>quser</Name>
    <Title>ユーザー定義データを設定</Title>
    <Format>
      num,user1,user2,user3
      num(0)   : オブジェクトID
      user1(0) : ユーザー定義データ1
      user2(0) : ユーザー定義データ2
      user3(0) : ユーザー定義データ3
    </Format>
    <Setting>
      指定したオブジェクトのユーザー定義データを設定します。
      ユーザー定義データは、オブジェクトごとに保存可能な値で、何に使用するかはユーザーが自由に決めることができます。
      ユーザー定義データ1〜3は、整数型の値を格納することができます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>quser2</Name>
    <Title>ユーザー定義データを設定2</Title>
    <Format>
      num,user4,user5,user6
      num(0)     : オブジェクトID
      user4(0.0) : ユーザー定義データ4(実数)
      user5(0.0) : ユーザー定義データ5(実数)
      user6(0.0) : ユーザー定義データ6(実数)
    </Format>
    <Setting>
      指定したオブジェクトのユーザー定義データを設定します。
      ユーザー定義データは、オブジェクトごとに保存可能な値で、何に使用するかはユーザーが自由に決めることができます。
      ユーザー定義データ4〜6は、実数型の値を格納することができます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qfind</Name>
    <Title>オブジェクト検索</Title>
    <Format>
      group,stat
      group(-1) : 検索するグループ値
      stat(0)   : stat値指定
    </Format>
    <Setting>
      登録されているオブジェクトを任意の条件で検索します。
      最初に、qfind命令で条件を指定した後、qnext命令で結果を受け取る必要があります。
      groupで検索するコリジョングループ値を指定します。
      groupの指定を省略するか-1の場合は、すべてのグループが対象となります。
      (ただしグループ値が0のオブジェクトは除外されます)
      複数のグループを指定する場合は、それぞれのグループ値を足した値を指定してください。
      statを指定することで、特定の状態だけを検索することが可能です。
      statが0の場合は、すべての状態が対象となります。
      statにstat_sleep(1)またはstat_active(2)を指定した場合は、同じ値を持つオブジェクトのみが対象となります。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qnext</Name>
    <Title>オブジェクト検索結果取得</Title>
    <Format>
      var
      var : 検索結果を取得する変数
    </Format>
    <Setting>
      qfind命令による検索の結果を取得します。
      最初に、qfind命令で条件を指定した後、qnext命令で結果を受け取る必要があります。
      varで指定された変数にオブジェクトID値が代入されます。(変数は自動的に整数型となります。)
      qnext命令を実行するごとに、検索結果を取り出すことができます。
      検索結果がなくなった場合は、-1が代入されます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qcollision</Name>
    <Title>コリジョン取得開始</Title>
    <Format>
      num, target
      num(0)     : オブジェクトID
      target(-1) : コリジョンを取得する対象のオブジェクトID
    </Format>
    <Setting>
      オブジェクト同士のコリジョン(衝突)に関する情報の取得を開始します。
      最初に、qcollision命令でオブジェクトを指定した後、qgetcol命令で結果を受け取る必要があります。
      targetで、コリジョンを取得する対象のオブジェクトIDします。
      targetが-1か、省略された場合は、numで指定されたオブジェクトに関わるすべての情報が取得されます。
      コリジョンの取得を行なう際には、必ずコリジョングループの設定を行なっておく必要があります。
      numで指定されたオブジェクトのパラメーターで、コリジョンログ作成グループとなっているものだけが取得されるので注意してください。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetcol</Name>
    <Title>コリジョン取得</Title>
    <Format>
      var_id,var_x,var_y
      var_id : オブジェクトIDを取得する変数
      var_x  : X座標を取得する変数
      var_y  : Y座標を取得する変数
    </Format>
    <Setting>
      qcollision命令による検索の結果を取得します。
      最初に、qcollision命令で条件を指定した後、qgetcol命令で結果を受け取る必要があります。
      さらに必要に応じて、qgetcol2命令、qgetcol3命令で追加の情報を取得することが可能です。
      var_idで指定された変数に、コリジョンが検出されたオブジェクトのID値が代入されます。(変数は自動的に整数型となります。)
      var_xで指定された変数に、コリジョンが検出されたX座標が代入されます。(変数は自動的に実数型となります。)
      var_yで指定された変数に、コリジョンが検出されたY座標が代入されます。(変数は自動的に実数型となります。)
      qgetcol命令を実行するごとに、検索結果を取り出すことができます。
      検索結果がなくなった場合は、オブジェクトIDとして-1が代入されます。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetcol2</Name>
    <Title>コリジョン詳細情報取得</Title>
    <Format>
      var_depth,var_nx,var_ny
      var_depth : 衝突の深さを取得する変数
      var_nx    : 衝突のX法線を取得する変数
      var_ny    : 衝突のY法線を取得する変数
    </Format>
    <Setting>
      qcollision命令による検索の結果を取得します。
      必ず、qgetcol命令で結果を受け取った後で、情報を取得するようにしてください。
      var_depthで指定された変数に、衝突の深さ(接触面にめりこんだ距離)が代入されます。(変数は自動的に実数型となります。)
      var_nx,var_nyで指定された変数に、衝突時の法線(x,y)が代入されます。(変数は自動的に実数型となります。)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetcol3</Name>
    <Title>コリジョン詳細情報取得2</Title>
    <Format>
      var_bound,var_slide
      var_bound : 垂直速度を取得する変数
      var_slide : 水平速度を取得する変数
    </Format>
    <Setting>
      qcollision命令による検索の結果を取得します。
      必ず、qgetcol命令で結果を受け取った後で、情報を取得するようにしてください。
      var_boundで指定された変数に、接触面と垂直（はねる）方向の速度(プラス側がめりこみ方向)が代入されます。(変数は自動的に実数型となります。)
      var_slideで指定された変数に、接触面と水平（ひきずる）方向の速度が代入されます。(変数は自動的に実数型となります。)

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgettype</Name>
    <Title>typeパラメーターを取得</Title>
    <Format>
      num,var_type
      num(0)    : オブジェクトID
      var_type  : typeパラメーターを取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_typeで指定された変数に、typeパラメーター値が代入されます。(変数は自動的に整数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetstat</Name>
    <Title>statパラメーターを取得</Title>
    <Format>
      num,var_stat,var_sleepcount
      num(0)        : オブジェクトID
      var_stat      : stat設定値を取得する変数
      var_sleepcount: スリープカウント値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_statで指定された変数に、statパラメーター値が代入されます。(変数は自動的に整数型となります。)
      var_sleepcountで指定された変数に、スリープカウント値が代入されます。(変数は自動的に整数型となります。)
      スリープカウント値は、qstatで設定した値ではなく、内部の物理計算実行回数に応じた値になっているので注意してください。
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetpos</Name>
    <Title>位置、角度パラメーターを取得</Title>
    <Format>
      num,var_x,var_y,var_angle
      num(0)     : オブジェクトID
      var_x      : X座標設定値を取得する変数
      var_y      : Y座標設定値を取得する変数
      var_angle  : 角度設定値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_xで指定された変数に、X座標設定値が代入されます。(変数は自動的に実数型となります。)
      var_yで指定された変数に、Y座標設定値が代入されます。(変数は自動的に実数型となります。)
      var_angleで指定された変数に、角度設定値が代入されます。(変数は自動的に実数型となります。)
      取得されるX,Y座標は、画面上の座標ではなくOBAQが使用する内部座標値なので注意してください。
      内部座標値を画面上の座標に変換する場合は、qcnvaxis命令を使用してください。
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetspeed</Name>
    <Title>速度パラメーターを取得</Title>
    <Format>
      num,var_px,var_py,var_pr
      num(0) : オブジェクトID
      var_px : X方向速度値を取得する変数
      var_py : Y方向速度値を取得する変数
      var_pr : 回転速度値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_pxで指定された変数に、X方向速度値が代入されます。(変数は自動的に実数型となります。)
      var_pyで指定された変数に、Y方向速度値が代入されます。(変数は自動的に実数型となります。)
      var_prで指定された変数に、回転速度値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetweight</Name>
    <Title>重さなどのパラメーターを取得</Title>
    <Format>
      num,var_weight,var_moment
      num(0)     : オブジェクトID
      var_weight : 重さの値を取得する変数
      var_moment : モーメント値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_weightで指定された変数に、重さの値が代入されます。(変数は自動的に実数型となります。)
      var_momentで指定された変数に、モーメント値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetdamper</Name>
    <Title>吸振などのパラメーターを取得</Title>
    <Format>
      num,var_damper,var_friction
      num(0) : オブジェクトID
      var_damper   : 吸振パラメーター値を取得する変数
      var_friction : 摩擦抵抗値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_damperで指定された変数に、吸振パラメーター値が代入されます。(変数は自動的に実数型となります。)
      var_frictionで指定された変数に、摩擦抵抗値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetinertia</Name>
    <Title>惰性などのパラメーターを取得</Title>
    <Format>
      num,var_inertia,var_gravity
      num(0) : オブジェクトID
      var_inertia : 惰性パラメーター値を取得する変数
      var_gravity : オブジェクトの重力値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_inertiaで指定された変数に、惰性パラメーター値が代入されます。(変数は自動的に実数型となります。)
      var_gravityで指定された変数に、オブジェクトの重力値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetgroup</Name>
    <Title>グループパラメーターを取得</Title>
    <Format>
      num,var_mygroup,var_exgroup,var_loggroup
      num(0)      : オブジェクトID
      var_mygroup : 自分が属するコリジョングループ値を取得する変数
      var_exgroup : 衝突を除外するグループ値を取得する変数
      var_loggroup: コリジョンログを作成するグループ値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_mygroupで指定された変数に、自分が属するコリジョングループ値が代入されます。(変数は自動的に整数型となります。)
      var_exgroupで指定された変数に、衝突を除外するグループ値が代入されます。(変数は自動的に整数型となります。)
      var_loggroupで指定された変数に、コリジョンログを作成するグループ値が代入されます。(変数は自動的に整数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetmat</Name>
    <Title>マテリアルパラメーターを取得</Title>
    <Format>
      num,var_type,var_id,var_subid
      num(0)    : オブジェクトID
      var_type  : マテリアルタイプ値を取得する変数
      var_id    : 参照id値を取得する変数
      var_subid : 参照subid値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_typeで指定された変数に、マテリアルタイプ値が代入されます。(変数は自動的に整数型となります。)
      var_idで指定された変数に、参照id値が代入されます。(変数は自動的に整数型となります。)
      var_subidで指定された変数に、参照subid値が代入されます。(変数は自動的に整数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetmat2</Name>
    <Title>マテリアル詳細パラメーターを取得</Title>
    <Format>
      num,var_offsetx,var_offsety,var_zoomx,var_zoomy
      num(0)   : オブジェクトID
      var_offsetx : X方向表示オフセット値を取得する変数
      var_offsety : Y方向表示オフセット値を取得する変数
      var_zoomx   : X方向表示倍率値を取得する変数
      var_zoomy   : Y方向表示倍率値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_offsetxで指定された変数に、X方向表示オフセット値が代入されます。(変数は自動的に整数型となります。)
      指定したオブジェクトのパラメーターを変数に取得します。
      var_offsetyで指定された変数に、Y方向表示オフセット値が代入されます。(変数は自動的に整数型となります。)
      指定したオブジェクトのパラメーターを変数に取得します。
      var_zoomxで指定された変数に、X方向表示倍率値が代入されます。(変数は自動的に実数型となります。)
      指定したオブジェクトのパラメーターを変数に取得します。
      var_zoomyで指定された変数に、Y方向表示倍率値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetmat3</Name>
    <Title>マテリアル表示パラメーターを取得</Title>
    <Format>
      num,var_gmode,var_rate
      num(0)   : オブジェクトID
      var_gmode : コピーモード値を取得する変数
      var_rate  : 半透明レート値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_gmodeで指定された変数に、コピーモード値が代入されます。(変数は自動的に整数型となります。)
      var_rateで指定された変数に、半透明レート値が代入されます。(変数は自動的に整数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetuser</Name>
    <Title>ユーザー定義データを取得</Title>
    <Format>
      num,var_user1,var_user2,var_user3
      num(0)   : オブジェクトID
      var_user1 : ユーザー定義データ1の値を取得する変数
      var_user2 : ユーザー定義データ2の値を取得する変数
      var_user3 : ユーザー定義データ3の値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_user1で指定された変数に、ユーザー定義データ1の値が代入されます。(変数は自動的に整数型となります。)
      var_user2で指定された変数に、ユーザー定義データ2の値が代入されます。(変数は自動的に整数型となります。)
      var_user3で指定された変数に、ユーザー定義データ3の値が代入されます。(変数は自動的に整数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetuser2</Name>
    <Title>ユーザー定義データを取得2</Title>
    <Format>
      num,var_user4,var_user5,var_user6
      num(0)     : オブジェクトID
      var_user4 : ユーザー定義データ4の値を取得する変数
      var_user5 : ユーザー定義データ5の値を取得する変数
      var_user6 : ユーザー定義データ6の値を取得する変数
    </Format>
    <Setting>
      指定したオブジェクトのパラメーターを変数に取得します。
      var_user4で指定された変数に、ユーザー定義データ4の値が代入されます。(変数は自動的に実数型となります。)
      var_user5で指定された変数に、ユーザー定義データ5の値が代入されます。(変数は自動的に実数型となります。)
      var_user6で指定された変数に、ユーザー定義データ6の値が代入されます。(変数は自動的に実数型となります。)
      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qpush</Name>
    <Title>任意の場所に力を与える</Title>
    <Format>
      num,xw,yw,ax,ay,sw
      num(0)     : オブジェクトID
      xw(0.0) : X座標(実数)
      yw(0.0) : Y座標(実数)
      ax(0.0) : X方向の力(実数)
      ay(0.0) : Y方向の力(実数)
      sw(1)   : 設定オプション
    </Format>
    <Setting>
      指定したオブジェクトに対して、(xw,yw)の位置から、(ax,ay)の強さで力を与えます。
      与えられた力に応じて、オブジェクトの姿勢や速度が変化します。
      swで、設定方法を指定することができます。

      sw     	内容
      --------------------------------------------------
      0       オブジェクトの速度に反映させない
      1       オブジェクトの速度に反映させる

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qblast</Name>
    <Title>任意の場所から放射状に力を与える</Title>
    <Format>
      xw,yw,power,near,far
      xw(0.0)    : X座標(実数)
      yw(0.0)    : Y座標(実数)
      power(1.0) : 力の大きさ(実数)
      near(1.0)  : 一番近い距離(実数)
      far(9999.0): 一番遠い距離(実数)
    </Format>
    <Setting>
      すべてのオブジェクトに対して任意の場所から放射状に力を与えます。
      (xw, yw)を中心として、距離に反比例する力が加えられます。
      powerは距離1.0の際に加わる力の大きさになります。
      nearより近い位置は、反比例せずnearと同じ力の大きさとなります。
      farより遠くにある場合は力は加わりません。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetversion</Name>
    <Title>バージョン情報を取得</Title>
    <Format>
      var
      var : バージョン情報を取得する変数
    </Format>
    <Setting>
      OBAQのバージョン情報を取得します。
      varで指定された変数に文字列としてバージョン情報が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qinner</Name>
    <Title>座標がオブジェクト内にあるかを取得</Title>
    <Format>
      var,x,y,num
      var     : 結果を取得する変数
      x(0.0)  : X座標(実数)
      y(0.0)  : Y座標(実数)
      num(-1) : オブジェクトID
    </Format>
    <Setting>
      (x,y)で指定された座標がオブジェクト形状の内側にあるかを調べます。
      numで調べたいオブジェクトのIDを指定します。
      numがマイナス値か、または省略された場合は、すべての有効なオブジェクトに渡って
      座標が内側にあるかどうかをチェックします。
      内側にある場合は、varで指定された変数にオブジェクトID値が代入されます。
      内側にない場合は、varで指定された変数に-1が代入されます。
      varで指定された変数は、自動的に整数型となります。
      (x,y)で指定する座標は、画面上の座標ではなくOBAQが使用する内部座標値になります。
      画面上の座標から結果を取得する場合は、cnvaxis命令などで内部座標値に変換を
      行なう必要があるので注意してください。

      実行に失敗した場合は、システム変数statに0以外の値が代入されます。
    </Setting>
  </command>
  <command>
    <Name>qgetptr</Name>
    <Title>システムポインタ値取得</Title>
    <Format>
      var,option
      var       : 内容を取得する変数
      option(0) : オプション値
    </Format>
    <Setting>
      OBAQのシステムポインタ値を取得します。
      このシステムポインタ値は、外部のアプリケーションやプラグイン等からOBAQの内部データにアクセスするために使用されます。
      通常の使用では、システムポインタ値は必要ありません。
      optionパラメーターでオプション値を設定することができます。
      現在、optionパラメーターは0以外の値は無効になります。
    </Setting>
  </command>
  <command>
    <Name>getobjsize</Name>
    <Title>オブジェクトのサイズと位置取得</Title>
    <Format>
      p1, p2
      p1 : オブジェクトのサイズ、位置を取得するための数値型配列変数
      p2 : オブジェクトID
    </Format>
    <Setting>
      オブジェクトのサイズと位置を取得します。
      p2にはbuttonやlistviewなど取得するオブジェクトのIDを指定します。

      p1にはオブジェクトのサイズ・位置が以下のように代入されます。
      p1(0)	幅
      p1(1)	高さ
      p1(2)	左上のx座標
      p1(3)	左上のy座標
      p1(4)	右下のx座標
      p1(5)	右下のy座標
      各座標はウィンドウ座標系です。
    </Setting>
  </command>
  <command>
    <Name>resizeobj</Name>
    <Title>オブジェクトのサイズ変更</Title>
    <Format>
      p1, p2, p3
      p1 : オブジェクトID
      p2 : サイズ・位置が入った数値型配列変数
      p3 : 位置・サイズを変更しないかどうかのフラグ
    </Format>
    <Setting>
      IDp1のオブジェクトのサイズを変更します。
      p2には幅,高さ,x座標,y座標の順に代入しておきます。

      p3を1にすると位置を変えずにサイズだけ変更します。
      p3を2にするとサイズを変えずに位置だけ変更します。
    </Setting>
  </command>
  <command>
    <Name>objgray</Name>
    <Title>オブジェクトの使用可、不可設定</Title>
    <Format>
      p1, p2
      p1 : オブジェクトID
      p2 : 使用可にするか不可にするかのフラグ
    </Format>
    <Setting>
      buttonなどのオブジェクトを使用可にしたり、不可にしたりします。
      p1にはbuttonやlistviewなどのIDを代入します。

      p2を0にするとオブジェクトを使用できない状態にし、1にすると使用できる状態にします。
      p2を-1にするとそのオブジェクトが使用可か不可かを調べます。
    </Setting>
  </command>
  <command>
    <Name>p_scrwnd</Name>
    <Title>スクリーン座標系をウィンドウ座標系に変換</Title>
    <Format>
      p1
      p1 : スクリーン座標系が入った数値型配列変数
    </Format>
    <Setting>
      スクリーン座標系をウィンドウ座標系に変換します。
      p1(0)にx座標、p1(1)にy座標を代入しておきます。
      描画対象となっているウィンドウを基準にします。
    </Setting>
  </command>
  <command>
    <Name>hspstat</Name>
    <Title>HSPランタイムの情報</Title>
    <Format></Format>
    <Setting>
      HSPランタイムの情報が整数値で代入されます。以下の情報がすべて合計された値になります。
      デバッグモード = 1
      スクリーンセーバー起動時 = 2
      コンソールモード = 16
      Macintosh版HSP = $80
      Linux版HSP = $1000
    </Setting>
  </command>
  <command>
    <Name>hspver</Name>
    <Title>HSPのバージョン番号</Title>
    <Format></Format>
    <Setting>HSP のバージョン番号が整数値で代入されます。バージョンコード +  マイナーバージョンコードの値になります。(3.0 は $3??? になる)</Setting>
  </command>
  <command>
    <Name>cnt</Name>
    <Title>ループのカウンター</Title>
    <Format></Format>
    <Setting>repeat〜loopループのカウンターが整数値で代入されます。</Setting>
  </command>
  <command>
    <Name>err</Name>
    <Title>HSPのエラーコード</Title>
    <Format></Format>
    <Setting>HSPのエラーコードです。エラーコードとメッセージの対応については、別途マニュアル(error.htm)を参照してください。</Setting>
  </command>
  <command>
    <Name>stat</Name>
    <Title>色々な命令のステータス値</Title>
    <Format></Format>
    <Setting>色々な命令を実行した結果(ステータス)が整数値で代入されます。</Setting>
  </command>
  <command>
    <Name>mousex</Name>
    <Title>マウスカーソルのX座標</Title>
    <Format></Format>
    <Setting>マウスカーソルのX座標が整数値で代入されます。</Setting>
  </command>
  <command>
    <Name>mousey</Name>
    <Title>マウスカーソルのY座標</Title>
    <Format></Format>
    <Setting>マウスカーソルのY座標が整数値で代入されます。</Setting>
  </command>
  <command>
    <Name>mousew</Name>
    <Title>マウスカーソルのホイール値</Title>
    <Format></Format>
    <Setting>ホイール付きマウスの移動量が整数値で代入されます。</Setting>
  </command>
  <command>
    <Name>strsize</Name>
    <Title>読み出しバイト数</Title>
    <Format></Format>
    <Setting>getstr、exist、bload命令などで読み出したバイト数が代入されます。</Setting>
  </command>
  <command>
    <Name>refstr</Name>
    <Title>色々な命令のステータス文字列</Title>
    <Format></Format>
    <Setting>色々な命令を実行した結果の文字列が代入されます。</Setting>
  </command>
  <command>
    <Name>looplev</Name>
    <Title>repeatのネストレベル</Title>
    <Format></Format>
    <Setting>repeat〜loopのネストレベルが代入されます。</Setting>
  </command>
  <command>
    <Name>sublev</Name>
    <Title>サブルーチンのネストレベル</Title>
    <Format></Format>
    <Setting>サブルーチン(またはユーザー定義命令、関数) のネストレベルが代入されます。</Setting>
  </command>
  <command>
    <Name>iparam</Name>
    <Title>割り込み要因を示す値</Title>
    <Format></Format>
    <Setting>
      割り込み要因を示す値が代入されます。
      oncmd命令による割り込み時は、割り込みメッセージのIDが代入されます。
      onexit命令による終了割り込み時は、通常のウィンドウクローズによる終了であれば0が、シャットダウン等のシステム通知による終了であれば1が代入されます。
    </Setting>
  </command>
  <command>
    <Name>wparam</Name>
    <Title>割り込み時のwParam</Title>
    <Format></Format>
    <Setting>割り込み時に保存される Windows のシステム値 (wParam) が代入されます。</Setting>
  </command>
  <command>
    <Name>lparam</Name>
    <Title>割り込み時のlParam</Title>
    <Format></Format>
    <Setting>割り込み時に保存される Windows のシステム値 (lParam) が代入されます。</Setting>
  </command>
  <command>
    <Name>hwnd</Name>
    <Title>現在のウィンドウハンドル</Title>
    <Format></Format>
    <Setting>
      現在選択されているウィンドウのハンドル(ポインタ)が代入されます。
      主にDLL等の外部呼出しで必要な場合に参照されます。
    </Setting>
  </command>
  <command>
    <Name>hdc</Name>
    <Title>現在のデバイスコンテキスト</Title>
    <Format></Format>
    <Setting>
      現在選択されているウィンドウのデバイスコンテキスト(ポインタ)が代入されます。
      主にDLL等の外部呼出しで必要な場合に参照されます。
    </Setting>
  </command>
  <command>
    <Name>hinstance</Name>
    <Title>現在のインスタンスハンドル</Title>
    <Format></Format>
    <Setting>
      現在実行中アプリケーションのインスタンスハンドル(ポインタ)が代入されます。
      主にDLL等の外部呼出しで必要な場合に参照されます。
    </Setting>
  </command>
  <command>
    <Name>refdval</Name>
    <Title>色々な命令のステータス実数値</Title>
    <Format></Format>
    <Setting>色々な命令を実行した結果の実数値が代入されます。</Setting>
  </command>
  <command>
    <Name>thismod</Name>
    <Title>現在の有効なモジュール変数</Title>
    <Format></Format>
    <Setting>
      モジュール変数処理のためのユーザー定義命令・関数内で、
      渡されたモジュール変数自身を示す名称として使用することができます。
      #modfuncで定義されたルーチンから、別な命令・関数を呼び出す場合に使用することができます。
    </Setting>
  </command>
  <command>
    <Name>notemax</Name>
    <Title>メモリノートパッドの行数</Title>
    <Format></Format>
    <Setting>
      現在選択されているメモリノートパッド全体の行数を示すシステム変数として使用することができます。
      noteinfo関数でも同様の情報を取得することが可能です。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>notesize</Name>
    <Title>メモリノートパッドの文字数</Title>
    <Format></Format>
    <Setting>
      現在選択されているメモリノートパッド全体の文字数(byte数)を示す
      システム変数として使用することができます。
      noteinfo関数でも同様の情報を取得することが可能です。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_mx</Name>
    <Title>スクリーン上のマウスカーソルX座標</Title>
    <Format></Format>
    <Setting>
      スクリーン上のマウスカーソルX座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_my</Name>
    <Title>スクリーン上のマウスカーソルY座標</Title>
    <Format></Format>
    <Setting>
      スクリーン上のマウスカーソルY座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_act</Name>
    <Title>アクティブなウィンドウID</Title>
    <Format></Format>
    <Setting>
      現在アクティブになっているウィンドウIDが代入されています。
      もし、 アクティブになっているウィンドウがHSP以外の場合は-1になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_sel</Name>
    <Title>操作先ウィンドウID</Title>
    <Format></Format>
    <Setting>
      gsel命令で指定した画面の操作先ウィンドウIDが代入されています。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_wx1</Name>
    <Title>ウィンドウの左上X座標</Title>
    <Format></Format>
    <Setting>
      スクリーン座標系で現在のウィンドウの左上X座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_wy1</Name>
    <Title>ウィンドウの左上Y座標</Title>
    <Format></Format>
    <Setting>
      スクリーン座標系で現在のウィンドウの左上Y座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_wx2</Name>
    <Title>ウィンドウの右下X座標</Title>
    <Format></Format>
    <Setting>
      スクリーン座標系で現在のウィンドウの右下X座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_wy2</Name>
    <Title>ウィンドウの右下Y座標</Title>
    <Format></Format>
    <Setting>
      スクリーン座標系で現在のウィンドウの右下Y座標が代入されています。
      スクリーン座標系は、 pos命令などで使用するウィンドウ内の座標ではなく、デスクトップ画面全体から見た座標になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_vx</Name>
    <Title>ウィンドウのスクロールX座標</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウのスクロールX座標が代入されています。
      これは、初期化サイズよりもウィンドウサイズが小さくなっている場合に、左上に表示されている座標がどれだけスクロールされているかを示す値です。
      スクロールさせていない通常の状態では、(0,0)になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_vy</Name>
    <Title>ウィンドウのスクロールY座標</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウのスクロールY座標が代入されています。
      これは、初期化サイズよりもウィンドウサイズが小さくなっている場合に、左上に表示されている座標がどれだけスクロールされているかを示す値です。
      スクロールさせていない通常の状態では、(0,0)になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_sizex</Name>
    <Title>ウィンドウ全体のXサイズ</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウの横幅が代入されています。
      これは、ウィンドウの枠やタイトルバーなども含めたサイズになります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_sizey</Name>
    <Title>ウィンドウ全体のYサイズ</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウの縦幅が代入されています。
      これは、ウィンドウの枠やタイトルバーなども含めたサイズになります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_winx</Name>
    <Title>画面の描画エリアXサイズ</Title>
    <Format></Format>
    <Setting>
      現在のウィンドウ描画エリアの横幅サイズが代入されています。
      (buffer命令で作成された画面の場合は、初期化された画面サイズになります。)

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_winy</Name>
    <Title>画面の描画エリアYサイズ</Title>
    <Format></Format>
    <Setting>
      現在のウィンドウ描画エリアの縦幅サイズが代入されています。
      (buffer命令で作成された画面の場合は、初期化された画面サイズになります。)

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_sx</Name>
    <Title>画面の初期化Xサイズ</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウの初期化Xサイズが代入されています。
      (最初にscreen,bgscr,buffer命令で初期化された画面サイズになります。)

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_sy</Name>
    <Title>画面の初期化Yサイズ</Title>
    <Format></Format>
    <Setting>
      現在の操作先ウィンドウの初期化Yサイズが代入されています。
      (最初にscreen,bgscr,buffer命令で初期化された画面サイズになります。)

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_mesx</Name>
    <Title>メッセージの出力Xサイズ</Title>
    <Format></Format>
    <Setting>
      最後にmes, print命令により出力されたメッセージのXサイズが代入されています。
      サイズは、 X座標にどれだけのドット数で描画されたかを示します。
      画面上の絶対座標ではないので注意してください。
      また、複数行ある文字列を出力した場合は、最後の行にあたるサイズが取得されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_mesy</Name>
    <Title>メッセージの出力Yサイズ</Title>
    <Format></Format>
    <Setting>
      最後にmes, print命令により出力されたメッセージのYサイズが代入されています。
      サイズは、 Y座標にどれだけのドット数で描画されたかを示します。
      画面上の絶対座標ではないので注意してください。
      また、複数行ある文字列を出力した場合は、最後の行にあたるサイズが取得されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_r</Name>
    <Title>現在設定されているカラーコードR</Title>
    <Format></Format>
    <Setting>
      color命令などにより指定された赤の色コード(輝度)が代入されています。
      色コードは、0〜255までの整数値になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_g</Name>
    <Title>現在設定されているカラーコードG</Title>
    <Format></Format>
    <Setting>
      color命令などにより指定された緑の色コード(輝度)が代入されています。
      色コードは、0〜255までの整数値になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_b</Name>
    <Title>現在設定されているカラーコードB</Title>
    <Format></Format>
    <Setting>
      color命令などにより指定された青の色コード(輝度)が代入されています。
      色コードは、0〜255までの整数値になります。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_paluse</Name>
    <Title>デスクトップのカラーモード</Title>
    <Format></Format>
    <Setting>
      現在のデスクトップカラーモード(色モード)が代入されています。
      フルカラーモードの場合は0が、パレットモードの場合は1が返されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_dispx</Name>
    <Title>デスクトップ全体のXサイズ</Title>
    <Format></Format>
    <Setting>
      デスクトップ全体のサイズ(画面解像度)が代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_dispy</Name>
    <Title>デスクトップ全体のYサイズ</Title>
    <Format></Format>
    <Setting>
      デスクトップ全体のサイズ(画面解像度)が代入されています。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_cx</Name>
    <Title>カレントポジションのX座標</Title>
    <Format></Format>
    <Setting>
      pos命令により設定されたカレントポジションのX座標が代入されています。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_cy</Name>
    <Title>カレントポジションのY座標</Title>
    <Format></Format>
    <Setting>
      pos命令により設定されたカレントポジションのY座標が代入されています。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_intid</Name>
    <Title>メッセージ割り込み時のウィンドウID</Title>
    <Format></Format>
    <Setting>
      oncmd命令により設定されたメッセージ割り込み時のウィンドウIDが代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_newid</Name>
    <Title>未使用ウィンドウID</Title>
    <Format></Format>
    <Setting>
      screen命令やbuffer命令などで初期化されていない未使用のウィンドウIDが返されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_accx</Name>
    <Title>加速度センサー値(X)</Title>
    <Format></Format>
    <Setting>
      加速度センサーが使用可能な環境で、センサーの値を取得します。
      X軸に対する加速度を-1.0〜+1.0の範囲で取得したものになります。
      加速度センサーが使用できない環境では、0.0が取得されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_accy</Name>
    <Title>加速度センサー値(Y)</Title>
    <Format></Format>
    <Setting>
      加速度センサーが使用可能な環境で、センサーの値を取得します。
      Y軸に対する加速度を-1.0〜+1.0の範囲で取得したものになります。
      加速度センサーが使用できない環境では、0.0が取得されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>ginfo_accz</Name>
    <Title>加速度センサー値(Z)</Title>
    <Format></Format>
    <Setting>
      加速度センサーが使用可能な環境で、センサーの値を取得します。
      Z軸に対する加速度を-1.0〜+1.0の範囲で取得したものになります。
      加速度センサーが使用できない環境では、0.0が取得されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_cur</Name>
    <Title>カレントディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      現在のカレントディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_exe</Name>
    <Title>実行ファイルがあるディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      ランタイム実行ファイルがあるディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_win</Name>
    <Title>Windowsディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      Windowsがインストールされているディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_sys</Name>
    <Title>Windowsシステムディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      Windowsのシステムディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_cmdline</Name>
    <Title>コマンドライン文字列</Title>
    <Format></Format>
    <Setting>
      実行時に渡されたコマンドライン文字列が代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_desktop</Name>
    <Title>デスクトップディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      デスクトップディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_mydoc</Name>
    <Title>マイドキュメントディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      マイドキュメントディレクトリ(フォルダ)のパスが文字列で代入されます。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
  <command>
    <Name>dir_tv</Name>
    <Title>HSPTVディレクトリ(フォルダ)</Title>
    <Format></Format>
    <Setting>
      HSPTVディレクトリ(フォルダ)のパスが文字列で代入されます。
      HSPTVディレクトリに標準で用意されたリソースを参照する場合に使用することができます。
      dir_tvは、デバッグ実行時にのみ取得され、実行(.exe)ファイルとして動作している場合は、空の文字列("")を返します。HSPTVディレクトリ内のファイルを使用するソフトの実行ファイル作成時は、#pack命令により必要なファイルを指定する必要があるので注意してください。

      ※このシステム変数は、マクロとしてhspdef.as内で定義されています。
    </Setting>
  </command>
</Index>